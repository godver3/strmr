{{template "base" .}}

{{define "title"}}Tools - strmr Admin{{end}}

{{define "content"}}
<div class="page-header">
    <h1>Tools</h1>
    <p>Import and manage your media library</p>
</div>

<!-- INTEGRATIONS CATEGORY -->
<div class="settings-group">
    <div class="group-title">Integrations</div>

    <!-- Trakt Accounts Section -->
    <div class="section" id="traktAccountSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M8 12l2 2 4-4"/>
                </svg>
                Trakt Accounts
            </div>
            <span id="traktStatusBadge" class="status-badge"></span>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Register Trakt accounts and link them to profiles. Each profile can have its own Trakt account for scrobbling.
                Create an app at <a href="https://trakt.tv/oauth/applications" target="_blank">trakt.tv/oauth/applications</a> to get Client ID and Secret.
            </p>

            <!-- Trakt Accounts List -->
            <div id="traktAccountsList" style="margin-bottom: 1.5rem;">
                <!-- Accounts will be rendered here -->
            </div>

            <!-- Add New Account Button -->
            <button class="btn btn-primary" onclick="showAddTraktAccountForm()" id="addTraktAccountBtn">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.5rem;">
                    <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                Add Trakt Account
            </button>

            <!-- Add Account Form (hidden by default) -->
            <div id="traktAddAccountForm" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border);">
                <h4 style="margin-bottom: 1rem;">Add New Trakt Account</h4>
                <div class="form-group">
                    <label class="form-label">Account Name</label>
                    <input type="text" class="form-input" id="newTraktAccountName" placeholder="e.g., Family Account">
                </div>
                <div class="form-group">
                    <label class="form-label">Client ID</label>
                    <input type="text" class="form-input" id="newTraktClientId" placeholder="From trakt.tv/oauth/applications">
                </div>
                <div class="form-group">
                    <label class="form-label">Client Secret</label>
                    <input type="password" class="form-input" id="newTraktClientSecret" placeholder="From trakt.tv/oauth/applications">
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="hideAddTraktAccountForm()">Cancel</button>
                    <button class="btn btn-primary" onclick="createTraktAccount()">Create Account</button>
                </div>
            </div>

            <!-- OAuth Waiting Modal -->
            <div id="traktAuthModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center;">
                <div style="background: var(--bg-elevated); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <div class="spinner" style="margin: 0 auto 1rem;"></div>
                    <h3 style="margin-bottom: 0.5rem;">Waiting for authorization...</h3>
                    <p class="text-muted" style="margin-bottom: 1rem;">
                        Go to <a id="traktAuthUrl" href="#" target="_blank" style="color: var(--accent);">trakt.tv/activate</a> and enter code:
                    </p>
                    <div id="traktUserCode" style="font-family: monospace; font-size: 2rem; font-weight: bold; color: var(--accent); margin-bottom: 1.5rem;"></div>
                    <button class="btn btn-secondary" onclick="cancelTraktAuth()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile-Trakt Linking Section -->
    <div class="section" id="profileTraktLinkingSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="8.5" cy="7" r="4"/>
                    <line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/>
                </svg>
                Profile Trakt Linking
            </div>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Link each profile to a Trakt account. When a profile watches content, it will sync to their linked Trakt account.
                <br><strong style="color: var(--text-secondary);">Note:</strong> Syncing only occurs if the linked Trakt account has scrobbling enabled (toggle above).
            </p>
            <div id="profileTraktLinkingList">
                <!-- Profile linking rows will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Plex Accounts Section -->
    <div class="section" id="plexAccountSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
                Plex Accounts
            </div>
            <span id="plexStatusBadge" class="status-badge"></span>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Register Plex accounts and link them to profiles for watchlist imports.
            </p>

            <!-- Plex Accounts List -->
            <div id="plexAccountsList" style="margin-bottom: 1.5rem;">
                <!-- Accounts will be rendered here -->
            </div>

            <!-- Add New Account Button -->
            <button class="btn btn-primary" onclick="showAddPlexAccountForm()" id="addPlexAccountBtn">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.5rem;">
                    <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                Add Plex Account
            </button>

            <!-- Add Account Form (hidden by default) -->
            <div id="plexAddAccountForm" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border);">
                <h4 style="margin-bottom: 1rem;">Add New Plex Account</h4>
                <div class="form-group">
                    <label class="form-label">Account Name</label>
                    <input type="text" class="form-input" id="newPlexAccountName" placeholder="e.g., Family Account">
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="hidePlexAddAccountForm()">Cancel</button>
                    <button class="btn btn-primary" onclick="createPlexAccount()">Create Account</button>
                </div>
            </div>

            <!-- OAuth Waiting Modal -->
            <div id="plexAuthModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center;">
                <div style="background: var(--bg-elevated); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <div class="spinner" style="margin: 0 auto 1rem;"></div>
                    <h3 style="margin-bottom: 0.5rem;">Waiting for authorization...</h3>
                    <p class="text-muted" style="margin-bottom: 1rem;">
                        Complete the login in the Plex popup window.<br>
                        <small>If the popup was blocked, go to <a href="https://plex.tv/link" target="_blank" style="color: var(--accent);">plex.tv/link</a> and enter code: <strong id="plexUserCode" style="color: var(--accent);"></strong></small>
                    </p>
                    <button class="btn btn-secondary" onclick="cancelPlexAuth()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- AUTOMATION CATEGORY (admin only) -->
{{if .IsAdmin}}
<div class="settings-group">
    <div class="group-title">Automation</div>

    <!-- Scheduled Tasks Section -->
    <div class="section" id="scheduledTasksSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                </svg>
                Scheduled Tasks
            </div>
            <span id="scheduledTasksCountBadge" class="status-badge"></span>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Automate recurring tasks like syncing watchlists or importing data from connected services.
            </p>

            <!-- Scheduled Tasks List -->
            <div id="scheduledTasksList" style="margin-bottom: 1.5rem;">
                <div class="loading-box">
                    <div class="spinner"></div>
                    <span>Loading tasks...</span>
                </div>
            </div>

            <!-- Empty State -->
            <div id="scheduledTasksEmptyState" style="display: none; text-align: center; padding: 2rem; color: var(--text-muted);">
                <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity: 0.5; margin-bottom: 1rem;">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                </svg>
                <p>No scheduled tasks configured.</p>
                <p style="font-size: 0.875rem;">Create a task to automate syncing from connected services.</p>
            </div>

            <!-- Add New Task Button -->
            <button class="btn btn-primary" onclick="showAddScheduledTaskModal()" id="addScheduledTaskBtn">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.5rem;">
                    <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                Add Scheduled Task
            </button>

            <!-- Add Task Modal -->
            <div id="addScheduledTaskModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center;">
                <div style="background: var(--bg-elevated); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <h3 style="margin-bottom: 1rem;">Add Scheduled Task</h3>

                    <div class="form-group">
                        <label class="form-label">Task Type</label>
                        <select id="newTaskType" class="form-select" onchange="onTaskTypeChange()">
                            <option value="plex_watchlist_sync">Plex Watchlist Sync</option>
                            <option value="trakt_list_sync">Trakt List Sync</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Task Name</label>
                        <input type="text" class="form-input" id="newTaskName" placeholder="e.g., Sync Family Plex Watchlist">
                    </div>

                    <!-- Plex Watchlist Sync specific config -->
                    <div id="plexWatchlistSyncConfig">
                        <div class="form-group">
                            <label class="form-label">Plex Account</label>
                            <select id="newTaskPlexAccount" class="form-select">
                                <!-- Populated by JavaScript -->
                            </select>
                            <small class="text-muted">Select a connected Plex account to sync from</small>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Sync to Profile</label>
                            <select id="newTaskProfile" class="form-select">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>
                    </div>

                    <!-- Trakt List Sync specific config -->
                    <div id="traktListSyncConfig" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Trakt Account</label>
                            <select id="newTaskTraktAccount" class="form-select" onchange="onTraktAccountChange()">
                                <!-- Populated by JavaScript -->
                            </select>
                            <small class="text-muted">Select a connected Trakt account to sync from</small>
                        </div>

                        <div class="form-group">
                            <label class="form-label">List Type</label>
                            <select id="newTaskListType" class="form-select" onchange="onListTypeChange()">
                                <option value="watchlist" selected>Watchlist</option>
                                <option value="collection">Collection</option>
                                <option value="favorites">Favorites</option>
                                <option value="custom">Custom List</option>
                            </select>
                            <small class="text-muted">Which Trakt list to sync</small>
                        </div>

                        <div class="form-group" id="customListGroup" style="display: none;">
                            <label class="form-label">Custom List</label>
                            <select id="newTaskCustomList" class="form-select">
                                <option value="">Loading lists...</option>
                            </select>
                            <small class="text-muted">Select a custom list to sync</small>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Sync to Profile</label>
                            <select id="newTaskTraktProfile" class="form-select">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>
                    </div>

                    <!-- Sync Options (shown for sync-type tasks) -->
                    <div id="syncOptionsConfig" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                        <div class="form-group">
                            <label class="form-label">Sync Direction</label>
                            <select id="newTaskSyncDirection" class="form-select" onchange="onSyncDirectionChange()">
                                <option value="source_to_target" selected>Plex → strmr (Import from Plex)</option>
                                <option value="target_to_source">strmr → Plex (Export to Plex)</option>
                                <option value="bidirectional">Bidirectional (Sync both ways)</option>
                            </select>
                            <small class="text-muted">Direction of data flow during sync</small>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Delete Behavior</label>
                            <select id="newTaskDeleteBehavior" class="form-select">
                                <option value="additive" selected>Additive (only add, never remove)</option>
                                <option value="delete">Delete (remove synced items, keep manually added)</option>
                                <option value="mirror">Mirror (exact copy, removes everything not in source)</option>
                            </select>
                            <small class="text-muted">How to handle items removed from source</small>
                        </div>

                        <div class="form-group" id="conflictResolutionGroup" style="display: none;">
                            <label class="form-label">Conflict Resolution</label>
                            <select id="newTaskConflictResolution" class="form-select">
                                <option value="source_wins" selected>Source wins</option>
                                <option value="target_wins">Target wins</option>
                            </select>
                            <small class="text-muted">How to resolve conflicts in bidirectional sync</small>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Frequency</label>
                        <select id="newTaskFrequency" class="form-select">
                            <option value="1min">Every Minute</option>
                            <option value="5min">Every 5 Minutes</option>
                            <option value="15min">Every 15 Minutes</option>
                            <option value="30min">Every 30 Minutes</option>
                            <option value="hourly">Every Hour</option>
                            <option value="6hours">Every 6 Hours</option>
                            <option value="12hours" selected>Every 12 Hours</option>
                            <option value="daily">Daily</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="newTaskEnabled" checked>
                            Enable task immediately
                        </label>
                    </div>

                    <div class="form-group" id="dryRunGroup">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="newTaskDryRun">
                            Dry run (test without making changes)
                        </label>
                        <small class="text-muted">When enabled, the task will log what it would do without actually syncing</small>
                    </div>

                    <div class="btn-group" style="margin-top: 1.5rem;">
                        <button class="btn btn-secondary" onclick="hideAddScheduledTaskModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="createScheduledTask()">Create Task</button>
                    </div>
                </div>
            </div>

            <!-- Edit Task Modal -->
            <div id="editScheduledTaskModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center;">
                <div style="background: var(--bg-elevated); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <h3 style="margin-bottom: 1rem;">Edit Scheduled Task</h3>
                    <input type="hidden" id="editTaskId">

                    <div class="form-group">
                        <label class="form-label">Task Type</label>
                        <select id="editTaskType" class="form-select" disabled>
                            <option value="plex_watchlist_sync">Plex Watchlist Sync</option>
                            <option value="trakt_list_sync">Trakt List Sync</option>
                        </select>
                        <small class="text-muted">Task type cannot be changed</small>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Task Name</label>
                        <input type="text" class="form-input" id="editTaskName" placeholder="e.g., Sync Family Plex Watchlist">
                    </div>

                    <!-- Plex Watchlist Sync specific config -->
                    <div id="editPlexWatchlistSyncConfig">
                        <div class="form-group">
                            <label class="form-label">Plex Account</label>
                            <select id="editTaskPlexAccount" class="form-select">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Sync to Profile</label>
                            <select id="editTaskProfile" class="form-select">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>
                    </div>

                    <!-- Trakt List Sync specific config -->
                    <div id="editTraktListSyncConfig" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Trakt Account</label>
                            <select id="editTaskTraktAccount" class="form-select" onchange="onEditTraktAccountChange()">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">List Type</label>
                            <select id="editTaskListType" class="form-select" onchange="onEditListTypeChange()">
                                <option value="watchlist">Watchlist</option>
                                <option value="collection">Collection</option>
                                <option value="favorites">Favorites</option>
                                <option value="custom">Custom List</option>
                            </select>
                        </div>

                        <div class="form-group" id="editCustomListGroup" style="display: none;">
                            <label class="form-label">Custom List</label>
                            <select id="editTaskCustomList" class="form-select">
                                <option value="">Loading lists...</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Sync to Profile</label>
                            <select id="editTaskTraktProfile" class="form-select">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>
                    </div>

                    <!-- Sync Options (shown for sync-type tasks) -->
                    <div id="editSyncOptionsConfig" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                        <div class="form-group">
                            <label class="form-label">Sync Direction</label>
                            <select id="editTaskSyncDirection" class="form-select" onchange="onEditSyncDirectionChange()">
                                <option value="source_to_target">Plex → strmr (Import from Plex)</option>
                                <option value="target_to_source">strmr → Plex (Export to Plex)</option>
                                <option value="bidirectional">Bidirectional (Sync both ways)</option>
                            </select>
                            <small class="text-muted">Direction of data flow during sync</small>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Delete Behavior</label>
                            <select id="editTaskDeleteBehavior" class="form-select">
                                <option value="additive">Additive (only add, never remove)</option>
                                <option value="delete">Delete (remove synced items, keep manually added)</option>
                                <option value="mirror">Mirror (exact copy, removes everything not in source)</option>
                            </select>
                            <small class="text-muted">How to handle items removed from source</small>
                        </div>

                        <div class="form-group" id="editConflictResolutionGroup" style="display: none;">
                            <label class="form-label">Conflict Resolution</label>
                            <select id="editTaskConflictResolution" class="form-select">
                                <option value="source_wins">Source wins</option>
                                <option value="target_wins">Target wins</option>
                            </select>
                            <small class="text-muted">How to resolve conflicts in bidirectional sync</small>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Frequency</label>
                        <select id="editTaskFrequency" class="form-select">
                            <option value="1min">Every Minute</option>
                            <option value="5min">Every 5 Minutes</option>
                            <option value="15min">Every 15 Minutes</option>
                            <option value="30min">Every 30 Minutes</option>
                            <option value="hourly">Every Hour</option>
                            <option value="6hours">Every 6 Hours</option>
                            <option value="12hours">Every 12 Hours</option>
                            <option value="daily">Daily</option>
                        </select>
                    </div>

                    <div class="form-group" id="editDryRunGroup">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="editTaskDryRun">
                            Dry run (test without making changes)
                        </label>
                        <small class="text-muted">When enabled, the task will log what it would do without actually syncing</small>
                    </div>

                    <div class="btn-group" style="margin-top: 1.5rem;">
                        <button class="btn btn-secondary" onclick="hideEditScheduledTaskModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="updateScheduledTask()">Save Changes</button>
                    </div>
                </div>
            </div>

            <!-- Dry Run Results Modal -->
            <div id="dryRunResultsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center;">
                <div style="background: var(--bg-elevated); padding: 2rem; border-radius: 12px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="margin: 0;">Dry Run Results</h3>
                        <button class="btn btn-secondary btn-sm" onclick="hideDryRunResultsModal()" style="padding: 0.25rem 0.5rem;">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                    </div>
                    <p class="text-muted" style="margin-bottom: 1rem;">These changes would be made if the task runs without dry run mode:</p>

                    <div id="dryRunToAddSection" style="margin-bottom: 1.5rem;">
                        <h4 style="color: var(--success); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Items to Add (<span id="dryRunToAddCount">0</span>)
                        </h4>
                        <div id="dryRunToAddList" style="max-height: 200px; overflow-y: auto; background: var(--bg-surface); border-radius: 8px; padding: 0.5rem;"></div>
                    </div>

                    <div id="dryRunToRemoveSection">
                        <h4 style="color: var(--danger); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Items to Remove (<span id="dryRunToRemoveCount">0</span>)
                        </h4>
                        <div id="dryRunToRemoveList" style="max-height: 200px; overflow-y: auto; background: var(--bg-surface); border-radius: 8px; padding: 0.5rem;"></div>
                    </div>

                    <div class="btn-group" style="margin-top: 1.5rem;">
                        <button class="btn btn-secondary" onclick="hideDryRunResultsModal()">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{{end}}

<!-- DEVICES CATEGORY -->
<div class="settings-group">
    <div class="group-title">Devices</div>

    <!-- Client Management Section -->
    <div class="section" id="clientManagementSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                    <line x1="8" y1="21" x2="16" y2="21"/>
                    <line x1="12" y1="17" x2="12" y2="21"/>
                </svg>
                Client Management
            </div>
            <span id="clientCountBadge" class="status-badge"></span>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Manage registered client devices. Ping to identify devices, reassign them to different profiles, or remove them.
            </p>

            <!-- Filter by profile -->
            <div class="form-group" style="margin-bottom: 1rem;">
                <label class="form-label">Filter by Profile</label>
                <select id="clientProfileFilter" class="form-select" style="max-width: 300px;" onchange="filterClientsByProfile()">
                    <option value="">All Profiles</option>
                    {{range .Users}}
                    <option value="{{.ID}}">{{.Name}}</option>
                    {{end}}
                </select>
            </div>

            <!-- Clients List -->
            <div id="clientsList" style="margin-bottom: 1rem;">
                <div class="loading-box">
                    <div class="spinner"></div>
                    <span>Loading clients...</span>
                </div>
            </div>

            <!-- Empty state -->
            <div id="clientsEmptyState" style="display: none; text-align: center; padding: 2rem; color: var(--text-muted);">
                <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity: 0.5; margin-bottom: 1rem;">
                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                    <line x1="8" y1="21" x2="16" y2="21"/>
                    <line x1="12" y1="17" x2="12" y2="21"/>
                </svg>
                <p>No client devices registered yet.</p>
                <p style="font-size: 0.875rem;">Devices will appear here when they connect to the server.</p>
            </div>
        </div>
    </div>
</div>

<!-- IMPORT CATEGORY -->
<div class="settings-group">
    <div class="group-title">Import</div>

    <!-- Watchlist Section -->
    <div class="section" id="watchlistSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                </svg>
                Watchlist
            </div>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <!-- Plex Watchlist Import -->
            <div class="import-card">
                <div class="import-card-header">
                    <h3>Plex Watchlist</h3>
                </div>
                <div class="import-card-body" id="plexWatchlistCard">
                    <!-- Not Connected -->
                    <div id="plexWatchlistNotConnected">
                        <p class="text-muted">Connect your Plex account in the Integrations section above to import your watchlist.</p>
                    </div>

                    <!-- Connected - Ready to import -->
                    <div id="plexWatchlistConnected" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Import from Plex Account</label>
                            <select id="plexWatchlistAccountSelect" class="form-select" style="max-width: 300px;">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Import to Profile</label>
                            <select id="plexProfileSelect" class="form-select" style="max-width: 300px;">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>

                        <!-- Action buttons - swap between Load and Import -->
                        <div id="plexFetchBtnWrapper">
                            <button class="btn btn-primary" onclick="fetchPlexWatchlist()" id="plexFetchBtn">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Load Watchlist from Plex
                            </button>
                        </div>
                        <div id="plexImportBtnWrapper" style="display: none;">
                            <div class="import-action-bar">
                                <button class="btn btn-primary" onclick="importPlexWatchlist()" id="plexImportBtn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Import <span id="plexSelectedCount">0</span> Selected
                                </button>
                                <button class="btn btn-secondary" onclick="resetPlexWatchlistLoad()">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"/>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                    </svg>
                                    Reload
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="plexLoadingSection" style="display: none;">
                        <div class="loading-box">
                            <div class="spinner"></div>
                            <span id="plexWatchlistLoadingText">Loading watchlist...</span>
                            <div id="plexWatchlistProgress" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted);"></div>
                        </div>
                    </div>

                    <!-- Preview Table -->
                    <div id="plexPreviewSection" style="display: none; margin-top: 1rem;">
                        <div class="preview-header">
                            <div>
                                <span class="preview-count" id="plexWatchlistCount">0 items</span>
                                <span class="text-muted"> in your Plex watchlist</span>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-sm" onclick="plexSelectAll(true)">Select All</button>
                                <button class="btn btn-secondary btn-sm" onclick="plexSelectAll(false)">Deselect All</button>
                            </div>
                        </div>

                        <div class="table-container">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"><input type="checkbox" id="plexSelectAllCheckbox" onchange="plexSelectAll(this.checked)" checked></th>
                                        <th style="width: 50px;"></th>
                                        <th>Title</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Type</th>
                                        <th style="width: 100px;">IDs</th>
                                    </tr>
                                </thead>
                                <tbody id="plexWatchlistTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Import Progress -->
                    <div id="plexImportingSection" style="display: none; margin-top: 1rem;">
                        <div class="status-box">
                            <div class="spinner"></div>
                            <div>
                                <div class="status-title">Importing items...</div>
                                <div class="text-muted" id="plexImportProgress">0 of 0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Complete -->
                    <div id="plexCompleteSection" style="display: none; margin-top: 1rem;">
                        <div class="success-box">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                            <div>
                                <div class="status-title" style="color: var(--success);">Import Complete</div>
                                <div id="plexImportSummary" class="text-muted"></div>
                            </div>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="resetPlexImport()">Import More</button>
                    </div>
                </div>
            </div>

            <!-- Trakt Watchlist Import -->
            <div class="import-card">
                <div class="import-card-header">
                    <h3>Trakt Watchlist</h3>
                </div>
                <div class="import-card-body" id="traktWatchlistCard">
                    <!-- Not Connected -->
                    <div id="traktWatchlistNotConnected">
                        <p class="text-muted">Connect your Trakt account in the Integrations section above to import your watchlist.</p>
                    </div>

                    <!-- Connected - Ready to import -->
                    <div id="traktWatchlistConnected" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Import from Trakt Account</label>
                            <select id="traktWatchlistAccountSelect" class="form-select" style="max-width: 300px;">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Import to Profile</label>
                            <select id="traktWatchlistProfileSelect" class="form-select" style="max-width: 300px;">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>

                        <!-- Action buttons - swap between Load and Import -->
                        <div id="traktWatchlistFetchBtnWrapper">
                            <button class="btn btn-primary" onclick="fetchTraktWatchlist()" id="traktWatchlistFetchBtn">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Load Watchlist from Trakt
                            </button>
                        </div>
                        <div id="traktWatchlistImportBtnWrapper" style="display: none;">
                            <div class="import-action-bar">
                                <button class="btn btn-primary" onclick="importTraktWatchlist()" id="traktWatchlistImportBtn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Import <span id="traktWatchlistSelectedCount">0</span> Selected
                                </button>
                                <button class="btn btn-secondary" onclick="resetTraktWatchlistLoad()">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"/>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                    </svg>
                                    Reload
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="traktWatchlistLoadingSection" style="display: none;">
                        <div class="loading-box">
                            <div class="spinner"></div>
                            <span>Loading watchlist...</span>
                        </div>
                    </div>

                    <!-- Preview Table -->
                    <div id="traktWatchlistPreviewSection" style="display: none; margin-top: 1rem;">
                        <div class="preview-header">
                            <div>
                                <span class="preview-count" id="traktWatchlistCount">0 items</span>
                                <span class="text-muted"> in your Trakt watchlist</span>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-sm" onclick="traktWatchlistSelectAll(true)">Select All</button>
                                <button class="btn btn-secondary btn-sm" onclick="traktWatchlistSelectAll(false)">Deselect All</button>
                            </div>
                        </div>

                        <div class="table-container">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"><input type="checkbox" id="traktWatchlistSelectAllCheckbox" onchange="traktWatchlistSelectAll(this.checked)" checked></th>
                                        <th>Title</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Type</th>
                                        <th style="width: 100px;">IDs</th>
                                    </tr>
                                </thead>
                                <tbody id="traktWatchlistTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Import Progress -->
                    <div id="traktWatchlistImportingSection" style="display: none; margin-top: 1rem;">
                        <div class="status-box">
                            <div class="spinner"></div>
                            <div>
                                <div class="status-title">Importing items...</div>
                                <div class="text-muted" id="traktWatchlistImportProgress">0 of 0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Complete -->
                    <div id="traktWatchlistCompleteSection" style="display: none; margin-top: 1rem;">
                        <div class="success-box">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                            <div>
                                <div class="status-title" style="color: var(--success);">Import Complete</div>
                                <div id="traktWatchlistImportSummary" class="text-muted"></div>
                            </div>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="resetTraktWatchlistImport()">Import More</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Watch History Section -->
    <div class="section" id="historySection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                </svg>
                Watch History
            </div>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <!-- Plex Watch History Import -->
            <div class="import-card">
                <div class="import-card-header">
                    <h3>Plex Watch History</h3>
                </div>
                <div class="import-card-body" id="plexHistoryCard">
                    <!-- Not Connected -->
                    <div id="plexHistoryNotConnected">
                        <p class="text-muted">Connect your Plex account in the Integrations section above to import your watch history.</p>
                    </div>

                    <!-- Connected - Ready to import -->
                    <div id="plexHistoryConnected" style="display: none;">
                        <p class="text-muted" style="margin-bottom: 1rem;">
                            <strong>Note:</strong> This imports watch history from your Plex Media Server(s). Your server must be online and accessible.
                        </p>
                        <div class="form-group">
                            <label class="form-label">Import from Plex Account</label>
                            <select id="plexHistoryAccountSelect" class="form-select" style="max-width: 300px;" onchange="onPlexHistoryAccountChange()">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Filter by Plex User</label>
                            <select id="plexHistoryUserSelect" class="form-select" style="max-width: 300px;">
                                <option value="0">All Users</option>
                                <!-- Populated by JavaScript when account is selected -->
                            </select>
                            <small class="text-muted">Select which Plex user's watch history to import</small>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Import to Profile</label>
                            <select id="plexHistoryProfileSelect" class="form-select" style="max-width: 300px;">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>

                        <!-- Action buttons - swap between Load and Import -->
                        <div id="plexHistoryFetchBtnWrapper">
                            <button class="btn btn-primary" onclick="fetchPlexHistory()" id="plexHistoryFetchBtn">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Load History from Plex
                            </button>
                        </div>
                        <div id="plexHistoryImportBtnWrapper" style="display: none;">
                            <div class="import-action-bar">
                                <button class="btn btn-primary" onclick="importPlexHistory()" id="plexHistoryImportBtn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Import <span id="plexHistorySelectedCount">0</span> Selected
                                </button>
                                <button class="btn btn-secondary" onclick="resetPlexHistoryLoad()">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"/>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                    </svg>
                                    Reload
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="plexHistoryLoading" style="display: none;">
                        <div class="loading-box">
                            <div class="spinner"></div>
                            <span id="plexHistoryLoadingText">Loading watch history from Plex servers...</span>
                            <div id="plexHistoryProgress" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted);"></div>
                        </div>
                    </div>

                    <!-- Preview Table -->
                    <div id="plexHistoryPreview" style="display: none; margin-top: 1rem;">
                        <div class="preview-header">
                            <div>
                                <span class="preview-count" id="plexHistoryCount">0 items</span>
                                <span class="text-muted"> in your Plex history</span>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-sm" onclick="plexHistorySelectAll(true)">Select All</button>
                                <button class="btn btn-secondary btn-sm" onclick="plexHistorySelectAll(false)">Deselect All</button>
                            </div>
                        </div>

                        <div class="table-container">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"><input type="checkbox" id="plexHistorySelectAllCheckbox" onchange="plexHistorySelectAll(this.checked)" checked></th>
                                        <th>Title</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Type</th>
                                        <th style="width: 150px;">Watched</th>
                                        <th style="width: 120px;">Server</th>
                                    </tr>
                                </thead>
                                <tbody id="plexHistoryTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Import Progress -->
                    <div id="plexHistoryImporting" style="display: none; margin-top: 1rem;">
                        <div class="status-box">
                            <div class="spinner"></div>
                            <div>
                                <div class="status-title">Importing items...</div>
                                <div class="text-muted" id="plexHistoryImportProgress">0 of 0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Complete -->
                    <div id="plexHistoryComplete" style="display: none; margin-top: 1rem;">
                        <div class="success-box">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                            <div>
                                <div class="status-title" style="color: var(--success);">Import Complete</div>
                                <div id="plexHistoryImportSummary" class="text-muted"></div>
                            </div>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="resetPlexHistoryImport()">Import More</button>
                    </div>
                </div>
            </div>

            <!-- Trakt Watch History Import -->
            <div class="import-card">
                <div class="import-card-header">
                    <h3>Trakt Watch History</h3>
                </div>
                <div class="import-card-body" id="traktHistoryCard">
                    <!-- Not Connected -->
                    <div id="traktHistoryNotConnected">
                        <p class="text-muted">Connect your Trakt account in the Integrations section above to import your watch history.</p>
                    </div>

                    <!-- Connected - Ready to import -->
                    <div id="traktHistoryConnected" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Import from Trakt Account</label>
                            <select id="traktHistoryAccountSelect" class="form-select" style="max-width: 300px;">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Import to Profile</label>
                            <select id="traktHistoryProfileSelect" class="form-select" style="max-width: 300px;">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>

                        <!-- Action buttons - swap between Load and Import -->
                        <div id="traktHistoryFetchBtnWrapper">
                            <button class="btn btn-primary" onclick="fetchTraktHistory()" id="traktHistoryFetchBtn">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Load History from Trakt
                            </button>
                        </div>
                        <div id="traktHistoryImportBtnWrapper" style="display: none;">
                            <div class="import-action-bar">
                                <button class="btn btn-primary" onclick="importTraktHistory()" id="traktHistoryImportBtn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Import <span id="traktHistorySelectedCount">0</span> Selected
                                </button>
                                <button class="btn btn-secondary" onclick="resetTraktHistoryLoad()">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"/>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                    </svg>
                                    Reload
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="traktHistoryLoading" style="display: none;">
                        <div class="loading-box">
                            <div class="spinner"></div>
                            <span>Loading watch history...</span>
                        </div>
                    </div>

                    <!-- Preview Table -->
                    <div id="traktHistoryPreview" style="display: none; margin-top: 1rem;">
                        <div class="preview-header">
                            <div>
                                <span class="preview-count" id="traktHistoryCount">0 items</span>
                                <span class="text-muted"> in your Trakt history</span>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-sm" onclick="traktHistorySelectAll(true)">Select All</button>
                                <button class="btn btn-secondary btn-sm" onclick="traktHistorySelectAll(false)">Deselect All</button>
                            </div>
                        </div>

                        <div class="table-container">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"><input type="checkbox" id="traktHistorySelectAllCheckbox" onchange="traktHistorySelectAll(this.checked)" checked></th>
                                        <th>Title</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Type</th>
                                        <th style="width: 150px;">Watched</th>
                                    </tr>
                                </thead>
                                <tbody id="traktHistoryTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Import Progress -->
                    <div id="traktHistoryImporting" style="display: none; margin-top: 1rem;">
                        <div class="status-box">
                            <div class="spinner"></div>
                            <div>
                                <div class="status-title">Importing items...</div>
                                <div class="text-muted" id="traktHistoryImportProgress">0 of 0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Complete -->
                    <div id="traktHistoryComplete" style="display: none; margin-top: 1rem;">
                        <div class="success-box">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                            <div>
                                <div class="status-title" style="color: var(--success);">Import Complete</div>
                                <div id="traktHistoryImportSummary" class="text-muted"></div>
                            </div>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="resetTraktHistoryImport()">Import More</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    /* Link styling - consistent light grey with underline */
    a {
        color: #9ca3af;
        text-decoration: underline;
    }
    a:visited {
        color: #9ca3af;
    }
    a:hover {
        color: #d1d5db;
    }
    .settings-group {
        margin-bottom: 2rem;
    }
    .group-title {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin-bottom: 0.75rem;
        padding-left: 0.25rem;
    }
    .section {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        margin-bottom: 0.5rem;
        overflow: hidden;
    }
    .section-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem 1.25rem;
        cursor: pointer;
        transition: background 0.15s;
    }
    .section-header:hover {
        background: var(--bg-hover);
    }
    .section-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 500;
        flex: 1;
    }
    .section-toggle {
        transition: transform 0.2s;
    }
    .section.open .section-toggle {
        transform: rotate(180deg);
    }
    .section-content {
        display: none;
        padding: 0 1.25rem 1.25rem;
    }
    .section.open .section-content {
        display: block;
    }
    .import-card {
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        margin-bottom: 1rem;
        overflow: hidden;
    }
    .import-card:last-child {
        margin-bottom: 0;
    }
    .import-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border);
        background: var(--bg-secondary);
    }
    .import-card-header h3 {
        margin: 0;
        font-size: 0.9375rem;
        font-weight: 500;
    }
    .import-card-body {
        padding: 1rem;
    }
    .todo-card {
        opacity: 0.7;
    }
    .todo-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        background: var(--warning);
        color: var(--bg-primary);
        border-radius: 4px;
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    .status-badge {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
    }
    .status-badge.connected {
        background: rgba(34, 197, 94, 0.15);
        color: var(--success);
    }
    .status-badge.disconnected {
        background: var(--bg-tertiary);
        color: var(--text-muted);
    }
    /* Toggle switch styling */
    .toggle-option {
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    .toggle-label {
        flex: 1;
    }
    .toggle-title {
        font-weight: 500;
        margin-bottom: 0.25rem;
    }
    .toggle-description {
        font-size: 0.875rem;
    }
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--bg-tertiary);
        transition: 0.3s;
        border-radius: 24px;
    }
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
    }
    .toggle-switch input:checked + .toggle-slider {
        background-color: var(--accent);
    }
    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(20px);
    }
    .toggle-switch input:disabled + .toggle-slider {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .status-box {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: var(--radius);
    }
    .status-title {
        font-weight: 500;
    }
    .loading-box {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        padding: 2rem;
        color: var(--text-muted);
    }
    .success-box {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem;
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid var(--success);
        border-radius: var(--radius);
    }
    .connected-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem;
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid var(--success);
        border-radius: var(--radius);
    }
    .connected-status .btn {
        margin-left: auto;
    }
    .preview-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.75rem;
    }
    .preview-count {
        font-weight: 500;
    }
    .table-container {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: var(--radius);
    }
    .data-table {
        width: 100%;
        border-collapse: collapse;
    }
    .data-table th,
    .data-table td {
        padding: 0.75rem 1rem;
        text-align: left;
        border-bottom: 1px solid var(--border);
    }
    .data-table th {
        background: var(--bg-secondary);
        font-weight: 500;
        font-size: 0.875rem;
        color: var(--text-secondary);
    }
    .data-table tbody tr:hover {
        background: var(--bg-hover);
    }
    .data-table tbody tr.disabled {
        opacity: 0.5;
    }
    .import-actions {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    .import-action-bar {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 1rem;
    }
    .poster-thumb {
        width: 35px;
        height: 52px;
        object-fit: cover;
        border-radius: 4px;
        background: var(--bg-tertiary);
    }
    .type-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
    }
    .type-badge.movie {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent);
    }
    .type-badge.series {
        background: rgba(34, 197, 94, 0.2);
        color: var(--success);
    }
    .type-badge.episode {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
    }
    .id-badges {
        display: flex;
        gap: 0.25rem;
        flex-wrap: wrap;
    }
    .id-badge {
        font-size: 0.7rem;
        padding: 0.125rem 0.375rem;
        background: var(--bg-secondary);
        border-radius: 3px;
        color: var(--text-muted);
    }
    input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
    }
    .text-muted {
        color: var(--text-muted);
    }
    .form-group {
        margin-bottom: 1rem;
    }
    .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    .form-input {
        width: 100%;
        max-width: 400px;
        padding: 0.5rem 0.75rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        color: var(--text-primary);
        font-size: 0.875rem;
    }
    .form-input:focus {
        outline: none;
        border-color: var(--accent);
    }
    .btn-group {
        display: flex;
        gap: 0.5rem;
    }
    /* Client Management Cards */
    .client-cards {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    .client-card {
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        overflow: hidden;
    }
    .client-card-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 0.875rem 1rem;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border);
        gap: 1rem;
    }
    .client-info {
        flex: 1;
        min-width: 0;
    }
    .client-name {
        font-weight: 500;
        font-size: 0.9375rem;
        word-break: break-word;
    }
    .client-meta {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-top: 0.25rem;
    }
    .client-id {
        font-size: 0.7rem;
        color: var(--text-muted);
        font-family: monospace;
        margin-top: 0.25rem;
    }
    .client-last-seen {
        font-size: 0.75rem;
        color: var(--text-muted);
        white-space: nowrap;
        padding: 0.25rem 0.5rem;
        background: var(--bg-tertiary);
        border-radius: 4px;
    }
    .client-card-body {
        padding: 0.875rem 1rem;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
    }
    .client-profile-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex: 1;
        min-width: 200px;
    }
    .client-label {
        font-size: 0.875rem;
        color: var(--text-secondary);
        white-space: nowrap;
    }
    .client-profile-select {
        flex: 1;
        max-width: 200px;
        font-size: 0.875rem;
    }
    .client-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    .client-actions .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }
    /* Mobile adjustments */
    @media (max-width: 480px) {
        .client-card-body {
            flex-direction: column;
            align-items: stretch;
        }
        .client-profile-row {
            min-width: 100%;
        }
        .client-profile-select {
            max-width: none;
        }
        .client-actions {
            justify-content: flex-end;
        }
    }
</style>
{{end}}

{{define "scripts"}}
<script>
    // ========== Section Toggle ==========
    function toggleSection(header) {
        const section = header.parentElement;
        section.classList.toggle('open');
    }

    // ========== Plex State ==========
    let plexAccounts = [];
    let plexWatchlistItems = [];
    let plexSelectedItems = new Set();
    let plexPollInterval = null;
    let plexAuthAccountId = null;
    // Plex history state
    let plexHistoryItems = [];
    let plexHistorySelectedItems = new Set();

    // ========== Trakt State ==========
    let traktAccounts = [];
    let traktHistoryItems = [];
    let traktHistorySelectedItems = new Set();
    let traktWatchlistItems = [];
    let traktWatchlistSelectedItems = new Set();
    let traktAuthAccountId = null;
    let traktPollInterval = null;
    let userProfiles = [];

    // ========== Client Management State ==========
    let allClients = [];
    let filteredClients = [];
    const basePath = '{{.BasePath}}';

    // ========== Scheduled Tasks State ==========
    let scheduledTasks = [];

    // ========== Initialize ==========
    document.addEventListener('DOMContentLoaded', async function() {
        // Load profiles first so client dropdowns are populated
        await loadUserProfiles();
        // Then load everything else in parallel
        await Promise.all([loadPlexAccounts(), loadTraktAccounts(), loadClients(), loadScheduledTasks()]);
    });

    // ========== Plex Account Functions ==========
    async function loadPlexAccounts() {
        try {
            const response = await fetch('/admin/api/plex/accounts');
            const data = await response.json();
            plexAccounts = data.accounts || [];
            renderPlexAccountsList();
            updatePlexStatusBadge();
            updatePlexWatchlistSection();
            updatePlexHistoryUI();
        } catch (err) {
            console.error('Failed to load Plex accounts:', err);
        }
    }

    function updatePlexStatusBadge() {
        const badge = document.getElementById('plexStatusBadge');
        const connectedCount = plexAccounts.filter(a => a.connected).length;
        if (connectedCount > 0) {
            badge.textContent = `${connectedCount} Connected`;
            badge.className = 'status-badge connected';
        } else if (plexAccounts.length > 0) {
            badge.textContent = 'Not Connected';
            badge.className = 'status-badge disconnected';
        } else {
            badge.textContent = 'No Accounts';
            badge.className = 'status-badge';
        }
    }

    function renderPlexAccountsList() {
        const container = document.getElementById('plexAccountsList');
        if (plexAccounts.length === 0) {
            container.innerHTML = '<p class="text-muted">No Plex accounts configured. Add one to get started.</p>';
            return;
        }

        container.innerHTML = plexAccounts.map(account => `
            <div class="plex-account-card" style="padding: 1rem; margin-bottom: 0.75rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border); overflow: hidden;">
                <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: flex-start; gap: 0.75rem;">
                    <div style="flex: 1; min-width: 150px;">
                        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                            <strong style="word-break: break-word;">${escapeHtml(account.name || 'Unnamed Account')}</strong>
                            ${account.connected ?
                                `<span class="status-badge connected" style="font-size: 0.75rem;">Connected</span>` :
                                `<span class="status-badge disconnected" style="font-size: 0.75rem;">Not Connected</span>`
                            }
                        </div>
                        ${account.connected && account.username ?
                            `<div class="text-muted" style="font-size: 0.875rem;">Logged in as ${escapeHtml(account.username)}</div>` :
                            ''
                        }
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; flex-shrink: 0; align-items: center;">
                        ${account.connected ? `
                            <button class="btn btn-secondary btn-sm" onclick="disconnectPlexAccount('${account.id}')">Disconnect</button>
                        ` : `
                            <button class="btn btn-primary btn-sm" onclick="connectPlexAccount('${account.id}')">Connect</button>
                        `}
                        <button class="btn btn-secondary btn-sm" onclick="deletePlexAccount('${account.id}')" style="color: var(--danger);">Delete</button>
                    </div>
                </div>
            </div>
        `).join('');
    }

    function showAddPlexAccountForm() {
        document.getElementById('plexAddAccountForm').style.display = 'block';
        document.getElementById('addPlexAccountBtn').style.display = 'none';
    }

    function hidePlexAddAccountForm() {
        document.getElementById('plexAddAccountForm').style.display = 'none';
        document.getElementById('addPlexAccountBtn').style.display = 'inline-flex';
        document.getElementById('newPlexAccountName').value = '';
    }

    async function createPlexAccount() {
        const name = document.getElementById('newPlexAccountName').value.trim();

        try {
            const response = await fetch('/admin/api/plex/accounts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name || 'Plex Account' })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create account');
            }

            showToast('Plex account created', 'success');
            hidePlexAddAccountForm();
            await loadPlexAccounts();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function deletePlexAccount(accountId) {
        if (!confirm('Delete this Plex account? Any linked profiles will be unlinked.')) return;

        try {
            const response = await fetch(`/admin/api/plex/accounts/${accountId}`, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to delete account');
            }
            showToast('Plex account deleted', 'success');
            await loadPlexAccounts();
            await loadUserProfiles();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    let plexAuthWindow = null;

    async function connectPlexAccount(accountId) {
        try {
            const response = await fetch(`/admin/api/plex/accounts/${accountId}/pin`, { method: 'POST' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to start auth');
            }

            const data = await response.json();
            plexAuthAccountId = accountId;

            // Open Plex auth in popup window
            plexAuthWindow = window.open(data.authUrl, 'plex_auth', 'width=800,height=600');

            // Show waiting modal
            document.getElementById('plexAuthModal').style.display = 'flex';
            document.getElementById('plexUserCode').textContent = data.code;

            // Start polling
            plexPollInterval = setInterval(() => pollPlexAuth(accountId, data.id), 2000);

            // Set timeout (5 minutes)
            setTimeout(() => {
                if (plexPollInterval) {
                    clearInterval(plexPollInterval);
                    plexPollInterval = null;
                    cancelPlexAuth();
                    showToast('Authorization timed out', 'error');
                }
            }, 300000);
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function pollPlexAuth(accountId, pinId) {
        try {
            const response = await fetch(`/admin/api/plex/accounts/${accountId}/pin/${pinId}`);
            const data = await response.json();

            if (data.authenticated) {
                clearInterval(plexPollInterval);
                plexPollInterval = null;

                // Close popup window if still open
                if (plexAuthWindow && !plexAuthWindow.closed) {
                    plexAuthWindow.close();
                }
                plexAuthWindow = null;

                document.getElementById('plexAuthModal').style.display = 'none';
                showToast('Successfully connected to Plex', 'success');
                await loadPlexAccounts();
            }
        } catch (err) {
            console.error('Poll error:', err);
        }
    }

    function cancelPlexAuth() {
        if (plexPollInterval) {
            clearInterval(plexPollInterval);
            plexPollInterval = null;
        }
        // Close popup window if still open
        if (plexAuthWindow && !plexAuthWindow.closed) {
            plexAuthWindow.close();
        }
        plexAuthWindow = null;
        document.getElementById('plexAuthModal').style.display = 'none';
        plexAuthAccountId = null;
    }

    async function disconnectPlexAccount(accountId) {
        try {
            const response = await fetch(`/admin/api/plex/accounts/${accountId}/disconnect`, { method: 'POST' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to disconnect');
            }
            showToast('Disconnected from Plex', 'success');
            await loadPlexAccounts();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    function updatePlexWatchlistSection() {
        const watchlistNotConnected = document.getElementById('plexWatchlistNotConnected');
        const watchlistConnected = document.getElementById('plexWatchlistConnected');
        const accountSelect = document.getElementById('plexWatchlistAccountSelect');

        const connectedAccounts = plexAccounts.filter(a => a.connected);

        if (connectedAccounts.length > 0) {
            if (watchlistNotConnected) watchlistNotConnected.style.display = 'none';
            if (watchlistConnected) watchlistConnected.style.display = 'block';

            // Populate account select for watchlist import
            if (accountSelect) {
                accountSelect.innerHTML = connectedAccounts.map(acc =>
                    `<option value="${acc.id}">${escapeHtml(acc.name)}${acc.username ? ` (${escapeHtml(acc.username)})` : ''}</option>`
                ).join('');
            }
        } else {
            if (watchlistNotConnected) watchlistNotConnected.style.display = 'block';
            if (watchlistConnected) watchlistConnected.style.display = 'none';
        }
    }

    // ========== User Profiles Functions ==========
    async function loadUserProfiles() {
        try {
            const response = await fetch('/admin/api/profiles');
            if (response.ok) {
                userProfiles = await response.json();
                renderProfileTraktLinking();
            }
        } catch (err) {
            console.error('Failed to load user profiles:', err);
        }
    }

    // ========== Trakt Accounts Functions ==========
    async function loadTraktAccounts() {
        try {
            const response = await fetch('/admin/api/trakt/accounts');
            const data = await response.json();
            traktAccounts = data.accounts || [];
            renderTraktAccountsList();
            updateTraktStatusBadge();
            updateTraktHistorySection();
            updateTraktWatchlistSection();
            renderProfileTraktLinking();
        } catch (err) {
            console.error('Failed to load Trakt accounts:', err);
        }
    }

    function updateTraktStatusBadge() {
        const badge = document.getElementById('traktStatusBadge');
        const connectedCount = traktAccounts.filter(a => a.connected).length;
        if (connectedCount > 0) {
            badge.textContent = `${connectedCount} Connected`;
            badge.className = 'status-badge connected';
        } else if (traktAccounts.length > 0) {
            badge.textContent = 'Not Connected';
            badge.className = 'status-badge disconnected';
        } else {
            badge.textContent = 'No Accounts';
            badge.className = 'status-badge';
        }
    }

    function renderTraktAccountsList() {
        const container = document.getElementById('traktAccountsList');
        if (traktAccounts.length === 0) {
            container.innerHTML = '<p class="text-muted">No Trakt accounts configured. Add one to get started.</p>';
            return;
        }

        container.innerHTML = traktAccounts.map(account => `
            <div class="trakt-account-card" style="padding: 1rem; margin-bottom: 0.75rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border); overflow: hidden;">
                <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: flex-start; gap: 0.75rem;">
                    <div style="flex: 1; min-width: 150px;">
                        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                            <strong style="word-break: break-word;">${escapeHtml(account.name || 'Unnamed Account')}</strong>
                            ${account.connected ?
                                `<span class="status-badge connected" style="font-size: 0.75rem;">Connected</span>` :
                                `<span class="status-badge disconnected" style="font-size: 0.75rem;">Not Connected</span>`
                            }
                        </div>
                        ${account.connected && account.username ?
                            `<div class="text-muted" style="font-size: 0.875rem;">Logged in as ${escapeHtml(account.username)}</div>` :
                            ''
                        }
                        ${account.linkedProfiles && account.linkedProfiles.length > 0 ?
                            `<div class="text-muted" style="font-size: 0.8rem; margin-top: 0.25rem;">
                                Linked to: ${account.linkedProfiles.map(pid => {
                                    const profile = userProfiles.find(p => p.id === pid);
                                    return profile ? escapeHtml(profile.name) : pid;
                                }).join(', ')}
                            </div>` :
                            ''
                        }
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; flex-shrink: 0; align-items: center;">
                        ${account.connected ? `
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-right: 0.5rem;" title="Enable scrobbling to sync watch history to Trakt">
                                <label class="toggle-switch">
                                    <input type="checkbox" ${account.scrobblingEnabled ? 'checked' : ''} onchange="toggleAccountScrobbling('${account.id}', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span style="font-size: 0.75rem; color: var(--text-muted);">Scrobble</span>
                            </div>
                            <button class="btn btn-secondary btn-sm" onclick="disconnectTraktAccount('${account.id}')">Disconnect</button>
                        ` : `
                            <button class="btn btn-primary btn-sm" onclick="connectTraktAccount('${account.id}')">Connect</button>
                        `}
                        <button class="btn btn-secondary btn-sm" onclick="deleteTraktAccount('${account.id}')" style="color: var(--danger);">Delete</button>
                    </div>
                </div>
            </div>
        `).join('');
    }

    function renderProfileTraktLinking() {
        const container = document.getElementById('profileTraktLinkingList');
        if (userProfiles.length === 0) {
            container.innerHTML = '<p class="text-muted">No profiles found.</p>';
            return;
        }

        const connectedAccounts = traktAccounts.filter(a => a.connected);

        container.innerHTML = userProfiles.map(profile => {
            const currentAccountId = profile.traktAccountId || '';
            // Check if current account ID exists in any account (connected or not)
            const currentAccountExists = currentAccountId && traktAccounts.some(a => a.id === currentAccountId);
            const currentAccountConnected = currentAccountId && connectedAccounts.some(a => a.id === currentAccountId);
            // Show warning if profile has an account ID that doesn't exist
            const orphanedLink = currentAccountId && !currentAccountExists;

            return `
                <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; padding: 0.75rem; margin-bottom: 0.5rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border); gap: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; min-width: 120px;">
                        <div style="width: 36px; height: 36px; border-radius: 50%; background: ${profile.color || 'var(--bg-elevated)'}; display: flex; align-items: center; justify-content: center; font-weight: 600; color: white; flex-shrink: 0;">
                            ${profile.name.charAt(0).toUpperCase()}
                        </div>
                        <span style="font-weight: 500;">${escapeHtml(profile.name)}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                        ${orphanedLink ? `<span class="status-badge" style="background: var(--warning); color: #000; font-size: 0.7rem;">Orphaned link</span>` : ''}
                        <select class="form-select" style="max-width: 200px; min-width: 150px;" onchange="updateProfileTraktLink('${profile.id}', this.value)">
                            <option value="" ${!currentAccountId ? 'selected' : ''}>No Trakt Account</option>
                            ${orphanedLink ? `<option value="${currentAccountId}" selected style="color: var(--warning);">⚠ Unknown Account</option>` : ''}
                            ${connectedAccounts.map(acc => `
                                <option value="${acc.id}" ${currentAccountId === acc.id ? 'selected' : ''}>
                                    ${escapeHtml(acc.name || acc.username || 'Unnamed')}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                </div>
            `;
        }).join('');
    }

    function showAddTraktAccountForm() {
        document.getElementById('traktAddAccountForm').style.display = 'block';
        document.getElementById('addTraktAccountBtn').style.display = 'none';
    }

    function hideAddTraktAccountForm() {
        document.getElementById('traktAddAccountForm').style.display = 'none';
        document.getElementById('addTraktAccountBtn').style.display = 'inline-flex';
        document.getElementById('newTraktAccountName').value = '';
        document.getElementById('newTraktClientId').value = '';
        document.getElementById('newTraktClientSecret').value = '';
    }

    async function createTraktAccount() {
        const name = document.getElementById('newTraktAccountName').value.trim();
        const clientId = document.getElementById('newTraktClientId').value.trim();
        const clientSecret = document.getElementById('newTraktClientSecret').value.trim();

        if (!clientId || !clientSecret) {
            showToast('Client ID and Client Secret are required', 'error');
            return;
        }

        try {
            const response = await fetch('/admin/api/trakt/accounts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name || 'Trakt Account', clientId, clientSecret })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create account');
            }

            showToast('Trakt account created', 'success');
            hideAddTraktAccountForm();
            await loadTraktAccounts();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function deleteTraktAccount(accountId) {
        if (!confirm('Delete this Trakt account? Any linked profiles will be unlinked.')) return;

        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}`, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to delete account');
            }
            showToast('Trakt account deleted', 'success');
            await loadTraktAccounts();
            await loadUserProfiles();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function connectTraktAccount(accountId) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/auth/start`, { method: 'POST' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to start auth');
            }

            const data = await response.json();
            traktAuthAccountId = accountId;

            // Show auth modal
            document.getElementById('traktAuthModal').style.display = 'flex';
            document.getElementById('traktUserCode').textContent = data.userCode;
            document.getElementById('traktAuthUrl').href = data.verificationUrl;
            document.getElementById('traktAuthUrl').textContent = data.verificationUrl;

            // Start polling
            const pollInterval = (data.interval || 5) * 1000;
            traktPollInterval = setInterval(() => pollTraktAuth(accountId, data.deviceCode), pollInterval);

            // Set timeout
            setTimeout(() => {
                if (traktPollInterval) {
                    clearInterval(traktPollInterval);
                    traktPollInterval = null;
                    cancelTraktAuth();
                    showToast('Authorization timed out', 'error');
                }
            }, (data.expiresIn || 600) * 1000);
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function pollTraktAuth(accountId, deviceCode) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/auth/check/${deviceCode}`);
            const data = await response.json();

            if (data.authenticated) {
                clearInterval(traktPollInterval);
                traktPollInterval = null;
                document.getElementById('traktAuthModal').style.display = 'none';
                showToast('Successfully connected to Trakt', 'success');
                await loadTraktAccounts();
                renderProfileTraktLinking();
            }
        } catch (err) {
            console.error('Poll error:', err);
        }
    }

    function cancelTraktAuth() {
        if (traktPollInterval) {
            clearInterval(traktPollInterval);
            traktPollInterval = null;
        }
        document.getElementById('traktAuthModal').style.display = 'none';
        traktAuthAccountId = null;
    }

    async function disconnectTraktAccount(accountId) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/disconnect`, { method: 'POST' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to disconnect');
            }
            showToast('Disconnected from Trakt', 'success');
            await loadTraktAccounts();
            renderProfileTraktLinking();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function toggleAccountScrobbling(accountId, enabled) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/scrobbling`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled })
            });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to update scrobbling');
            }
            showToast(`Scrobbling ${enabled ? 'enabled' : 'disabled'}`, 'success');
        } catch (err) {
            showToast(err.message, 'error');
            // Reload to reset toggle state
            await loadTraktAccounts();
        }
    }

    async function updateProfileTraktLink(profileId, traktAccountId) {
        try {
            const method = traktAccountId ? 'PUT' : 'DELETE';
            const response = await fetch(`/admin/api/users/${profileId}/trakt`, {
                method,
                headers: { 'Content-Type': 'application/json' },
                body: traktAccountId ? JSON.stringify({ traktAccountId }) : undefined
            });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to update profile');
            }
            showToast(traktAccountId ? 'Profile linked to Trakt account' : 'Profile unlinked from Trakt', 'success');
            await loadUserProfiles();
            await loadTraktAccounts();
        } catch (err) {
            showToast(err.message, 'error');
            await loadUserProfiles();
        }
    }

    function updateTraktHistorySection() {
        const historyNotConnected = document.getElementById('traktHistoryNotConnected');
        const historyConnected = document.getElementById('traktHistoryConnected');
        const accountSelect = document.getElementById('traktHistoryAccountSelect');

        const connectedAccounts = traktAccounts.filter(a => a.connected);

        if (connectedAccounts.length > 0) {
            if (historyNotConnected) historyNotConnected.style.display = 'none';
            if (historyConnected) historyConnected.style.display = 'block';

            // Populate account select for history import
            if (accountSelect) {
                accountSelect.innerHTML = connectedAccounts.map(acc =>
                    `<option value="${acc.id}">${escapeHtml(acc.name || acc.username || 'Unnamed')}</option>`
                ).join('');
            }
        } else {
            if (historyNotConnected) historyNotConnected.style.display = 'block';
            if (historyConnected) historyConnected.style.display = 'none';
        }
    }

    // ========== Trakt Watchlist Functions ==========
    function updateTraktWatchlistSection() {
        const watchlistNotConnected = document.getElementById('traktWatchlistNotConnected');
        const watchlistConnected = document.getElementById('traktWatchlistConnected');
        const accountSelect = document.getElementById('traktWatchlistAccountSelect');

        const connectedAccounts = traktAccounts.filter(a => a.connected);

        if (connectedAccounts.length > 0) {
            if (watchlistNotConnected) watchlistNotConnected.style.display = 'none';
            if (watchlistConnected) watchlistConnected.style.display = 'block';

            // Populate account select for watchlist import
            if (accountSelect) {
                accountSelect.innerHTML = connectedAccounts.map(acc =>
                    `<option value="${acc.id}">${escapeHtml(acc.name || acc.username || 'Unnamed')}</option>`
                ).join('');
            }
        } else {
            if (watchlistNotConnected) watchlistNotConnected.style.display = 'block';
            if (watchlistConnected) watchlistConnected.style.display = 'none';
        }
    }

    async function fetchTraktWatchlist() {
        const accountSelect = document.getElementById('traktWatchlistAccountSelect');
        const accountId = accountSelect.value;

        if (!accountId) {
            showToast('Please select a Trakt account', 'error');
            return;
        }

        const fetchBtn = document.getElementById('traktWatchlistFetchBtn');
        fetchBtn.disabled = true;
        document.getElementById('traktWatchlistLoadingSection').style.display = 'block';
        document.getElementById('traktWatchlistPreviewSection').style.display = 'none';
        document.getElementById('traktWatchlistFetchBtnWrapper').style.display = 'none';

        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/watchlist`);

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to fetch watchlist');
            }

            const data = await response.json();
            traktWatchlistItems = data.items || [];

            // Select all items by default
            traktWatchlistSelectedItems.clear();
            traktWatchlistItems.forEach((item, index) => traktWatchlistSelectedItems.add(index));

            renderTraktWatchlistTable();
            document.getElementById('traktWatchlistLoadingSection').style.display = 'none';
            document.getElementById('traktWatchlistPreviewSection').style.display = 'block';
            document.getElementById('traktWatchlistImportBtnWrapper').style.display = 'block';
            updateTraktWatchlistSelectedCount();

        } catch (err) {
            showToast(err.message, 'error');
            document.getElementById('traktWatchlistLoadingSection').style.display = 'none';
            document.getElementById('traktWatchlistFetchBtnWrapper').style.display = 'block';
        } finally {
            fetchBtn.disabled = false;
        }
    }

    function renderTraktWatchlistTable() {
        const tbody = document.getElementById('traktWatchlistTableBody');
        const countEl = document.getElementById('traktWatchlistCount');

        countEl.textContent = `${traktWatchlistItems.length} item${traktWatchlistItems.length !== 1 ? 's' : ''}`;

        if (traktWatchlistItems.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--text-muted); padding: 2rem;">Your Trakt watchlist is empty</td></tr>';
            return;
        }

        tbody.innerHTML = traktWatchlistItems.map((item, index) => {
            const isSelected = traktWatchlistSelectedItems.has(index);
            const ids = item.externalIds || {};
            const idBadges = Object.entries(ids)
                .filter(([k, v]) => v)
                .map(([k, v]) => `<span class="id-badge">${k.toUpperCase()}</span>`)
                .join('');

            return `
                <tr class="${isSelected ? '' : 'disabled'}">
                    <td>
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleTraktWatchlistItem(${index}, this.checked)">
                    </td>
                    <td style="font-weight: 500;">${escapeHtml(item.title || 'Unknown Title')}</td>
                    <td style="color: var(--text-muted);">${item.year || '-'}</td>
                    <td><span class="type-badge ${item.type}">${item.type}</span></td>
                    <td><div class="id-badges">${idBadges || '<span class="id-badge">TRAKT</span>'}</div></td>
                </tr>
            `;
        }).join('');
    }

    function toggleTraktWatchlistItem(index, checked) {
        if (checked) {
            traktWatchlistSelectedItems.add(index);
        } else {
            traktWatchlistSelectedItems.delete(index);
        }
        updateTraktWatchlistSelectedCount();
        updateTraktWatchlistRowStyles();
    }

    function traktWatchlistSelectAll(checked) {
        traktWatchlistSelectedItems.clear();
        if (checked) {
            traktWatchlistItems.forEach((item, index) => traktWatchlistSelectedItems.add(index));
        }

        document.querySelectorAll('#traktWatchlistTableBody input[type="checkbox"]').forEach(cb => {
            cb.checked = checked;
        });
        document.getElementById('traktWatchlistSelectAllCheckbox').checked = checked;

        updateTraktWatchlistSelectedCount();
        updateTraktWatchlistRowStyles();
    }

    function updateTraktWatchlistSelectedCount() {
        document.getElementById('traktWatchlistSelectedCount').textContent = traktWatchlistSelectedItems.size;
        document.getElementById('traktWatchlistImportBtn').disabled = traktWatchlistSelectedItems.size === 0;

        const selectAllCb = document.getElementById('traktWatchlistSelectAllCheckbox');
        selectAllCb.checked = traktWatchlistSelectedItems.size === traktWatchlistItems.length;
        selectAllCb.indeterminate = traktWatchlistSelectedItems.size > 0 && traktWatchlistSelectedItems.size < traktWatchlistItems.length;
    }

    function updateTraktWatchlistRowStyles() {
        document.querySelectorAll('#traktWatchlistTableBody tr').forEach((row, index) => {
            if (traktWatchlistItems[index]) {
                const isSelected = traktWatchlistSelectedItems.has(index);
                row.classList.toggle('disabled', !isSelected);
            }
        });
    }

    async function importTraktWatchlist() {
        if (traktWatchlistSelectedItems.size === 0) {
            showToast('Please select at least one item to import', 'error');
            return;
        }

        const profileId = document.getElementById('traktWatchlistProfileSelect').value;
        if (!profileId) {
            showToast('Please select a profile', 'error');
            return;
        }

        const itemsToImport = traktWatchlistItems.filter((item, index) => traktWatchlistSelectedItems.has(index));

        document.getElementById('traktWatchlistPreviewSection').style.display = 'none';
        document.getElementById('traktWatchlistImportBtnWrapper').style.display = 'none';
        document.getElementById('traktWatchlistImportingSection').style.display = 'block';
        document.getElementById('traktWatchlistImportProgress').textContent = `0 of ${itemsToImport.length}`;

        try {
            const response = await fetch('/admin/api/trakt/import/watchlist', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    profileId: profileId,
                    items: itemsToImport
                })
            });

            const result = await response.json();

            document.getElementById('traktWatchlistImportingSection').style.display = 'none';
            document.getElementById('traktWatchlistCompleteSection').style.display = 'block';

            let summary = `Successfully imported ${result.imported} item${result.imported !== 1 ? 's' : ''}.`;
            if (result.failed > 0) {
                summary += ` ${result.failed} item${result.failed !== 1 ? 's' : ''} failed.`;
            }
            document.getElementById('traktWatchlistImportSummary').textContent = summary;

            if (result.success) {
                showToast(`Imported ${result.imported} items to watchlist`, 'success');
            } else {
                showToast(`Imported ${result.imported} items with ${result.failed} failures`, 'warning');
            }

        } catch (err) {
            document.getElementById('traktWatchlistImportingSection').style.display = 'none';
            document.getElementById('traktWatchlistPreviewSection').style.display = 'block';
            document.getElementById('traktWatchlistImportBtnWrapper').style.display = 'block';
            showToast('Import failed: ' + err.message, 'error');
        }
    }

    function resetTraktWatchlistImport() {
        document.getElementById('traktWatchlistCompleteSection').style.display = 'none';
        document.getElementById('traktWatchlistImportBtnWrapper').style.display = 'none';
        document.getElementById('traktWatchlistFetchBtnWrapper').style.display = 'block';
        traktWatchlistItems = [];
        traktWatchlistSelectedItems.clear();
    }

    function resetTraktWatchlistLoad() {
        document.getElementById('traktWatchlistPreviewSection').style.display = 'none';
        document.getElementById('traktWatchlistImportBtnWrapper').style.display = 'none';
        document.getElementById('traktWatchlistFetchBtnWrapper').style.display = 'block';
        traktWatchlistItems = [];
        traktWatchlistSelectedItems.clear();
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Legacy compatibility - redirect old function calls
    function loadTraktStatus() { loadTraktAccounts(); }
    function saveTraktCredentials() { showAddTraktAccountForm(); }

    // ========== Trakt History Import Functions ==========
    async function fetchTraktHistory() {
        const fetchBtn = document.getElementById('traktHistoryFetchBtn');
        const accountSelect = document.getElementById('traktHistoryAccountSelect');
        const accountId = accountSelect?.value;

        if (!accountId) {
            showToast('Please select a Trakt account', 'error');
            return;
        }

        fetchBtn.disabled = true;
        document.getElementById('traktHistoryLoading').style.display = 'block';
        document.getElementById('traktHistoryPreview').style.display = 'none';
        document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'none';

        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/history?all=true`);
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to fetch history');
            }

            const data = await response.json();
            traktHistoryItems = data.items || [];

            // Select all by default
            traktHistorySelectedItems.clear();
            traktHistoryItems.forEach((item, idx) => traktHistorySelectedItems.add(idx));

            renderTraktHistoryTable();
            document.getElementById('traktHistoryLoading').style.display = 'none';
            document.getElementById('traktHistoryPreview').style.display = 'block';
            document.getElementById('traktHistoryImportBtnWrapper').style.display = 'block';
            updateTraktHistorySelectedCount();

        } catch (err) {
            showToast(err.message, 'error');
            document.getElementById('traktHistoryLoading').style.display = 'none';
            document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'block';
        } finally {
            fetchBtn.disabled = false;
        }
    }

    function renderTraktHistoryTable() {
        const tbody = document.getElementById('traktHistoryTableBody');
        const countEl = document.getElementById('traktHistoryCount');

        countEl.textContent = `${traktHistoryItems.length} item${traktHistoryItems.length !== 1 ? 's' : ''}`;

        if (traktHistoryItems.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--text-muted); padding: 2rem;">Your Trakt history is empty</td></tr>';
            return;
        }

        tbody.innerHTML = traktHistoryItems.map((item, idx) => {
            const isSelected = traktHistorySelectedItems.has(idx);
            const watchedDate = new Date(item.watchedAt).toLocaleDateString();

            return `
                <tr class="${isSelected ? '' : 'disabled'}">
                    <td>
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleTraktHistoryItem(${idx}, this.checked)">
                    </td>
                    <td style="font-weight: 500;">${escapeHtml(item.title)}</td>
                    <td style="color: var(--text-muted);">${item.year || '-'}</td>
                    <td><span class="type-badge ${item.type}">${item.type}</span></td>
                    <td style="color: var(--text-muted);">${watchedDate}</td>
                </tr>
            `;
        }).join('');
    }

    function toggleTraktHistoryItem(idx, checked) {
        if (checked) {
            traktHistorySelectedItems.add(idx);
        } else {
            traktHistorySelectedItems.delete(idx);
        }
        updateTraktHistorySelectedCount();
        updateTraktHistoryRowStyles();
    }

    function traktHistorySelectAll(checked) {
        traktHistorySelectedItems.clear();
        if (checked) {
            traktHistoryItems.forEach((_, idx) => traktHistorySelectedItems.add(idx));
        }

        document.querySelectorAll('#traktHistoryTableBody input[type="checkbox"]').forEach(cb => {
            cb.checked = checked;
        });
        document.getElementById('traktHistorySelectAllCheckbox').checked = checked;

        updateTraktHistorySelectedCount();
        updateTraktHistoryRowStyles();
    }

    function updateTraktHistorySelectedCount() {
        document.getElementById('traktHistorySelectedCount').textContent = traktHistorySelectedItems.size;
        document.getElementById('traktHistoryImportBtn').disabled = traktHistorySelectedItems.size === 0;

        const selectAllCb = document.getElementById('traktHistorySelectAllCheckbox');
        selectAllCb.checked = traktHistorySelectedItems.size === traktHistoryItems.length;
        selectAllCb.indeterminate = traktHistorySelectedItems.size > 0 && traktHistorySelectedItems.size < traktHistoryItems.length;
    }

    function updateTraktHistoryRowStyles() {
        document.querySelectorAll('#traktHistoryTableBody tr').forEach((row, idx) => {
            if (traktHistoryItems[idx]) {
                row.classList.toggle('disabled', !traktHistorySelectedItems.has(idx));
            }
        });
    }

    async function importTraktHistory() {
        if (traktHistorySelectedItems.size === 0) {
            showToast('Please select at least one item to import', 'error');
            return;
        }

        const profileId = document.getElementById('traktHistoryProfileSelect').value;
        if (!profileId) {
            showToast('Please select a profile', 'error');
            return;
        }

        const itemsToImport = Array.from(traktHistorySelectedItems).map(idx => traktHistoryItems[idx]);

        document.getElementById('traktHistoryPreview').style.display = 'none';
        document.getElementById('traktHistoryImporting').style.display = 'block';
        document.getElementById('traktHistoryImportProgress').textContent = `0 of ${itemsToImport.length}`;

        try {
            const response = await fetch('/admin/api/trakt/import/history', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    profileId: profileId,
                    items: itemsToImport
                })
            });

            const result = await response.json();

            document.getElementById('traktHistoryImporting').style.display = 'none';
            document.getElementById('traktHistoryComplete').style.display = 'block';

            let summary = `Successfully imported ${result.imported} item${result.imported !== 1 ? 's' : ''}.`;
            if (result.failed > 0) {
                summary += ` ${result.failed} item${result.failed !== 1 ? 's' : ''} failed.`;
            }
            document.getElementById('traktHistoryImportSummary').textContent = summary;

            if (result.success) {
                showToast(`Imported ${result.imported} items to watch history`, 'success');
            } else {
                showToast(`Imported ${result.imported} items with ${result.failed} failures`, 'warning');
            }

        } catch (err) {
            document.getElementById('traktHistoryImporting').style.display = 'none';
            document.getElementById('traktHistoryPreview').style.display = 'block';
            showToast('Import failed: ' + err.message, 'error');
        }
    }

    function resetTraktHistoryImport() {
        document.getElementById('traktHistoryComplete').style.display = 'none';
        document.getElementById('traktHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'block';
        traktHistoryItems = [];
        traktHistorySelectedItems.clear();
    }

    function resetTraktHistoryLoad() {
        document.getElementById('traktHistoryPreview').style.display = 'none';
        document.getElementById('traktHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'block';
        traktHistoryItems = [];
        traktHistorySelectedItems.clear();
    }

    // ========== Plex Watchlist Functions ==========
    async function fetchPlexWatchlist() {
        const accountSelect = document.getElementById('plexWatchlistAccountSelect');
        const accountId = accountSelect.value;

        if (!accountId) {
            showToast('Please select a Plex account', 'error');
            return;
        }

        const fetchBtn = document.getElementById('plexFetchBtn');
        const loadingText = document.getElementById('plexWatchlistLoadingText');
        const progressEl = document.getElementById('plexWatchlistProgress');

        fetchBtn.disabled = true;
        document.getElementById('plexLoadingSection').style.display = 'block';
        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexFetchBtnWrapper').style.display = 'none';
        loadingText.textContent = 'Fetching watchlist from Plex...';
        progressEl.textContent = '';

        try {
            // Use SSE for progress streaming
            const eventSource = new EventSource(`/admin/api/plex/accounts/${accountId}/watchlist?stream=true`);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);

                if (data.type === 'progress') {
                    switch (data.stage) {
                        case 'fetching':
                            loadingText.textContent = 'Fetching watchlist from Plex...';
                            if (data.total > 0) {
                                progressEl.textContent = `${data.current} of ${data.total} items`;
                            }
                            break;
                        case 'details':
                            loadingText.textContent = 'Fetching item details...';
                            progressEl.textContent = `${data.current} of ${data.total} items`;
                            break;
                    }
                } else if (data.type === 'complete') {
                    eventSource.close();
                    plexWatchlistItems = data.items || [];

                    plexSelectedItems.clear();
                    plexWatchlistItems.forEach(item => plexSelectedItems.add(item.ratingKey));

                    renderPlexWatchlistTable();
                    document.getElementById('plexLoadingSection').style.display = 'none';
                    document.getElementById('plexPreviewSection').style.display = 'block';
                    document.getElementById('plexImportBtnWrapper').style.display = 'block';
                    updatePlexSelectedCount();
                    fetchBtn.disabled = false;
                } else if (data.type === 'error') {
                    eventSource.close();
                    throw new Error(data.error || 'Failed to fetch watchlist');
                }
            };

            eventSource.onerror = function(err) {
                eventSource.close();
                showToast('Connection error while fetching watchlist', 'error');
                document.getElementById('plexLoadingSection').style.display = 'none';
                document.getElementById('plexFetchBtnWrapper').style.display = 'block';
                fetchBtn.disabled = false;
            };

        } catch (err) {
            showToast(err.message, 'error');
            document.getElementById('plexLoadingSection').style.display = 'none';
            document.getElementById('plexFetchBtnWrapper').style.display = 'block';
            fetchBtn.disabled = false;
        }
    }

    function renderPlexWatchlistTable() {
        const tbody = document.getElementById('plexWatchlistTableBody');
        const countEl = document.getElementById('plexWatchlistCount');

        countEl.textContent = `${plexWatchlistItems.length} item${plexWatchlistItems.length !== 1 ? 's' : ''}`;

        if (plexWatchlistItems.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-muted); padding: 2rem;">Your Plex watchlist is empty</td></tr>';
            return;
        }

        tbody.innerHTML = plexWatchlistItems.map(item => {
            const isSelected = plexSelectedItems.has(item.ratingKey);
            const ids = item.externalIds || {};
            const idBadges = Object.entries(ids)
                .filter(([k, v]) => v && k !== 'plex')
                .map(([k, v]) => `<span class="id-badge">${k.toUpperCase()}</span>`)
                .join('');

            return `
                <tr class="${isSelected ? '' : 'disabled'}">
                    <td>
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="togglePlexItem('${item.ratingKey}', this.checked)">
                    </td>
                    <td>
                        ${item.posterUrl
                            ? `<img src="${item.posterUrl}" class="poster-thumb" loading="lazy" onerror="this.style.display='none'">`
                            : '<div class="poster-thumb"></div>'}
                    </td>
                    <td style="font-weight: 500;">${escapeHtml(item.title)}</td>
                    <td style="color: var(--text-muted);">${item.year || '-'}</td>
                    <td><span class="type-badge ${item.type}">${item.type}</span></td>
                    <td><div class="id-badges">${idBadges || '<span class="id-badge">PLEX</span>'}</div></td>
                </tr>
            `;
        }).join('');
    }

    function togglePlexItem(ratingKey, checked) {
        if (checked) {
            plexSelectedItems.add(ratingKey);
        } else {
            plexSelectedItems.delete(ratingKey);
        }
        updatePlexSelectedCount();
        updatePlexRowStyles();
    }

    function plexSelectAll(checked) {
        plexSelectedItems.clear();
        if (checked) {
            plexWatchlistItems.forEach(item => plexSelectedItems.add(item.ratingKey));
        }

        document.querySelectorAll('#plexWatchlistTableBody input[type="checkbox"]').forEach(cb => {
            cb.checked = checked;
        });
        document.getElementById('plexSelectAllCheckbox').checked = checked;

        updatePlexSelectedCount();
        updatePlexRowStyles();
    }

    function updatePlexSelectedCount() {
        document.getElementById('plexSelectedCount').textContent = plexSelectedItems.size;
        document.getElementById('plexImportBtn').disabled = plexSelectedItems.size === 0;

        const selectAllCb = document.getElementById('plexSelectAllCheckbox');
        selectAllCb.checked = plexSelectedItems.size === plexWatchlistItems.length;
        selectAllCb.indeterminate = plexSelectedItems.size > 0 && plexSelectedItems.size < plexWatchlistItems.length;
    }

    function updatePlexRowStyles() {
        document.querySelectorAll('#plexWatchlistTableBody tr').forEach((row, index) => {
            if (plexWatchlistItems[index]) {
                const isSelected = plexSelectedItems.has(plexWatchlistItems[index].ratingKey);
                row.classList.toggle('disabled', !isSelected);
            }
        });
    }

    async function importPlexWatchlist() {
        if (plexSelectedItems.size === 0) {
            showToast('Please select at least one item to import', 'error');
            return;
        }

        const profileId = document.getElementById('plexProfileSelect').value;
        if (!profileId) {
            showToast('Please select a profile', 'error');
            return;
        }

        const itemsToImport = plexWatchlistItems.filter(item => plexSelectedItems.has(item.ratingKey));

        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexImportingSection').style.display = 'block';
        document.getElementById('plexImportProgress').textContent = `0 of ${itemsToImport.length}`;

        try {
            const response = await fetch('/admin/api/plex/import', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    profileId: profileId,
                    items: itemsToImport
                })
            });

            const result = await response.json();

            document.getElementById('plexImportingSection').style.display = 'none';
            document.getElementById('plexCompleteSection').style.display = 'block';

            let summary = `Successfully imported ${result.imported} item${result.imported !== 1 ? 's' : ''}.`;
            if (result.failed > 0) {
                summary += ` ${result.failed} item${result.failed !== 1 ? 's' : ''} failed.`;
            }
            document.getElementById('plexImportSummary').textContent = summary;

            if (result.success) {
                showToast(`Imported ${result.imported} items to watchlist`, 'success');
            } else {
                showToast(`Imported ${result.imported} items with ${result.failed} failures`, 'warning');
            }

        } catch (err) {
            document.getElementById('plexImportingSection').style.display = 'none';
            document.getElementById('plexPreviewSection').style.display = 'block';
            showToast('Import failed: ' + err.message, 'error');
        }
    }

    function resetPlexImport() {
        document.getElementById('plexCompleteSection').style.display = 'none';
        document.getElementById('plexImportBtnWrapper').style.display = 'none';
        document.getElementById('plexFetchBtnWrapper').style.display = 'block';
        plexWatchlistItems = [];
        plexSelectedItems.clear();
    }

    function resetPlexWatchlistLoad() {
        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexImportBtnWrapper').style.display = 'none';
        document.getElementById('plexFetchBtnWrapper').style.display = 'block';
        plexWatchlistItems = [];
        plexSelectedItems.clear();
    }

    // ========== Plex Watch History Functions ==========
    async function onPlexHistoryAccountChange() {
        const accountSelect = document.getElementById('plexHistoryAccountSelect');
        const userSelect = document.getElementById('plexHistoryUserSelect');
        const accountId = accountSelect.value;

        // Reset user select
        userSelect.innerHTML = '<option value="0">All Users</option>';

        if (!accountId) return;

        try {
            const response = await fetch(`/admin/api/plex/accounts/${accountId}/users`);
            if (response.ok) {
                const data = await response.json();
                const users = data.users || [];
                users.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.id;
                    option.textContent = user.title + (user.username ? ` (${user.username})` : '');
                    userSelect.appendChild(option);
                });
            }
        } catch (err) {
            console.error('Failed to load Plex users:', err);
        }
    }

    async function fetchPlexHistory() {
        const accountSelect = document.getElementById('plexHistoryAccountSelect');
        const userSelect = document.getElementById('plexHistoryUserSelect');
        const accountId = accountSelect.value;
        const plexUserId = userSelect.value || '0';

        if (!accountId) {
            showToast('Please select a Plex account', 'error');
            return;
        }

        const fetchBtn = document.getElementById('plexHistoryFetchBtn');
        const loadingText = document.getElementById('plexHistoryLoadingText');
        const progressEl = document.getElementById('plexHistoryProgress');

        fetchBtn.disabled = true;
        document.getElementById('plexHistoryFetchBtnWrapper').style.display = 'none';
        document.getElementById('plexHistoryLoading').style.display = 'block';
        loadingText.textContent = 'Connecting to Plex servers...';
        progressEl.textContent = '';

        try {
            // Use SSE for progress streaming
            const eventSource = new EventSource(`/admin/api/plex/accounts/${accountId}/history?limit=1000&plexUserId=${plexUserId}&stream=true`);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);

                if (data.type === 'progress') {
                    switch (data.stage) {
                        case 'servers':
                            loadingText.textContent = 'Finding Plex servers...';
                            progressEl.textContent = '';
                            break;
                        case 'fetching':
                            loadingText.textContent = `Fetching history from server ${data.current} of ${data.total}...`;
                            progressEl.textContent = '';
                            break;
                        case 'details':
                            loadingText.textContent = 'Fetching item details...';
                            progressEl.textContent = `${data.current} of ${data.total} items`;
                            break;
                    }
                } else if (data.type === 'complete') {
                    eventSource.close();
                    plexHistoryItems = data.items || [];

                    // Select all items by default
                    plexHistorySelectedItems.clear();
                    plexHistoryItems.forEach((item, index) => plexHistorySelectedItems.add(index));

                    renderPlexHistoryTable();
                    document.getElementById('plexHistoryLoading').style.display = 'none';
                    document.getElementById('plexHistoryPreview').style.display = 'block';
                    document.getElementById('plexHistoryImportBtnWrapper').style.display = 'block';
                    updatePlexHistorySelectedCount();
                    fetchBtn.disabled = false;
                } else if (data.type === 'error') {
                    eventSource.close();
                    throw new Error(data.error || 'Failed to fetch watch history');
                }
            };

            eventSource.onerror = function(err) {
                eventSource.close();
                showToast('Connection error while fetching history', 'error');
                document.getElementById('plexHistoryLoading').style.display = 'none';
                document.getElementById('plexHistoryFetchBtnWrapper').style.display = 'block';
                fetchBtn.disabled = false;
            };

        } catch (err) {
            showToast(err.message, 'error');
            document.getElementById('plexHistoryLoading').style.display = 'none';
            document.getElementById('plexHistoryFetchBtnWrapper').style.display = 'block';
            fetchBtn.disabled = false;
        }
    }

    function renderPlexHistoryTable() {
        const tbody = document.getElementById('plexHistoryTableBody');
        const countEl = document.getElementById('plexHistoryCount');

        countEl.textContent = `${plexHistoryItems.length} item${plexHistoryItems.length !== 1 ? 's' : ''}`;

        if (plexHistoryItems.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-muted); padding: 2rem;">No watch history found on your Plex servers</td></tr>';
            return;
        }

        tbody.innerHTML = plexHistoryItems.map((item, index) => {
            const isSelected = plexHistorySelectedItems.has(index);
            let displayTitle = item.title;
            if (item.type === 'episode' && item.seriesTitle) {
                displayTitle = `${item.seriesTitle} - S${String(item.season).padStart(2,'0')}E${String(item.episode).padStart(2,'0')} - ${item.title}`;
            }
            const watchedDate = item.viewedAt ? new Date(item.viewedAt * 1000).toLocaleDateString() : '-';

            return `
                <tr class="${isSelected ? '' : 'disabled'}">
                    <td>
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="togglePlexHistoryItem(${index}, this.checked)">
                    </td>
                    <td style="font-weight: 500;">${escapeHtml(displayTitle)}</td>
                    <td style="color: var(--text-muted);">${item.year || '-'}</td>
                    <td><span class="type-badge ${item.type}">${item.type}</span></td>
                    <td style="color: var(--text-muted);">${watchedDate}</td>
                    <td style="color: var(--text-muted); font-size: 0.85rem;">${escapeHtml(item.serverName || '-')}</td>
                </tr>
            `;
        }).join('');
    }

    function togglePlexHistoryItem(index, checked) {
        if (checked) {
            plexHistorySelectedItems.add(index);
        } else {
            plexHistorySelectedItems.delete(index);
        }
        updatePlexHistorySelectedCount();
        updatePlexHistoryRowStyles();
    }

    function plexHistorySelectAll(checked) {
        plexHistorySelectedItems.clear();
        if (checked) {
            plexHistoryItems.forEach((item, index) => plexHistorySelectedItems.add(index));
        }

        document.querySelectorAll('#plexHistoryTableBody input[type="checkbox"]').forEach(cb => {
            cb.checked = checked;
        });
        document.getElementById('plexHistorySelectAllCheckbox').checked = checked;

        updatePlexHistorySelectedCount();
        updatePlexHistoryRowStyles();
    }

    function updatePlexHistorySelectedCount() {
        document.getElementById('plexHistorySelectedCount').textContent = plexHistorySelectedItems.size;
        document.getElementById('plexHistoryImportBtn').disabled = plexHistorySelectedItems.size === 0;

        const selectAllCb = document.getElementById('plexHistorySelectAllCheckbox');
        selectAllCb.checked = plexHistorySelectedItems.size === plexHistoryItems.length;
        selectAllCb.indeterminate = plexHistorySelectedItems.size > 0 && plexHistorySelectedItems.size < plexHistoryItems.length;
    }

    function updatePlexHistoryRowStyles() {
        document.querySelectorAll('#plexHistoryTableBody tr').forEach((row, index) => {
            if (plexHistorySelectedItems.has(index)) {
                row.classList.remove('disabled');
            } else {
                row.classList.add('disabled');
            }
        });
    }

    async function importPlexHistory() {
        const profileId = document.getElementById('plexHistoryProfileSelect').value;

        if (!profileId) {
            showToast('Please select a profile', 'error');
            return;
        }

        if (plexHistorySelectedItems.size === 0) {
            showToast('No items selected', 'error');
            return;
        }

        const selectedItems = plexHistoryItems.filter((item, index) => plexHistorySelectedItems.has(index));

        document.getElementById('plexHistoryPreview').style.display = 'none';
        document.getElementById('plexHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('plexHistoryImporting').style.display = 'block';
        document.getElementById('plexHistoryImportProgress').textContent = `0 of ${selectedItems.length}`;

        try {
            const response = await fetch(`/admin/api/plex/import/history`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    profileId: profileId,
                    items: selectedItems.map(item => ({
                        ratingKey: item.ratingKey,
                        title: item.title,
                        type: item.type,
                        year: item.year || 0,
                        viewedAt: item.viewedAt,
                        externalIds: item.externalIds || {},
                        seriesTitle: item.seriesTitle || '',
                        season: item.season || 0,
                        episode: item.episode || 0
                    }))
                })
            });

            const result = await response.json();

            document.getElementById('plexHistoryImporting').style.display = 'none';
            document.getElementById('plexHistoryComplete').style.display = 'block';

            let summary = `Successfully imported ${result.imported} item${result.imported !== 1 ? 's' : ''}.`;
            if (result.failed > 0) {
                summary += ` ${result.failed} item${result.failed !== 1 ? 's' : ''} failed.`;
            }
            document.getElementById('plexHistoryImportSummary').textContent = summary;

            if (result.success) {
                showToast(`Imported ${result.imported} items to watch history`, 'success');
            } else {
                showToast(`Imported ${result.imported} items with ${result.failed} failures`, 'warning');
            }

        } catch (err) {
            document.getElementById('plexHistoryImporting').style.display = 'none';
            document.getElementById('plexHistoryPreview').style.display = 'block';
            showToast('Import failed: ' + err.message, 'error');
        }
    }

    function resetPlexHistoryImport() {
        document.getElementById('plexHistoryComplete').style.display = 'none';
        document.getElementById('plexHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('plexHistoryFetchBtnWrapper').style.display = 'block';
        plexHistoryItems = [];
        plexHistorySelectedItems.clear();
    }

    function resetPlexHistoryLoad() {
        document.getElementById('plexHistoryPreview').style.display = 'none';
        document.getElementById('plexHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('plexHistoryFetchBtnWrapper').style.display = 'block';
        plexHistoryItems = [];
        plexHistorySelectedItems.clear();
    }

    // Update Plex History UI when accounts change
    function updatePlexHistoryUI() {
        const connectedAccounts = plexAccounts.filter(a => a.connected);
        const accountSelect = document.getElementById('plexHistoryAccountSelect');

        if (connectedAccounts.length === 0) {
            document.getElementById('plexHistoryNotConnected').style.display = 'block';
            document.getElementById('plexHistoryConnected').style.display = 'none';
        } else {
            document.getElementById('plexHistoryNotConnected').style.display = 'none';
            document.getElementById('plexHistoryConnected').style.display = 'block';

            // Populate account select
            accountSelect.innerHTML = connectedAccounts.map(a =>
                `<option value="${a.id}">${escapeHtml(a.name)}${a.username ? ` (${escapeHtml(a.username)})` : ''}</option>`
            ).join('');

            // Load users for the first account
            onPlexHistoryAccountChange();
        }
    }

    // ========== Client Management Functions ==========
    async function loadClients() {
        try {
            const response = await fetch(basePath + '/api/clients', { credentials: 'same-origin' });
            if (!response.ok) throw new Error('Failed to load clients');
            allClients = await response.json();
            filterClientsByProfile();
            updateClientCountBadge();
        } catch (err) {
            console.error('Failed to load clients:', err);
            document.getElementById('clientsList').innerHTML = `
                <div style="color: var(--error); padding: 1rem;">
                    Failed to load clients: ${escapeHtml(err.message)}
                </div>
            `;
        }
    }

    function updateClientCountBadge() {
        const badge = document.getElementById('clientCountBadge');
        if (allClients.length > 0) {
            badge.textContent = `${allClients.length} Device${allClients.length !== 1 ? 's' : ''}`;
            badge.className = 'status-badge connected';
        } else {
            badge.textContent = '';
            badge.className = 'status-badge';
        }
    }

    function filterClientsByProfile() {
        const filterValue = document.getElementById('clientProfileFilter').value;
        if (filterValue) {
            filteredClients = allClients.filter(c => c.userId === filterValue);
        } else {
            filteredClients = [...allClients];
        }
        renderClientsList();
    }

    function getProfileName(userId) {
        const profile = userProfiles.find(p => p.id === userId);
        return profile ? profile.name : 'Unknown Profile';
    }

    function formatRelativeTime(dateStr) {
        if (!dateStr) return 'Never';
        const date = new Date(dateStr);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    }

    function renderClientsList() {
        const container = document.getElementById('clientsList');
        const emptyState = document.getElementById('clientsEmptyState');

        if (filteredClients.length === 0) {
            container.innerHTML = '';
            emptyState.style.display = 'block';
            return;
        }

        emptyState.style.display = 'none';

        // Use card layout for better mobile experience
        container.innerHTML = `
            <div class="client-cards">
                ${filteredClients.map(client => `
                    <div class="client-card" data-client-id="${client.id}">
                        <div class="client-card-header">
                            <div class="client-info">
                                <div class="client-name">${escapeHtml(client.name || 'Unknown Device')}</div>
                                <div class="client-meta">
                                    ${escapeHtml(client.deviceType || '')}${client.os ? ' • ' + escapeHtml(client.os) : ''}${client.appVersion ? ' • v' + escapeHtml(client.appVersion) : ''}
                                </div>
                                <div class="client-id">ID: ${escapeHtml(client.id.substring(0, 8))}...</div>
                            </div>
                            <div class="client-last-seen">${formatRelativeTime(client.lastSeenAt)}</div>
                        </div>
                        <div class="client-card-body">
                            <div class="client-profile-row">
                                <label class="client-label">Profile:</label>
                                <select class="form-select client-profile-select"
                                        onchange="reassignClient('${client.id}', this.value)"
                                        data-original="${client.userId}">
                                    ${userProfiles.map(p => `
                                        <option value="${p.id}" ${p.id === client.userId ? 'selected' : ''}>
                                            ${escapeHtml(p.name)}
                                        </option>
                                    `).join('')}
                                </select>
                            </div>
                            <div class="client-actions">
                                <button class="btn btn-secondary btn-sm" onclick="pingClient('${client.id}')" title="Send ping to identify device">
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <polyline points="12 6 12 12 16 14"/>
                                    </svg>
                                    Ping
                                </button>
                                <button class="btn btn-danger btn-sm" onclick="deleteClient('${client.id}', '${escapeHtml(client.name || 'this device')}')" title="Remove device">
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="3 6 5 6 21 6"/>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                    </svg>
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    async function pingClient(clientId) {
        try {
            const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(clientId) + '/ping', {
                method: 'POST',
                credentials: 'same-origin'
            });
            if (response.ok) {
                showToast('Ping sent! If the device is active, it will flash.');
            } else {
                const data = await response.json();
                showToast(data.error || 'Failed to send ping', 'error');
            }
        } catch (err) {
            showToast('Failed to send ping: ' + err.message, 'error');
        }
    }

    async function reassignClient(clientId, newUserId) {
        const select = document.querySelector(`.client-card[data-client-id="${clientId}"] select`);
        const originalValue = select.dataset.original;

        try {
            const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(clientId) + '/reassign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ userId: newUserId })
            });

            if (response.ok) {
                const updatedClient = await response.json();
                // Update local state
                const idx = allClients.findIndex(c => c.id === clientId);
                if (idx !== -1) {
                    allClients[idx] = updatedClient;
                }
                select.dataset.original = newUserId;
                showToast('Client reassigned to ' + getProfileName(newUserId));
                // Re-filter in case the filter is active
                filterClientsByProfile();
            } else {
                const data = await response.json();
                showToast(data.error || 'Failed to reassign client', 'error');
                // Revert select
                select.value = originalValue;
            }
        } catch (err) {
            showToast('Failed to reassign client: ' + err.message, 'error');
            select.value = originalValue;
        }
    }

    async function deleteClient(clientId, clientName) {
        if (!confirm(`Are you sure you want to remove "${clientName}"?\n\nThis will delete the device registration. The device can re-register when it next connects.`)) {
            return;
        }

        try {
            const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(clientId), {
                method: 'DELETE',
                credentials: 'same-origin'
            });

            if (response.ok || response.status === 204) {
                // Remove from local state
                allClients = allClients.filter(c => c.id !== clientId);
                filterClientsByProfile();
                updateClientCountBadge();
                showToast('Device removed successfully');
            } else {
                const data = await response.json();
                showToast(data.error || 'Failed to remove device', 'error');
            }
        } catch (err) {
            showToast('Failed to remove device: ' + err.message, 'error');
        }
    }

    // ========== Scheduled Tasks Functions ==========
    async function loadScheduledTasks() {
        const listContainer = document.getElementById('scheduledTasksList');
        const emptyState = document.getElementById('scheduledTasksEmptyState');

        // Only load if admin (the section won't exist for non-admins)
        if (!listContainer) return;

        try {
            const response = await fetch('/admin/api/scheduled-tasks');
            if (!response.ok) {
                throw new Error('Failed to load scheduled tasks');
            }
            const data = await response.json();
            scheduledTasks = data.tasks || [];
            renderScheduledTasksList();
            updateScheduledTasksCountBadge();
        } catch (err) {
            console.error('Failed to load scheduled tasks:', err);
            listContainer.innerHTML = '<p class="text-muted">Failed to load scheduled tasks.</p>';
        }
    }

    function updateScheduledTasksCountBadge() {
        const badge = document.getElementById('scheduledTasksCountBadge');
        if (!badge) return;

        const enabledCount = scheduledTasks.filter(t => t.enabled).length;
        if (enabledCount > 0) {
            badge.textContent = `${enabledCount} Active`;
            badge.className = 'status-badge connected';
        } else if (scheduledTasks.length > 0) {
            badge.textContent = `${scheduledTasks.length} Configured`;
            badge.className = 'status-badge';
        } else {
            badge.textContent = '';
            badge.className = 'status-badge';
        }
    }

    function renderScheduledTasksList() {
        const listContainer = document.getElementById('scheduledTasksList');
        const emptyState = document.getElementById('scheduledTasksEmptyState');

        if (!listContainer) return;

        if (scheduledTasks.length === 0) {
            listContainer.innerHTML = '';
            if (emptyState) emptyState.style.display = 'block';
            return;
        }

        if (emptyState) emptyState.style.display = 'none';

        listContainer.innerHTML = scheduledTasks.map(task => {
            const statusClass = getStatusClass(task.lastStatus);
            const statusLabel = getStatusLabel(task.lastStatus);
            const frequencyLabel = getFrequencyLabel(task.frequency);
            const lastRunLabel = task.lastRunAt ? formatRelativeTime(task.lastRunAt) : 'Never';
            const taskTypeLabel = getTaskTypeLabel(task.type);

            // Get account and profile names based on task type
            let accountName = 'Unknown';
            let accountSource = '';
            let profileName = 'Unknown';
            let listTypeLabel = '';
            if (task.config) {
                if (task.type === 'plex_watchlist_sync') {
                    const plexAccount = plexAccounts.find(a => a.id === task.config.plexAccountId);
                    if (plexAccount) accountName = plexAccount.name || plexAccount.username || 'Plex Account';
                    accountSource = 'Plex';
                } else if (task.type === 'trakt_list_sync') {
                    const traktAccount = traktAccounts.find(a => a.id === task.config.traktAccountId);
                    if (traktAccount) accountName = traktAccount.name || traktAccount.username || 'Trakt Account';
                    accountSource = 'Trakt';
                    // Get list type label
                    const listType = task.config.listType || 'watchlist';
                    const listTypeLabels = { watchlist: 'Watchlist', collection: 'Collection', favorites: 'Favorites', custom: 'Custom' };
                    listTypeLabel = listTypeLabels[listType] || listType;
                }
                const profile = userProfiles.find(p => p.id === task.config.profileId);
                if (profile) profileName = profile.name || 'Profile';
            }

            return `
                <div class="import-card" data-task-id="${task.id}" style="margin-bottom: 0.75rem;">
                    <div class="import-card-header">
                        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem 0.75rem; flex: 1;">
                            <h3 style="margin: 0;">${escapeHtml(task.name || taskTypeLabel)}</h3>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">
                                <span class="type-badge" style="background: rgba(99, 102, 241, 0.2); color: var(--accent); font-size: 0.7rem;">${taskTypeLabel}</span>
                                ${listTypeLabel ? `<span class="type-badge" style="background: rgba(99, 102, 241, 0.1); color: var(--accent); font-size: 0.65rem;">${listTypeLabel}</span>` : ''}
                                ${task.config && task.config.dryRun === 'true' ? `<span class="type-badge" style="background: rgba(251, 191, 36, 0.2); color: #fbbf24; font-size: 0.65rem;">DRY RUN</span>` : ''}
                            </div>
                        </div>
                        <label class="toggle-switch" style="margin-left: auto;">
                            <input type="checkbox" ${task.enabled ? 'checked' : ''} onchange="toggleScheduledTask('${task.id}', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="import-card-body" style="padding: 0.75rem 1rem;">
                        <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem;">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="opacity: 0.6;">
                                    <circle cx="12" cy="12" r="10"/>
                                    <polyline points="12 6 12 12 16 14"/>
                                </svg>
                                <span>${frequencyLabel}</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">
                                <span>${accountSource}:</span>
                                <strong>${escapeHtml(accountName)}</strong>
                                <span>→</span>
                                <strong>${escapeHtml(profileName)}</strong>
                            </div>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;">
                            <span class="status-badge ${statusClass}" style="font-size: 0.75rem;">${statusLabel}</span>
                            <span class="text-muted" style="font-size: 0.8125rem;">Last: ${lastRunLabel}</span>
                            ${task.enabled ? `<span class="text-muted" style="font-size: 0.8125rem;">Next: ${getNextRunLabel(task)}</span>` : ''}
                            ${task.itemsImported > 0 ? `<span class="text-muted" style="font-size: 0.8125rem;">${task.itemsImported} items synced</span>` : ''}
                            ${task.dryRunDetails ? `<button class="btn btn-sm" onclick="showDryRunResults('${task.id}')" style="padding: 0.15rem 0.5rem; font-size: 0.75rem; background: rgba(99, 102, 241, 0.2); color: var(--accent);">View Dry Run Results</button>` : ''}
                            ${task.lastError ? `<span style="color: var(--danger); font-size: 0.8125rem;">${escapeHtml(task.lastError)}</span>` : ''}
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                            <button class="btn btn-sm btn-secondary" onclick="runScheduledTaskNow('${task.id}')" ${task.lastStatus === 'running' ? 'disabled' : ''}>
                                <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.25rem;">
                                    <polygon points="5 3 19 12 5 21 5 3"/>
                                </svg>
                                ${task.lastStatus === 'running' ? 'Running...' : 'Run Now'}
                            </button>
                            <button class="btn btn-sm btn-secondary" onclick="showEditScheduledTaskModal('${task.id}')">
                                <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.25rem;">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                </svg>
                                Edit
                            </button>
                            <button class="btn btn-sm btn-secondary" onclick="deleteScheduledTask('${task.id}')" ${task.lastStatus === 'running' ? 'disabled' : ''} style="color: var(--danger);">
                                <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.25rem;">
                                    <polyline points="3 6 5 6 21 6"/><path d="m19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                </svg>
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }

    function getStatusClass(status) {
        switch (status) {
            case 'success': return 'connected';
            case 'error': return 'disconnected';
            case 'running': return 'connected';
            default: return '';
        }
    }

    function getStatusLabel(status) {
        switch (status) {
            case 'success': return 'Success';
            case 'error': return 'Error';
            case 'running': return 'Running';
            case 'pending': return 'Pending';
            default: return 'Unknown';
        }
    }

    function getFrequencyLabel(frequency) {
        switch (frequency) {
            case '1min': return 'Every minute';
            case '5min': return 'Every 5 minutes';
            case '15min': return 'Every 15 minutes';
            case '30min': return 'Every 30 minutes';
            case 'hourly': return 'Every hour';
            case '6hours': return 'Every 6 hours';
            case '12hours': return 'Every 12 hours';
            case 'daily': return 'Daily';
            default: return frequency;
        }
    }

    function getTaskTypeLabel(type) {
        switch (type) {
            case 'plex_watchlist_sync': return 'Plex Watchlist';
            case 'trakt_list_sync': return 'Trakt List';
            default: return type;
        }
    }

    function formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    }

    function getFrequencyMs(frequency) {
        switch (frequency) {
            case '1min': return 60 * 1000;
            case '5min': return 5 * 60 * 1000;
            case '15min': return 15 * 60 * 1000;
            case '30min': return 30 * 60 * 1000;
            case 'hourly': return 60 * 60 * 1000;
            case '6hours': return 6 * 60 * 60 * 1000;
            case '12hours': return 12 * 60 * 60 * 1000;
            case 'daily': return 24 * 60 * 60 * 1000;
            default: return 24 * 60 * 60 * 1000;
        }
    }

    function getNextRunLabel(task) {
        if (task.lastStatus === 'running') return 'Running now';
        if (!task.enabled) return 'Disabled';

        const intervalMs = getFrequencyMs(task.frequency);

        // If never run, will run on next scheduler check
        if (!task.lastRunAt) return 'Soon';

        const lastRun = new Date(task.lastRunAt);
        const nextRun = new Date(lastRun.getTime() + intervalMs);
        const now = new Date();

        // If next run is in the past, it will run soon
        if (nextRun <= now) return 'Soon';

        const diffMs = nextRun - now;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);

        if (diffMins < 1) return 'Soon';
        if (diffMins < 60) return `in ${diffMins}m`;
        if (diffHours < 24) {
            const remainingMins = Math.floor((diffMs % 3600000) / 60000);
            if (remainingMins > 0) return `in ${diffHours}h ${remainingMins}m`;
            return `in ${diffHours}h`;
        }
        return nextRun.toLocaleString();
    }

    function showAddScheduledTaskModal() {
        // Populate Plex accounts dropdown
        const plexSelect = document.getElementById('newTaskPlexAccount');
        const connectedPlexAccounts = plexAccounts.filter(a => a.connected);

        // Populate Trakt accounts dropdown
        const traktSelect = document.getElementById('newTaskTraktAccount');
        const connectedTraktAccounts = traktAccounts.filter(a => a.connected);

        // Check if at least one service has connected accounts
        if (connectedPlexAccounts.length === 0 && connectedTraktAccounts.length === 0) {
            showToast('Please connect a Plex or Trakt account first', 'error');
            return;
        }

        // Populate Plex dropdown
        if (connectedPlexAccounts.length > 0) {
            plexSelect.innerHTML = connectedPlexAccounts.map(account =>
                `<option value="${account.id}">${escapeHtml(account.name || account.username || 'Plex Account')}</option>`
            ).join('');
        } else {
            plexSelect.innerHTML = '<option value="">No Plex accounts connected</option>';
        }

        // Populate Trakt dropdown
        if (connectedTraktAccounts.length > 0) {
            traktSelect.innerHTML = connectedTraktAccounts.map(account =>
                `<option value="${account.id}">${escapeHtml(account.name || account.username || 'Trakt Account')}</option>`
            ).join('');
        } else {
            traktSelect.innerHTML = '<option value="">No Trakt accounts connected</option>';
        }

        // Reset form
        document.getElementById('newTaskType').value = 'plex_watchlist_sync';
        document.getElementById('newTaskName').value = '';
        document.getElementById('newTaskFrequency').value = '12hours';
        document.getElementById('newTaskEnabled').checked = true;
        document.getElementById('newTaskDryRun').checked = false;
        document.getElementById('newTaskListType').value = 'watchlist';
        document.getElementById('customListGroup').style.display = 'none';

        // Reset visibility
        onTaskTypeChange();

        document.getElementById('addScheduledTaskModal').style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }

    function hideAddScheduledTaskModal() {
        document.getElementById('addScheduledTaskModal').style.display = 'none';
        document.body.style.overflow = '';
    }

    function onTaskTypeChange() {
        const taskType = document.getElementById('newTaskType').value;
        const plexConfig = document.getElementById('plexWatchlistSyncConfig');
        const traktConfig = document.getElementById('traktListSyncConfig');
        const syncOptions = document.getElementById('syncOptionsConfig');
        const syncDirection = document.getElementById('newTaskSyncDirection');

        // Show/hide config sections based on task type
        plexConfig.style.display = taskType === 'plex_watchlist_sync' ? 'block' : 'none';
        traktConfig.style.display = taskType === 'trakt_list_sync' ? 'block' : 'none';

        // Update sync direction labels based on task type
        if (taskType === 'plex_watchlist_sync') {
            syncDirection.innerHTML = `
                <option value="source_to_target" selected>Plex → strmr (Import from Plex)</option>
                <option value="target_to_source">strmr → Plex (Export to Plex)</option>
                <option value="bidirectional">Bidirectional (Sync both ways)</option>
            `;
        } else if (taskType === 'trakt_list_sync') {
            syncDirection.innerHTML = `
                <option value="source_to_target" selected>Trakt → strmr (Import from Trakt)</option>
                <option value="target_to_source">strmr → Trakt (Export to Trakt)</option>
                <option value="bidirectional">Bidirectional (Sync both ways)</option>
            `;
        }

        // Show sync options and dry run for any sync-type task
        const isSyncTask = taskType.includes('sync');
        syncOptions.style.display = isSyncTask ? 'block' : 'none';
        document.getElementById('dryRunGroup').style.display = isSyncTask ? 'block' : 'none';
    }

    async function onListTypeChange() {
        const listType = document.getElementById('newTaskListType').value;
        const customListGroup = document.getElementById('customListGroup');
        customListGroup.style.display = listType === 'custom' ? 'block' : 'none';

        // Load custom lists if custom is selected and account is chosen
        if (listType === 'custom') {
            const accountId = document.getElementById('newTaskTraktAccount').value;
            if (accountId) {
                await loadTraktLists(accountId, 'newTaskCustomList');
            }
        }
    }

    async function onEditListTypeChange() {
        const listType = document.getElementById('editTaskListType').value;
        const customListGroup = document.getElementById('editCustomListGroup');
        customListGroup.style.display = listType === 'custom' ? 'block' : 'none';

        // Load custom lists if custom is selected and account is chosen
        if (listType === 'custom') {
            const accountId = document.getElementById('editTaskTraktAccount').value;
            if (accountId) {
                await loadTraktLists(accountId, 'editTaskCustomList');
            }
        }
    }

    async function onTraktAccountChange() {
        const accountId = document.getElementById('newTaskTraktAccount').value;
        if (!accountId) return;
        await loadTraktLists(accountId, 'newTaskCustomList');
    }

    async function onEditTraktAccountChange() {
        const accountId = document.getElementById('editTaskTraktAccount').value;
        if (!accountId) return;
        await loadTraktLists(accountId, 'editTaskCustomList');
    }

    async function loadTraktLists(accountId, selectId) {
        const select = document.getElementById(selectId);
        select.innerHTML = '<option value="">Loading lists...</option>';
        select.disabled = true;

        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/lists`);
            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Failed to load lists');
            }

            const lists = data.lists || [];
            if (lists.length === 0) {
                select.innerHTML = '<option value="">No custom lists found</option>';
            } else {
                select.innerHTML = lists.map(list =>
                    `<option value="${list.id}">${escapeHtml(list.name)} (${list.itemCount} items)</option>`
                ).join('');
            }
        } catch (err) {
            console.error('Failed to load Trakt lists:', err);
            select.innerHTML = '<option value="">Failed to load lists</option>';
        } finally {
            select.disabled = false;
        }
    }

    function onSyncDirectionChange() {
        const direction = document.getElementById('newTaskSyncDirection').value;
        const conflictGroup = document.getElementById('conflictResolutionGroup');
        conflictGroup.style.display = direction === 'bidirectional' ? 'block' : 'none';
    }

    function onEditSyncDirectionChange() {
        const direction = document.getElementById('editTaskSyncDirection').value;
        const conflictGroup = document.getElementById('editConflictResolutionGroup');
        conflictGroup.style.display = direction === 'bidirectional' ? 'block' : 'none';
    }

    async function createScheduledTask() {
        const taskType = document.getElementById('newTaskType').value;
        const taskName = document.getElementById('newTaskName').value.trim();
        const frequency = document.getElementById('newTaskFrequency').value;
        const enabled = document.getElementById('newTaskEnabled').checked;

        let config = {};

        if (taskType === 'plex_watchlist_sync') {
            config.plexAccountId = document.getElementById('newTaskPlexAccount').value;
            config.profileId = document.getElementById('newTaskProfile').value;

            if (!config.plexAccountId || !config.profileId) {
                showToast('Please select a Plex account and profile', 'error');
                return;
            }
        } else if (taskType === 'trakt_list_sync') {
            config.traktAccountId = document.getElementById('newTaskTraktAccount').value;
            config.profileId = document.getElementById('newTaskTraktProfile').value;
            config.listType = document.getElementById('newTaskListType').value;

            if (!config.traktAccountId || !config.profileId) {
                showToast('Please select a Trakt account and profile', 'error');
                return;
            }

            if (config.listType === 'custom') {
                config.customListId = document.getElementById('newTaskCustomList').value;
                if (!config.customListId) {
                    showToast('Please select a custom list', 'error');
                    return;
                }
            }
        }

        // Add sync options for sync-type tasks
        if (taskType.includes('sync')) {
            config.syncDirection = document.getElementById('newTaskSyncDirection').value;
            config.deleteBehavior = document.getElementById('newTaskDeleteBehavior').value;
            if (config.syncDirection === 'bidirectional') {
                config.conflictResolution = document.getElementById('newTaskConflictResolution').value;
            }
            // Add dry run option
            if (document.getElementById('newTaskDryRun').checked) {
                config.dryRun = 'true';
            }
        }

        try {
            const response = await fetch('/admin/api/scheduled-tasks', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: taskType,
                    name: taskName || undefined,
                    frequency: frequency,
                    config: config,
                    enabled: enabled
                })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Failed to create task');
            }

            showToast('Scheduled task created', 'success');
            hideAddScheduledTaskModal();
            await loadScheduledTasks();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function toggleScheduledTask(taskId, enabled) {
        try {
            const response = await fetch(`/admin/api/scheduled-tasks/${taskId}/toggle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            });

            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.error || 'Failed to toggle task');
            }

            // Update local state
            const task = scheduledTasks.find(t => t.id === taskId);
            if (task) task.enabled = enabled;

            updateScheduledTasksCountBadge();
            showToast(enabled ? 'Task enabled' : 'Task disabled', 'success');
        } catch (err) {
            showToast(err.message, 'error');
            // Reload to reset checkbox state
            await loadScheduledTasks();
        }
    }

    async function runScheduledTaskNow(taskId) {
        try {
            const response = await fetch(`/admin/api/scheduled-tasks/${taskId}/run`, {
                method: 'POST'
            });

            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.error || 'Failed to start task');
            }

            showToast('Task started', 'success');

            // Poll for status updates
            setTimeout(async () => {
                await loadScheduledTasks();
            }, 1000);

            // Poll again after a few seconds
            setTimeout(async () => {
                await loadScheduledTasks();
            }, 5000);
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function deleteScheduledTask(taskId) {
        if (!confirm('Delete this scheduled task?')) return;

        try {
            const response = await fetch(`/admin/api/scheduled-tasks/${taskId}`, {
                method: 'DELETE'
            });

            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.error || 'Failed to delete task');
            }

            showToast('Task deleted', 'success');
            await loadScheduledTasks();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function showEditScheduledTaskModal(taskId) {
        const task = scheduledTasks.find(t => t.id === taskId);
        if (!task) {
            showToast('Task not found', 'error');
            return;
        }

        // Populate Plex accounts dropdown
        const plexSelect = document.getElementById('editTaskPlexAccount');
        const connectedPlexAccounts = plexAccounts.filter(a => a.connected);

        plexSelect.innerHTML = connectedPlexAccounts.map(account =>
            `<option value="${account.id}">${escapeHtml(account.name || account.username || 'Plex Account')}</option>`
        ).join('');

        // Populate Trakt accounts dropdown
        const traktSelect = document.getElementById('editTaskTraktAccount');
        const connectedTraktAccounts = traktAccounts.filter(a => a.connected);

        traktSelect.innerHTML = connectedTraktAccounts.map(account =>
            `<option value="${account.id}">${escapeHtml(account.name || account.username || 'Trakt Account')}</option>`
        ).join('');

        // Set form values
        document.getElementById('editTaskId').value = task.id;
        document.getElementById('editTaskType').value = task.type;
        document.getElementById('editTaskName').value = task.name || '';
        document.getElementById('editTaskFrequency').value = task.frequency;

        // Hide all config sections first
        document.getElementById('editPlexWatchlistSyncConfig').style.display = 'none';
        document.getElementById('editTraktListSyncConfig').style.display = 'none';

        // Set config values for Plex watchlist sync
        if (task.type === 'plex_watchlist_sync' && task.config) {
            document.getElementById('editTaskPlexAccount').value = task.config.plexAccountId || '';
            document.getElementById('editTaskProfile').value = task.config.profileId || '';
            document.getElementById('editPlexWatchlistSyncConfig').style.display = 'block';
        }

        // Set config values for Trakt list sync
        if (task.type === 'trakt_list_sync' && task.config) {
            document.getElementById('editTaskTraktAccount').value = task.config.traktAccountId || '';
            document.getElementById('editTaskTraktProfile').value = task.config.profileId || '';
            document.getElementById('editTaskListType').value = task.config.listType || 'watchlist';
            document.getElementById('editTraktListSyncConfig').style.display = 'block';

            // Handle custom list
            if (task.config.listType === 'custom') {
                document.getElementById('editCustomListGroup').style.display = 'block';
                if (task.config.traktAccountId) {
                    await loadTraktLists(task.config.traktAccountId, 'editTaskCustomList');
                    document.getElementById('editTaskCustomList').value = task.config.customListId || '';
                }
            } else {
                document.getElementById('editCustomListGroup').style.display = 'none';
            }
        }

        // Update sync direction labels based on task type
        const syncDirection = document.getElementById('editTaskSyncDirection');
        if (task.type === 'plex_watchlist_sync') {
            syncDirection.innerHTML = `
                <option value="source_to_target">Plex → strmr (Import from Plex)</option>
                <option value="target_to_source">strmr → Plex (Export to Plex)</option>
                <option value="bidirectional">Bidirectional (Sync both ways)</option>
            `;
        } else if (task.type === 'trakt_list_sync') {
            syncDirection.innerHTML = `
                <option value="source_to_target">Trakt → strmr (Import from Trakt)</option>
                <option value="target_to_source">strmr → Trakt (Export to Trakt)</option>
                <option value="bidirectional">Bidirectional (Sync both ways)</option>
            `;
        }

        // Set sync options for sync-type tasks
        const isSyncTask = task.type.includes('sync');
        document.getElementById('editSyncOptionsConfig').style.display = isSyncTask ? 'block' : 'none';

        if (isSyncTask && task.config) {
            document.getElementById('editTaskSyncDirection').value = task.config.syncDirection || 'source_to_target';
            document.getElementById('editTaskDeleteBehavior').value = task.config.deleteBehavior || 'additive';
            document.getElementById('editTaskConflictResolution').value = task.config.conflictResolution || 'source_wins';
            document.getElementById('editTaskDryRun').checked = task.config.dryRun === 'true';

            // Show/hide conflict resolution based on sync direction
            const conflictGroup = document.getElementById('editConflictResolutionGroup');
            conflictGroup.style.display = (task.config.syncDirection === 'bidirectional') ? 'block' : 'none';
        }

        // Show dry run option for sync tasks
        document.getElementById('editDryRunGroup').style.display = isSyncTask ? 'block' : 'none';

        document.getElementById('editScheduledTaskModal').style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }

    function hideEditScheduledTaskModal() {
        document.getElementById('editScheduledTaskModal').style.display = 'none';
        document.body.style.overflow = '';
    }

    function showDryRunResults(taskId) {
        const task = scheduledTasks.find(t => t.id === taskId);
        if (!task || !task.dryRunDetails) {
            showToast('No dry run results available', 'error');
            return;
        }

        const details = task.dryRunDetails;
        const toAdd = details.toAdd || [];
        const toRemove = details.toRemove || [];

        // Update counts
        document.getElementById('dryRunToAddCount').textContent = toAdd.length;
        document.getElementById('dryRunToRemoveCount').textContent = toRemove.length;

        // Render add list
        const addList = document.getElementById('dryRunToAddList');
        if (toAdd.length === 0) {
            addList.innerHTML = '<p class="text-muted" style="margin: 0.5rem;">No items to add</p>';
        } else {
            addList.innerHTML = toAdd.map(item => `
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-bottom: 1px solid var(--border);">
                    <span class="type-badge" style="background: rgba(99, 102, 241, 0.2); color: var(--accent); font-size: 0.7rem; text-transform: uppercase;">${escapeHtml(item.mediaType)}</span>
                    <span>${escapeHtml(item.name)}</span>
                </div>
            `).join('');
        }

        // Render remove list
        const removeList = document.getElementById('dryRunToRemoveList');
        if (toRemove.length === 0) {
            removeList.innerHTML = '<p class="text-muted" style="margin: 0.5rem;">No items to remove</p>';
        } else {
            removeList.innerHTML = toRemove.map(item => `
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-bottom: 1px solid var(--border);">
                    <span class="type-badge" style="background: rgba(239, 68, 68, 0.2); color: var(--danger); font-size: 0.7rem; text-transform: uppercase;">${escapeHtml(item.mediaType)}</span>
                    <span>${escapeHtml(item.name)}</span>
                </div>
            `).join('');
        }

        // Always show both sections (with appropriate content)
        document.getElementById('dryRunToAddSection').style.display = 'block';
        document.getElementById('dryRunToRemoveSection').style.display = 'block';

        // Show modal
        document.getElementById('dryRunResultsModal').style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }

    function hideDryRunResultsModal() {
        document.getElementById('dryRunResultsModal').style.display = 'none';
        document.body.style.overflow = '';
    }

    async function updateScheduledTask() {
        const taskId = document.getElementById('editTaskId').value;
        const taskType = document.getElementById('editTaskType').value;
        const taskName = document.getElementById('editTaskName').value.trim();
        const frequency = document.getElementById('editTaskFrequency').value;

        let config = {};

        if (taskType === 'plex_watchlist_sync') {
            config.plexAccountId = document.getElementById('editTaskPlexAccount').value;
            config.profileId = document.getElementById('editTaskProfile').value;

            if (!config.plexAccountId || !config.profileId) {
                showToast('Please select a Plex account and profile', 'error');
                return;
            }
        } else if (taskType === 'trakt_list_sync') {
            config.traktAccountId = document.getElementById('editTaskTraktAccount').value;
            config.profileId = document.getElementById('editTaskTraktProfile').value;
            config.listType = document.getElementById('editTaskListType').value;

            if (!config.traktAccountId || !config.profileId) {
                showToast('Please select a Trakt account and profile', 'error');
                return;
            }

            if (config.listType === 'custom') {
                config.customListId = document.getElementById('editTaskCustomList').value;
                if (!config.customListId) {
                    showToast('Please select a custom list', 'error');
                    return;
                }
            }
        }

        // Add sync options for sync-type tasks
        if (taskType.includes('sync')) {
            config.syncDirection = document.getElementById('editTaskSyncDirection').value;
            config.deleteBehavior = document.getElementById('editTaskDeleteBehavior').value;
            if (config.syncDirection === 'bidirectional') {
                config.conflictResolution = document.getElementById('editTaskConflictResolution').value;
            }
            // Add dry run option
            if (document.getElementById('editTaskDryRun').checked) {
                config.dryRun = 'true';
            }
        }

        try {
            const response = await fetch(`/admin/api/scheduled-tasks/${taskId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: taskName || undefined,
                    frequency: frequency,
                    config: config
                })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Failed to update task');
            }

            showToast('Task updated', 'success');
            hideEditScheduledTaskModal();
            await loadScheduledTasks();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }
</script>
{{end}}
