{{template "base" .}}

{{define "title"}}Settings - {{if .IsAdmin}}strmr Admin{{else}}strmr account{{end}}{{end}}

{{define "content"}}
{{if .NoProfiles}}
<div class="page-header">
    <h1>Settings</h1>
    <p>Configure profile settings</p>
</div>
<div class="card" style="margin-top: 2rem;">
    <div class="card-body" style="text-align: center; padding: 3rem;">
        <svg viewBox="0 0 24 24" width="64" height="64" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 1rem; opacity: 0.5;">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
            <circle cx="12" cy="7" r="4"/>
        </svg>
        <h2 style="margin-bottom: 0.5rem;">No Profiles</h2>
        <p style="color: var(--text-muted); margin-bottom: 1.5rem;">You don't have any profiles associated with your account yet. Create a profile to view this page.</p>
    </div>
</div>
{{else}}
<div class="page-header page-header-flex" style="display: flex; align-items: center; justify-content: space-between;">
    <div>
        <h1>Settings</h1>
        <p>{{if .IsAdmin}}Configure your strmr server{{else}}Configure profile settings{{end}}</p>
    </div>
    <div class="page-header-controls" style="display: flex; gap: 0.5rem; align-items: center;">
        <select id="userSelector" class="form-select" style="min-width: 180px;" onchange="handleUserChange(this.value)">
            {{if .IsAdmin}}<option value="">Global Defaults</option>{{end}}
            {{range .Users}}
            <option value="{{.ID}}" data-has-overrides="{{if index $.UserOverrides .ID}}true{{else}}false{{end}}">{{.Name}}{{if index $.UserOverrides .ID}} ●{{end}}</option>
            {{end}}
        </select>
        <select id="clientSelector" class="form-select" style="min-width: 180px; display: none;" onchange="handleClientChange(this.value)">
            <option value="">Profile Defaults</option>
        </select>
        <button id="identifyClientBtn" class="btn btn-secondary" style="display: none;" onclick="identifyClient()" title="Send ping to identify this device">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            Identify
        </button>
        <button id="revertBtn" class="btn btn-secondary" style="display: none;" onclick="revertToGlobal()" title="Reset all settings to inherit from parent defaults">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
            </svg>
            Revert
        </button>
        <button class="btn btn-primary" onclick="saveAllSettings()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save
        </button>
    </div>
</div>

<div id="settingsContainer">
    <div style="display: flex; align-items: center; justify-content: center; padding: 2rem;">
        <div class="spinner"></div>
    </div>
</div>
{{end}}
{{end}}

{{define "scripts"}}
{{if not .NoProfiles}}
<script>
    let currentSettings = {{json .Settings}};
    let schema = {{json .Schema}};
    let groups = {{json .Groups}};
    let originalSettings = JSON.parse(JSON.stringify(currentSettings));
    let selectedUserId = '';
    let userSettings = null;
    let originalUserSettings = null;
    let selectedClientId = '';
    let clientSettings = null;
    let originalClientSettings = null;
    let clientsForUser = []; // Clients for the selected user
    let profilesData = []; // Profiles with PIN status
    let accountsData = []; // User accounts with profiles
    let hasDefaultPassword = false; // Whether admin has default password
    let userOverrides = {{json .UserOverrides}}; // Map of userId -> hasOverrides
    const isAdmin = {{json .IsAdmin}};
    const basePath = {{json .BasePath}};

    // Sections that are per-user (when a user is selected, only show these)
    // Note: liveTV settings (favorites, hidden channels) are managed in-app, not via this UI
    const perUserSections = ['playback', 'homeShelves', 'homeShelves.shelves', 'filtering', 'liveTV'];

    // Validation state - stores errors by section and field
    let validationErrors = {};

    // Check if a value is empty/missing
    function isEmpty(val) {
        if (val === undefined || val === null) return true;
        if (typeof val === 'string') return val.trim() === '';
        if (typeof val === 'number') return false; // 0 is valid for numbers
        if (Array.isArray(val)) return val.length === 0;
        return false;
    }

    // Check if an array has at least one enabled item
    function hasEnabledItem(arr) {
        if (!Array.isArray(arr)) return false;
        return arr.some(item => item.enabled === true);
    }

    // Validate all settings and return errors object
    function validateSettings() {
        const errors = {};

        // Skip validation for user-specific settings or non-admin users
        if (selectedUserId || !isAdmin) return errors;

        const serviceMode = currentSettings.streaming?.serviceMode || 'debrid';
        const needsDebrid = serviceMode === 'debrid' || serviceMode === 'hybrid';
        const needsUsenet = serviceMode === 'usenet' || serviceMode === 'hybrid';

        // Server Settings - all required
        const serverErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.server?.host)) serverErrors.fields.host = 'Host is required';
        if (isEmpty(currentSettings.server?.port) && currentSettings.server?.port !== 0) serverErrors.fields.port = 'Port is required';
        if (Object.keys(serverErrors.fields).length > 0) errors.server = serverErrors;

        // Streaming - all required
        const streamingErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.streaming?.serviceMode)) streamingErrors.fields.serviceMode = 'Service mode is required';
        if (Object.keys(streamingErrors.fields).length > 0) errors.streaming = streamingErrors;

        // Debrid Providers - at least one enabled if debrid/hybrid mode
        if (needsDebrid) {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                errors.debridProviders = {
                    fields: {},
                    messages: ['At least one enabled debrid provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Usenet Providers - at least one enabled if usenet/hybrid mode
        if (needsUsenet) {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                errors.usenet = {
                    fields: {},
                    messages: ['At least one enabled usenet provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Streaming - if service priority selected, must have enabled provider of that type
        const servicePriority = currentSettings.streaming?.servicePriority;
        if (servicePriority === 'usenet') {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                if (!errors.streaming) errors.streaming = { fields: {}, messages: [] };
                errors.streaming.fields.servicePriority = 'Usenet priority requires an enabled usenet provider';
            }
        } else if (servicePriority === 'debrid') {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                if (!errors.streaming) errors.streaming = { fields: {}, messages: [] };
                errors.streaming.fields.servicePriority = 'Debrid priority requires an enabled debrid provider';
            }
        }

        // Indexers - required if usenet/hybrid mode
        if (needsUsenet) {
            const indexers = currentSettings.indexers || [];
            if (!hasEnabledItem(indexers)) {
                errors.indexers = {
                    fields: {},
                    messages: ['At least one enabled indexer is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Torrent Scrapers - required if debrid/hybrid mode
        if (needsDebrid) {
            const scrapers = currentSettings.torrentScrapers || [];
            if (!hasEnabledItem(scrapers)) {
                errors.torrentScrapers = {
                    fields: {},
                    messages: ['At least one enabled scraper is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Metadata - all required
        const metadataErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.metadata?.tvdbApiKey)) metadataErrors.fields.tvdbApiKey = 'TVDB API Key is required';
        if (isEmpty(currentSettings.metadata?.tmdbApiKey)) metadataErrors.fields.tmdbApiKey = 'TMDB API Key is required';
        if (Object.keys(metadataErrors.fields).length > 0) errors.metadata = metadataErrors;

        // Cache - all required
        const cacheErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.cache?.directory)) cacheErrors.fields.directory = 'Cache directory is required';
        if (Object.keys(cacheErrors.fields).length > 0) errors.cache = cacheErrors;

        // Import Settings - all required (numbers can be 0, so just check existence)
        const importErrors = { fields: {}, messages: [] };
        if (currentSettings.import?.rarMaxWorkers === undefined) importErrors.fields.rarMaxWorkers = 'RAR Max Workers is required';
        if (currentSettings.import?.rarMaxCacheSizeMb === undefined) importErrors.fields.rarMaxCacheSizeMb = 'RAR Cache Size is required';
        if (currentSettings.import?.rarMaxMemoryGB === undefined) importErrors.fields.rarMaxMemoryGB = 'RAR Max Memory is required';
        if (Object.keys(importErrors.fields).length > 0) errors.import = importErrors;

        return errors;
    }

    // Get error count for a section
    function getSectionErrorCount(sectionKey) {
        const sectionErrors = validationErrors[sectionKey];
        if (!sectionErrors) return 0;
        const fieldCount = Object.keys(sectionErrors.fields || {}).length;
        const msgCount = (sectionErrors.messages || []).length;
        return fieldCount + msgCount;
    }

    // Check if a specific field has an error
    function getFieldError(sectionKey, fieldKey) {
        return validationErrors[sectionKey]?.fields?.[fieldKey] || null;
    }

    async function handleUserChange(userId) {
        selectedUserId = userId;
        // Clear client selection when user changes
        selectedClientId = '';
        clientSettings = null;
        originalClientSettings = null;
        clientsForUser = [];

        const clientSelector = document.getElementById('clientSelector');
        const identifyBtn = document.getElementById('identifyClientBtn');

        // Always hide identify button when user changes (no client selected yet)
        if (identifyBtn) identifyBtn.style.display = 'none';

        if (userId) {
            // Load user-specific settings
            try {
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(userId));
                if (response.ok) {
                    userSettings = await response.json();
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                } else {
                    showToast('Failed to load user settings', 'error');
                    userSettings = null;
                    originalUserSettings = null;
                }
            } catch (e) {
                showToast('Failed to load user settings: ' + e.message, 'error');
                userSettings = null;
                originalUserSettings = null;
            }

            // Load clients for this user
            await loadClientsForUser(userId);

            // Recalculate whether profile has actual overrides (compare values, not just record existence)
            recalculateUserOverrides(userId);
            updateUserDropdownIndicators();

            // Show client selector if there are clients
            if (clientsForUser.length > 0) {
                const profileHasOverrides = userOverrides && userOverrides[userId];
                clientSelector.innerHTML = `<option value="">Profile Defaults${profileHasOverrides ? ' ●' : ''}</option>` +
                    clientsForUser.map(c => `<option value="${c.id}">${c.name}${c.hasOverrides ? ' ●' : ''}</option>`).join('');
                clientSelector.style.display = 'block';
            } else {
                clientSelector.style.display = 'none';
            }
        } else {
            userSettings = null;
            originalUserSettings = null;
            clientSelector.style.display = 'none';
        }
        renderSettings();
        updateRevertButtonVisibility();
    }

    async function loadClientsForUser(userId) {
        try {
            const response = await fetch(basePath + '/api/clients?userId=' + encodeURIComponent(userId), {
                credentials: 'same-origin'
            });
            if (response.ok) {
                clientsForUser = await response.json() || [];
                // Recalculate hasOverrides for each client by loading their settings
                await recalculateAllClientOverrides();
            } else {
                clientsForUser = [];
            }
        } catch (e) {
            console.warn('Failed to load clients:', e);
            clientsForUser = [];
        }
    }

    // Recalculate hasOverrides for all clients in the list
    async function recalculateAllClientOverrides() {
        for (const client of clientsForUser) {
            try {
                const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(client.id) + '/settings', {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const settings = await response.json();
                    // Check if any client filter fields have actual values that differ from inherited
                    let hasActualOverrides = false;
                    for (const key of clientFilterFields) {
                        const clientVal = settings[key];
                        if (clientVal === undefined || clientVal === null) continue;

                        // Get the effective inherited value
                        const globalVal = currentSettings.filtering ? currentSettings.filtering[key] : undefined;
                        let inheritedVal;

                        if (selectedUserId && userSettings && userSettings.filtering) {
                            const profileVal = userSettings.filtering[key];
                            if (profileVal !== undefined && profileVal !== null &&
                                !deepEqual(normalizeForComparison(profileVal), normalizeForComparison(globalVal))) {
                                inheritedVal = profileVal;
                            } else {
                                inheritedVal = globalVal;
                            }
                        } else {
                            inheritedVal = globalVal;
                        }

                        if (!deepEqual(normalizeForComparison(clientVal), normalizeForComparison(inheritedVal))) {
                            hasActualOverrides = true;
                            break;
                        }
                    }
                    client.hasOverrides = hasActualOverrides;
                }
            } catch (e) {
                console.warn('Failed to load settings for client', client.id, e);
            }
        }
    }

    // Recalculate hasOverrides for all users on page load
    // This compares actual values to global defaults, not just record existence
    async function recalculateAllUserOverrides() {
        if (!userOverrides) return;

        const userIds = Object.keys(userOverrides).filter(id => userOverrides[id]);
        for (const userId of userIds) {
            try {
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(userId), {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const settings = await response.json();
                    if (!settings || Object.keys(settings).length === 0) {
                        userOverrides[userId] = false;
                        continue;
                    }

                    // Check all per-user sections for any actual differences
                    let hasActualOverrides = false;

                    // Check filtering section
                    if (settings.filtering) {
                        const globalFiltering = currentSettings.filtering || {};
                        for (const key of Object.keys(settings.filtering)) {
                            const profileVal = normalizeForComparison(settings.filtering[key]);
                            const globalVal = normalizeForComparison(globalFiltering[key]);
                            if (!deepEqual(profileVal, globalVal)) {
                                hasActualOverrides = true;
                                break;
                            }
                        }
                    }

                    // Check playback section
                    if (!hasActualOverrides && settings.playback) {
                        const globalPlayback = currentSettings.playback || {};
                        for (const key of Object.keys(settings.playback)) {
                            const profileVal = normalizeForComparison(settings.playback[key]);
                            const globalVal = normalizeForComparison(globalPlayback[key]);
                            if (!deepEqual(profileVal, globalVal)) {
                                hasActualOverrides = true;
                                break;
                            }
                        }
                    }

                    // Check homeShelves section
                    if (!hasActualOverrides && settings.homeShelves) {
                        const globalHomeShelves = currentSettings.homeShelves || {};
                        if (!deepEqual(normalizeForComparison(settings.homeShelves), normalizeForComparison(globalHomeShelves))) {
                            hasActualOverrides = true;
                        }
                    }

                    userOverrides[userId] = hasActualOverrides;
                } else {
                    userOverrides[userId] = false;
                }
            } catch (e) {
                console.warn('Failed to load settings for user', userId, e);
            }
        }
        updateUserDropdownIndicators();
    }

    async function handleClientChange(clientId) {
        selectedClientId = clientId;
        const identifyBtn = document.getElementById('identifyClientBtn');
        if (clientId) {
            // Load client-specific settings
            try {
                const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(clientId) + '/settings', {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    clientSettings = await response.json();
                    originalClientSettings = JSON.parse(JSON.stringify(clientSettings));
                } else {
                    clientSettings = {};
                    originalClientSettings = {};
                }
            } catch (e) {
                console.warn('Failed to load client settings:', e);
                clientSettings = {};
                originalClientSettings = {};
            }
            // Recalculate whether client has actual overrides (compare values, not just record existence)
            recalculateClientOverrides(clientId);
            updateClientDropdownIndicators();
            // Show identify button when a client is selected
            if (identifyBtn) identifyBtn.style.display = 'inline-flex';
        } else {
            clientSettings = null;
            originalClientSettings = null;
            // Hide identify button when no client selected
            if (identifyBtn) identifyBtn.style.display = 'none';
        }
        renderSettings();
        updateRevertButtonVisibility();
    }

    async function identifyClient() {
        if (!selectedClientId) return;
        const btn = document.getElementById('identifyClientBtn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Sending...';
        try {
            const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(selectedClientId) + '/ping', {
                method: 'POST',
                credentials: 'same-origin'
            });
            if (response.ok) {
                showToast('Ping sent! If the device is on the settings page, it will flash.');
            } else {
                showToast('Failed to send ping', 'error');
            }
        } catch (e) {
            showToast('Failed to send ping: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }

    // Update revert button visibility based on selection and overrides
    function updateRevertButtonVisibility() {
        const revertBtn = document.getElementById('revertBtn');
        if (!revertBtn) return;

        let showRevert = false;
        let hasOverrides = false;

        if (selectedClientId && clientSettings) {
            // Check if client has any overrides
            hasOverrides = Object.keys(clientSettings).some(k => clientSettings[k] !== undefined && clientSettings[k] !== null);
            showRevert = hasOverrides;
        } else if (selectedUserId) {
            // Check if user/profile has overrides
            hasOverrides = userOverrides && userOverrides[selectedUserId];
            showRevert = hasOverrides;
        }

        revertBtn.style.display = showRevert ? 'inline-flex' : 'none';
        revertBtn.title = selectedClientId
            ? 'Reset all device settings to profile defaults'
            : 'Reset all profile settings to global defaults';
    }

    // Revert all settings to parent defaults (global for profile, profile for client)
    async function revertToGlobal() {
        const isClient = !!selectedClientId;
        const target = isClient ? 'device' : 'profile';
        const parentName = isClient ? 'profile' : 'global';

        if (!confirm(`Are you sure you want to reset all ${target} settings to ${parentName} defaults? This cannot be undone.`)) {
            return;
        }

        const btn = document.getElementById('revertBtn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Resetting...';

        try {
            let response;
            if (isClient) {
                // Reset client settings
                response = await fetch(basePath + '/api/clients/' + encodeURIComponent(selectedClientId) + '/settings', {
                    method: 'DELETE',
                    credentials: 'same-origin'
                });
            } else {
                // Reset user/profile settings
                response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'DELETE',
                    credentials: 'same-origin'
                });
            }

            if (response.ok) {
                showToast(`${isClient ? 'Device' : 'Profile'} settings reset to ${parentName} defaults`);

                // Update local state
                if (isClient) {
                    clientSettings = {};
                    originalClientSettings = {};
                    // Update client in the list
                    const clientInList = clientsForUser.find(c => c.id === selectedClientId);
                    if (clientInList) clientInList.hasOverrides = false;
                    updateClientDropdownIndicators();
                } else {
                    userSettings = null;
                    originalUserSettings = null;
                    // Update user overrides tracking
                    if (userOverrides) userOverrides[selectedUserId] = false;
                    updateUserDropdownIndicators();
                    updateClientDropdownIndicators(); // Update "Profile Defaults" indicator
                }

                updateRevertButtonVisibility();
                renderSettings();
            } else {
                const err = await response.text();
                showToast('Failed to reset settings: ' + err, 'error');
            }
        } catch (e) {
            showToast('Failed to reset settings: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }

    // Update the user dropdown to show/hide override indicators
    function updateUserDropdownIndicators() {
        const userSelector = document.getElementById('userSelector');
        if (!userSelector) return;

        Array.from(userSelector.options).forEach(option => {
            if (!option.value) return; // Skip "Global Defaults" option
            const hasOverride = userOverrides && userOverrides[option.value];
            const currentText = option.text.replace(/ ●$/, ''); // Remove existing indicator
            option.text = hasOverride ? currentText + ' ●' : currentText;
            option.dataset.hasOverrides = hasOverride ? 'true' : 'false';
        });
    }

    // Update the client dropdown to show/hide override indicators
    function updateClientDropdownIndicators() {
        const clientSelector = document.getElementById('clientSelector');
        if (!clientSelector) return;

        // Update "Profile Defaults" option
        const profileDefaultsOption = clientSelector.querySelector('option[value=""]');
        if (profileDefaultsOption && selectedUserId) {
            const profileHasOverrides = userOverrides && userOverrides[selectedUserId];
            profileDefaultsOption.text = profileHasOverrides ? 'Profile Defaults ●' : 'Profile Defaults';
        }

        // Update individual client options
        clientsForUser.forEach(client => {
            const option = clientSelector.querySelector(`option[value="${client.id}"]`);
            if (option) {
                const currentText = option.text.replace(/ ●$/, '');
                option.text = client.hasOverrides ? currentText + ' ●' : currentText;
            }
        });
    }

    // Check if user settings have any actual differences from global settings
    // This recalculates userOverrides based on actual value comparison, not just record existence
    function recalculateUserOverrides(userId) {
        if (!userId || !userSettings) {
            if (userOverrides) userOverrides[userId] = false;
            return;
        }

        // Check all per-user sections for any actual differences
        let hasActualOverrides = false;

        // Check filtering section
        if (userSettings.filtering) {
            const globalFiltering = currentSettings.filtering || {};
            for (const key of Object.keys(userSettings.filtering)) {
                const profileVal = normalizeForComparison(userSettings.filtering[key]);
                const globalVal = normalizeForComparison(globalFiltering[key]);
                if (!deepEqual(profileVal, globalVal)) {
                    hasActualOverrides = true;
                    break;
                }
            }
        }

        // Check playback section
        if (!hasActualOverrides && userSettings.playback) {
            const globalPlayback = currentSettings.playback || {};
            for (const key of Object.keys(userSettings.playback)) {
                const profileVal = normalizeForComparison(userSettings.playback[key]);
                const globalVal = normalizeForComparison(globalPlayback[key]);
                if (!deepEqual(profileVal, globalVal)) {
                    hasActualOverrides = true;
                    break;
                }
            }
        }

        // Check homeShelves section
        if (!hasActualOverrides && userSettings.homeShelves) {
            const globalHomeShelves = currentSettings.homeShelves || {};
            if (!deepEqual(normalizeForComparison(userSettings.homeShelves), normalizeForComparison(globalHomeShelves))) {
                hasActualOverrides = true;
            }
        }

        if (userOverrides) userOverrides[userId] = hasActualOverrides;
    }

    // Recalculate whether a client has actual overrides (compare to profile/global values)
    function recalculateClientOverrides(clientId) {
        const client = clientsForUser.find(c => c.id === clientId);
        if (!client || !clientSettings) {
            if (client) client.hasOverrides = false;
            return;
        }

        // Check if any client filter fields have actual values that differ from inherited
        let hasActualOverrides = false;
        for (const key of clientFilterFields) {
            const clientVal = clientSettings[key];
            if (clientVal === undefined || clientVal === null) continue;

            // Get the effective inherited value using the same logic as getInheritedValue
            // First check if profile has a value that differs from global
            let inheritedVal;
            const globalVal = currentSettings.filtering ? currentSettings.filtering[key] : undefined;

            if (selectedUserId && userSettings && userSettings.filtering) {
                const profileVal = userSettings.filtering[key];
                // Use profile value if it's set AND differs from global
                if (profileVal !== undefined && profileVal !== null &&
                    !deepEqual(normalizeForComparison(profileVal), normalizeForComparison(globalVal))) {
                    inheritedVal = profileVal;
                } else {
                    inheritedVal = globalVal;
                }
            } else {
                inheritedVal = globalVal;
            }

            if (!deepEqual(normalizeForComparison(clientVal), normalizeForComparison(inheritedVal))) {
                hasActualOverrides = true;
                break;
            }
        }

        client.hasOverrides = hasActualOverrides;
    }

    const icons = {
        'server': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>',
        'download': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>',
        'search': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        'magnet': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><path d="M22 7l-10 7L2 7"/></svg>',
        'film': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/></svg>',
        'database': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>',
        'folder': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
        'play-circle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>',
        'cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
        'upload': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>',
        'download-cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="8 17 12 21 16 17"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"/></svg>',
        'shuffle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>',
        'play': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>',
        'tv': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>',
        'layout': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>',
        'list': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        'filter': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>',
        'monitor': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>',
        'users': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>',
        'lock': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>',
        'unlock': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>',
        'edit': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
        'trash': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>',
        'plus': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>',
        'check': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>',
        'x': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>',
        'shield': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>',
        'key': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>',
    };

    function getIcon(name) { return icons[name] || icons['server']; }

    // Map section keys to user settings structure
    function mapToUserSettingsPath(path) {
        // homeShelves.shelves.0.enabled -> homeShelves.shelves.0.enabled (same)
        // playback.preferredPlayer -> playback.preferredPlayer (same)
        // filtering.maxSizeMovieGb -> filtering.maxSizeMovieGb (same)
        return path;
    }

    // Map filtering field paths to client settings keys
    const clientFilterFields = ['maxSizeMovieGb', 'maxSizeEpisodeGb', 'maxResolution', 'hdrDvPolicy', 'prioritizeHdr', 'filterOutTerms', 'preferredTerms', 'bypassFilteringForAioStreamsOnly'];

    function getClientSettingsKey(path) {
        // filtering.maxSizeMovieGb -> maxSizeMovieGb
        const keys = path.split('.');
        if (keys[0] === 'filtering' && keys.length === 2 && clientFilterFields.includes(keys[1])) {
            return keys[1];
        }
        return null;
    }

    function getValue(path) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If client selected and this is a client-supported filtering field
        const clientKey = getClientSettingsKey(path);
        if (selectedClientId && clientSettings && clientKey) {
            // Return client setting if set, otherwise fall through to profile/global
            if (clientSettings[clientKey] !== undefined && clientSettings[clientKey] !== null) {
                return clientSettings[clientKey];
            }
        }

        // If user selected and this is a per-user section, use userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let val = userSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return undefined;
                val = val[key];
            }
            return val;
        }

        // Otherwise use global settings
        let val = currentSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return undefined;
            val = val[key];
        }
        return val;
    }

    function setValue(path, value) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If client selected and this is a client-supported filtering field
        const clientKey = getClientSettingsKey(path);
        if (selectedClientId && clientSettings !== null && clientKey) {
            clientSettings[clientKey] = value;
            return;
        }

        // If user selected and this is a per-user section, update userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let obj = userSettings;
            for (let i = 0; i < keys.length - 1; i++) {
                if (obj[keys[i]] === undefined) obj[keys[i]] = {};
                obj = obj[keys[i]];
            }
            obj[keys[keys.length - 1]] = value;
            return;
        }

        // Otherwise update global settings
        let obj = currentSettings;
        for (let i = 0; i < keys.length - 1; i++) {
            if (obj[keys[i]] === undefined) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
    }

    // Check if a client setting is explicitly set (not inherited)
    function isClientSettingSet(fieldKey) {
        if (!selectedClientId || !clientSettings) return false;
        return clientSettings[fieldKey] !== undefined && clientSettings[fieldKey] !== null;
    }

    // Check if a client value is actually different from what it would inherit
    function isClientValueDifferent(fieldKey) {
        if (!selectedClientId || !clientSettings) return false;
        const clientVal = clientSettings[fieldKey];
        if (clientVal === undefined || clientVal === null) return false;

        // Get the effective inherited value (profile if different from global, otherwise global)
        const globalVal = currentSettings.filtering ? currentSettings.filtering[fieldKey] : undefined;
        let inheritedVal;

        if (selectedUserId && userSettings && userSettings.filtering) {
            const profileVal = userSettings.filtering[fieldKey];
            // Use profile value if it's set AND differs from global
            if (profileVal !== undefined && profileVal !== null &&
                !deepEqual(normalizeForComparison(profileVal), normalizeForComparison(globalVal))) {
                inheritedVal = profileVal;
            } else {
                inheritedVal = globalVal;
            }
        } else {
            inheritedVal = globalVal;
        }

        return !deepEqual(normalizeForComparison(clientVal), normalizeForComparison(inheritedVal));
    }

    // Clear a client setting (revert to profile default)
    function clearClientSetting(fieldKey) {
        if (selectedClientId && clientSettings) {
            delete clientSettings[fieldKey];
            renderSettings();
        }
    }

    // Check if a user/profile setting is explicitly set (exists in userSettings)
    function isUserSettingSet(path) {
        if (!selectedUserId || !userSettings) return false;
        const keys = path.split('.');
        let val = userSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return false;
            if (typeof val !== 'object') return false;
            if (!(key in val)) return false;
            val = val[key];
        }
        // Value exists in userSettings (even if it's false, 0, or empty string)
        return true;
    }

    // Normalize empty values for comparison (treat undefined, null, [], "" as equivalent "empty")
    function normalizeForComparison(val) {
        if (val === undefined || val === null) return null;
        if (Array.isArray(val) && val.length === 0) return null;
        if (typeof val === 'string' && val.trim() === '') return null;
        return val;
    }

    // Check if profile value is different from global (actual override)
    function isProfileValueDifferent(path) {
        if (!selectedUserId || !userSettings) return false;
        const keys = path.split('.');
        const topKey = keys[0];

        // Get profile value
        let profileVal = userSettings;
        for (const key of keys) {
            if (profileVal === undefined || profileVal === null) return false;
            if (typeof profileVal !== 'object' || !(key in profileVal)) return false;
            profileVal = profileVal[key];
        }

        // Get global value
        let globalVal = currentSettings;
        for (const key of keys) {
            if (globalVal === undefined || globalVal === null) {
                globalVal = undefined;
                break;
            }
            globalVal = globalVal[key];
        }

        // Normalize and compare - treat empty arrays/strings/null/undefined as equivalent
        const normProfile = normalizeForComparison(profileVal);
        const normGlobal = normalizeForComparison(globalVal);

        return !deepEqual(normProfile, normGlobal);
    }

    // Get the inherited value (what value would be used if current level override is removed)
    function getInheritedValue(path) {
        const keys = path.split('.');
        const topKey = keys[0];
        const clientKey = getClientSettingsKey(path);

        // If we're at client level, inherited value is from profile or global
        if (selectedClientId && clientKey) {
            // Get profile value if set, otherwise global
            if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
                let val = userSettings;
                for (const key of keys) {
                    if (val === undefined || val === null) break;
                    val = val[key];
                }
                if (val !== undefined && val !== null) return { value: val, source: 'profile' };
            }
            // Fall through to global
            let val = currentSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return { value: undefined, source: 'global' };
                val = val[key];
            }
            return { value: val, source: 'global' };
        }

        // If we're at profile level, inherited value is from global
        if (selectedUserId && perUserSections.includes(topKey)) {
            let val = currentSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return { value: undefined, source: 'global' };
                val = val[key];
            }
            return { value: val, source: 'global' };
        }

        return { value: undefined, source: 'global' };
    }

    // Get inheritance information for a field
    // Returns: { source: 'client'|'profile'|'global', isOverridden: boolean, inheritedFrom: string|null }
    function getInheritanceInfo(path) {
        const keys = path.split('.');
        const topKey = keys[0];
        const clientKey = getClientSettingsKey(path);

        // Check if we're editing client settings and this field supports client override
        if (selectedClientId && clientSettings && clientKey) {
            // Check if client has a value that's actually different from what it would inherit
            if (isClientValueDifferent(clientKey)) {
                // Value is set at client level AND differs from inherited - check what it would inherit from
                const profileHasOverride = isUserSettingSet(path) && isProfileValueDifferent(path);
                return { source: 'client', isOverridden: true, inheritedFrom: profileHasOverride ? 'profile' : 'global' };
            }
            // Value is inherited (either not set, or set but same as inherited) - check if from profile or global
            if (isUserSettingSet(path) && isProfileValueDifferent(path)) {
                return { source: 'profile', isOverridden: false, inheritedFrom: null };
            }
            return { source: 'global', isOverridden: false, inheritedFrom: null };
        }

        // Check if we're editing profile settings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            // Check if profile has this setting AND it's different from global
            if (isUserSettingSet(path) && isProfileValueDifferent(path)) {
                return { source: 'profile', isOverridden: true, inheritedFrom: 'global' };
            }
            return { source: 'global', isOverridden: false, inheritedFrom: null };
        }

        // We're at global level
        return { source: 'global', isOverridden: false, inheritedFrom: null };
    }

    // Clear a profile setting (revert to global default)
    function clearProfileSetting(path) {
        if (!selectedUserId || !userSettings) return;
        const keys = path.split('.');
        if (keys.length === 2) {
            const [section, field] = keys;
            if (userSettings[section]) {
                delete userSettings[section][field];
                renderSettings();
            }
        }
    }

    // Format a value for display in tooltip
    function formatValueForTooltip(value) {
        if (value === undefined || value === null) return 'not set';
        if (typeof value === 'boolean') return value ? 'Yes' : 'No';
        if (Array.isArray(value)) {
            if (value.length === 0) return 'none';
            return value.join(', ');
        }
        if (typeof value === 'number') return String(value);
        if (typeof value === 'string') return value || 'empty';
        return String(value);
    }

    // Render inheritance badge for a field
    function renderInheritanceBadge(path, fieldDef) {
        // Only show inheritance info when editing profile or client settings
        if (!selectedUserId && !selectedClientId) return '';

        const info = getInheritanceInfo(path);
        const inherited = getInheritedValue(path);
        const clientKey = getClientSettingsKey(path);

        let badgeHtml = '';
        let resetBtn = '';

        if (info.isOverridden) {
            // Show that this value overrides a parent level
            const sourceLabel = info.source === 'client' ? 'Device' : 'Profile';
            const inheritedLabel = info.inheritedFrom === 'profile' ? 'profile' : 'global';
            const inheritedValueStr = formatValueForTooltip(inherited.value);
            const tooltip = 'Overrides ' + inheritedLabel + ' default: ' + inheritedValueStr;
            badgeHtml = '<span class="inheritance-badge overridden" title="' + tooltip.replace(/"/g, '&quot;') + '">' + sourceLabel + '</span>';

            // Add reset button
            if (info.source === 'client' && clientKey) {
                resetBtn = '<button type="button" class="inheritance-reset" onclick="clearClientSetting(\'' + clientKey + '\')" title="Reset to ' + inheritedLabel + ' value: ' + inheritedValueStr.replace(/"/g, '&quot;') + '">↩</button>';
            } else if (info.source === 'profile') {
                resetBtn = '<button type="button" class="inheritance-reset" onclick="clearProfileSetting(\'' + path + '\')" title="Reset to global value: ' + inheritedValueStr.replace(/"/g, '&quot;') + '">↩</button>';
            }
        } else {
            // Show where value is inherited from
            const sourceLabel = info.source === 'profile' ? 'From Profile' : 'From Global';
            badgeHtml = '<span class="inheritance-badge inherited" title="Using ' + info.source + ' default">' + sourceLabel + '</span>';
        }

        return '<span class="inheritance-wrapper">' + badgeHtml + resetBtn + '</span>';
    }
    function renderInput(fieldKey, fieldDef, value, basePath, sectionKey) {
        const id = (basePath + '_' + fieldKey).replace(/\./g, '_');
        const isReadonly = fieldDef.readonly ? 'readonly' : '';
        const fieldError = getFieldError(sectionKey, fieldKey);
        const invalidClass = fieldError ? ' invalid' : '';
        switch (fieldDef.type) {
            case 'boolean':
                return '<label class="toggle"><input type="checkbox" id="'+id+'" '+(value ? 'checked' : '')+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.checked)"><span class="toggle-slider"></span></label>';
            case 'select':
                const options = fieldDef.options.map(opt => {
                    const optValue = typeof opt === 'object' ? opt.value : opt;
                    const optLabel = typeof opt === 'object' ? opt.label : opt;
                    return '<option value="'+optValue+'" '+(value === optValue ? 'selected' : '')+'>'+optLabel+'</option>';
                }).join('');
                return '<select class="form-select'+invalidClass+'" id="'+id+'" onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">'+options+'</select>';
            case 'number':
                return '<input type="number" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || 0)+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', parseFloat(this.value) || 0)">';
            case 'password':
                return '<input type="password" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
            case 'tags':
                const tags = Array.isArray(value) ? value : [];
                const tagsHtml = tags.map(tag => '<span class="tag">'+tag+'<span class="tag-remove" onclick="removeTag(\''+basePath+'\', \''+fieldKey+'\', \''+tag+'\')">&times;</span></span>').join('');
                return '<div class="tags-input'+invalidClass+'" id="'+id+'_container">'+tagsHtml+'<input type="text" placeholder="Add tag..." onkeydown="handleTagInput(event, \''+basePath+'\', \''+fieldKey+'\')"></div>';
            case 'checkboxes':
                const selectedValues = Array.isArray(value) ? value : [];
                const checkboxesHtml = (fieldDef.options || []).map(opt => {
                    const optValue = typeof opt === 'object' ? opt.value : opt;
                    const optLabel = typeof opt === 'object' ? opt.label : opt;
                    const isChecked = selectedValues.includes(optValue) ? 'checked' : '';
                    return '<label class="checkbox-option"><input type="checkbox" value="'+optValue+'" '+isChecked+' onchange="handleCheckboxChange(\''+basePath+'\', \''+fieldKey+'\', \''+optValue+'\', this.checked)"><span>'+optLabel+'</span></label>';
                }).join('');
                return '<div class="checkboxes-group'+invalidClass+'" id="'+id+'_container">'+checkboxesHtml+'</div>';
            default:
                return '<input type="text" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
        }
    }
    function handleFieldChange(basePath, fieldKey, value) {
        setValue(basePath ? basePath+'.'+fieldKey : fieldKey, value);
        // Re-render to update validation indicators (renderSettings runs validation)
        renderSettings();
    }
    function handleTagInput(event, basePath, fieldKey) {
        if (event.key === 'Enter' || event.key === ',') {
            event.preventDefault();
            const tag = event.target.value.trim();
            if (tag) { addTag(basePath, fieldKey, tag); event.target.value = ''; }
        }
    }
    function addTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = getValue(fullPath) || [];
        if (!tags.includes(tag)) { tags.push(tag); setValue(fullPath, tags); renderSettings(); }
    }
    function removeTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = (getValue(fullPath) || []).filter(t => t !== tag);
        setValue(fullPath, tags);
        renderSettings();
    }
    function handleCheckboxChange(basePath, fieldKey, optionValue, isChecked) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let values = getValue(fullPath) || [];
        if (!Array.isArray(values)) values = [];
        if (isChecked && !values.includes(optionValue)) {
            values.push(optionValue);
        } else if (!isChecked) {
            values = values.filter(v => v !== optionValue);
        }
        setValue(fullPath, values);
        renderSettings();
    }
    function addArrayItem(sectionKey) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr;
        if (sectionDef.parent) {
            if (!targetSettings[sectionDef.parent]) targetSettings[sectionDef.parent] = {};
            arr = targetSettings[sectionDef.parent][sectionDef.key] || [];
            targetSettings[sectionDef.parent][sectionDef.key] = arr;
        } else {
            arr = targetSettings[sectionKey] || [];
            targetSettings[sectionKey] = arr;
        }
        const newItem = {};
        for (const [fieldKey, fieldDef] of Object.entries(sectionDef.fields)) {
            switch (fieldDef.type) {
                case 'boolean': newItem[fieldKey] = false; break;
                case 'number': newItem[fieldKey] = 0; break;
                case 'select':
                    const firstOpt = fieldDef.options?.[0];
                    newItem[fieldKey] = typeof firstOpt === 'object' ? firstOpt.value : (firstOpt || '');
                    break;
                default: newItem[fieldKey] = '';
            }
        }
        arr.push(newItem);
        renderSettings();
    }
    function removeArrayItem(sectionKey, index) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr = sectionDef.parent ? targetSettings[sectionDef.parent]?.[sectionDef.key] : targetSettings[sectionKey];
        if (arr && arr.length > index) { arr.splice(index, 1); renderSettings(); }
    }
    // Test provider functions
    async function testProvider(sectionKey, index) {
        const btn = document.getElementById('test-btn-'+sectionKey+'-'+index);
        const resultSpan = document.getElementById('test-result-'+sectionKey+'-'+index);
        if (!btn) return;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Testing...';
        resultSpan.textContent = '';
        resultSpan.className = 'test-result';

        let endpoint, payload;
        const sectionDef = schema[sectionKey];
        let items;

        if (sectionDef.parent) {
            items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
        } else {
            items = currentSettings[sectionKey] || [];
        }
        const item = items[index];
        if (!item) {
            btn.disabled = false;
            btn.textContent = 'Test';
            resultSpan.textContent = 'Item not found';
            resultSpan.className = 'test-result error';
            return;
        }

        switch(sectionKey) {
            case 'indexers':
                endpoint = '/admin/api/test/indexer';
                payload = { url: item.url, apiKey: item.apiKey, name: item.name };
                break;
            case 'torrentScrapers':
                endpoint = '/admin/api/test/scraper';
                payload = { name: item.name, type: item.type, url: item.url, apiKey: item.apiKey };
                break;
            case 'usenet':
                endpoint = '/admin/api/test/usenet-provider';
                payload = {
                    name: item.name,
                    host: item.host,
                    port: item.port,
                    ssl: item.ssl,
                    username: item.username,
                    password: item.password
                };
                break;
            case 'debridProviders':
                endpoint = '/admin/api/test/debrid-provider';
                payload = { name: item.name, provider: item.provider, apiKey: item.apiKey };
                break;
            default:
                btn.disabled = false;
                btn.textContent = 'Test';
                resultSpan.textContent = 'Unknown section';
                resultSpan.className = 'test-result error';
                return;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            btn.disabled = false;
            btn.textContent = 'Test';

            if (result.success) {
                resultSpan.textContent = result.message || 'Success';
                resultSpan.className = 'test-result success';
            } else {
                resultSpan.textContent = result.error || 'Test failed';
                resultSpan.className = 'test-result error';
            }
        } catch (e) {
            btn.disabled = false;
            btn.textContent = 'Test';
            resultSpan.textContent = 'Error: ' + e.message;
            resultSpan.className = 'test-result error';
        }
    }

    // Testable sections
    const testableSections = ['indexers', 'torrentScrapers', 'usenet', 'debridProviders'];

    // Deep equality check for comparing values
    function deepEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return a == b;
        if (typeof a !== typeof b) return false;
        if (typeof a !== 'object') return false;
        if (Array.isArray(a) !== Array.isArray(b)) return false;

        if (Array.isArray(a)) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) return false;
            }
            return true;
        }

        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) return false;

        for (const key of keysA) {
            if (!keysB.includes(key) || !deepEqual(a[key], b[key])) return false;
        }
        return true;
    }

    // Check if a specific section has unsaved changes
    function sectionHasChanges(sectionKey) {
        const sectionDef = schema[sectionKey];
        if (!sectionDef) return false;

        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        let hasDirectChanges = false;

        if (selectedUserId && isPerUserSection) {
            // Compare user settings
            if (!userSettings || !originalUserSettings) return false;

            if (sectionDef.parent) {
                const currentVal = userSettings[sectionDef.parent]?.[sectionDef.key];
                const originalVal = originalUserSettings[sectionDef.parent]?.[sectionDef.key];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            } else {
                const currentVal = userSettings[sectionKey];
                const originalVal = originalUserSettings[sectionKey];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            }
        } else {
            // Compare global settings
            if (sectionDef.parent) {
                const currentVal = currentSettings[sectionDef.parent]?.[sectionDef.key];
                const originalVal = originalSettings[sectionDef.parent]?.[sectionDef.key];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            } else {
                const currentVal = currentSettings[sectionKey];
                const originalVal = originalSettings[sectionKey];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            }
        }

        if (hasDirectChanges) return true;

        // Also check nested sections that are rendered within this section
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (sectionHasChanges(nestedKey)) return true;
            }
        }

        return false;
    }

    // Save a specific section (still saves all, but used for UX)
    async function saveSection(sectionKey, event) {
        event.stopPropagation(); // Don't toggle section when clicking save

        const btn = event.target.closest('.section-save-btn');
        if (!btn) return;

        const originalHtml = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span>';

        try {
            if (selectedUserId && userSettings) {
                // Save user-specific settings
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(userSettings)
                });
                if (response.ok) {
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
                    showToast('Settings saved successfully');
                    // Update override indicators
                    if (userOverrides) userOverrides[selectedUserId] = true;
                    updateUserDropdownIndicators();
                    updateClientDropdownIndicators();
                    updateRevertButtonVisibility();
                    setTimeout(() => renderSettings(), 500);
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save settings', 'error');
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            } else {
                // Save global settings
                const response = await fetch(basePath + '/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
                    showToast('Settings saved successfully');
                    setTimeout(() => renderSettings(), 500);
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            }
        } catch (e) {
            showToast('Failed to save settings: ' + e.message, 'error');
            btn.innerHTML = originalHtml;
            btn.disabled = false;
        }
    }

    function renderArraySection(sectionKey, sectionDef) {
        let items, basePath;
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        if (sectionDef.parent) {
            // For nested array sections like homeShelves.shelves
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionDef.parent]?.[sectionDef.key] || [];
            } else {
                items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
            }
            basePath = sectionDef.parent+'.'+sectionDef.key;
        } else {
            // For top-level array sections
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionKey] || [];
            } else {
                items = currentSettings[sectionKey] || [];
            }
            basePath = sectionKey;
        }
        const isTestable = testableSections.includes(sectionKey);
        const itemsHtml = items.map((item, index) => {
            const fieldsHtml = Object.entries(sectionDef.fields)
                .sort((a, b) => (a[1].order || 0) - (b[1].order || 0))
                .map(([fieldKey, fieldDef]) => {
                const showWhen = fieldDef.showWhen;
                if (showWhen) {
                    let shouldShow = false;
                    if (showWhen.operator === 'or' && Array.isArray(showWhen.conditions)) {
                        shouldShow = showWhen.conditions.some(cond => item[cond.field] === cond.value);
                    } else {
                        shouldShow = item[showWhen.field] === showWhen.value;
                    }
                    if (!shouldShow) return '';
                }
                return '<div class="form-group"><label class="form-label">'+fieldDef.label+'</label>'+renderInput(fieldKey, fieldDef, item[fieldKey], basePath+'.'+index, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+'</div>';
            }).join('');
            const testBtn = isTestable ? '<button id="test-btn-'+sectionKey+'-'+index+'" class="btn btn-sm btn-secondary" onclick="testProvider(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test</button>' : '';
            const testResult = isTestable ? '<span id="test-result-'+sectionKey+'-'+index+'" class="test-result"></span>' : '';
            return '<div class="array-item"><div class="array-item-header"><div class="array-item-title">'+(item.name || item.id || 'Item '+(index+1))+'</div><div class="array-item-actions">'+testBtn+testResult+'<button class="btn btn-sm btn-danger" onclick="removeArrayItem(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button></div></div><div class="grid grid-2">'+fieldsHtml+'</div></div>';
        }).join('');
        return '<div class="array-items">'+itemsHtml+'<button class="add-item-btn" onclick="addArrayItem(\''+sectionKey+'\')"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add '+sectionDef.label.replace(/s$/, '')+'</button></div>';
    }
    function renderObjectSection(sectionKey, sectionDef) {
        // Use getValue for proper three-tier cascade (global → profile → client)
        const fieldsHtml = Object.entries(sectionDef.fields)
            .sort((a, b) => (a[1].order || 0) - (b[1].order || 0))
            .map(([fieldKey, fieldDef]) => {
                const fieldError = getFieldError(sectionKey, fieldKey);
                const invalidClass = fieldError ? ' invalid' : '';
                const errorHtml = fieldError ? '<div class="validation-message"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+fieldError+'</div>' : '';
                const fieldValue = getValue(sectionKey + '.' + fieldKey);
                const fieldPath = sectionKey + '.' + fieldKey;
                const inheritanceBadge = renderInheritanceBadge(fieldPath, fieldDef);
                return '<div class="form-group'+invalidClass+'"><label class="form-label"><span>'+fieldDef.label+'</span>'+inheritanceBadge+'</label>'+renderInput(fieldKey, fieldDef, fieldValue, sectionKey, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+errorHtml+'</div>';
            }).join('');

        // Add test button for testable object sections
        let testHtml = '';
        if (sectionDef.testable) {
            testHtml = '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.75rem;">'+
                '<button id="test-btn-'+sectionKey+'" class="btn btn-secondary" onclick="testObjectSection(\''+sectionKey+'\')">'+
                '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection</button>'+
                '<span id="test-result-'+sectionKey+'" class="test-result"></span></div>';
        }
        return fieldsHtml + testHtml;
    }

    // Test object section (non-array sections like subtitles)
    async function testObjectSection(sectionKey) {
        const btn = document.getElementById('test-btn-'+sectionKey);
        const resultSpan = document.getElementById('test-result-'+sectionKey);
        if (!btn) return;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Testing...';
        resultSpan.textContent = '';
        resultSpan.className = 'test-result';

        let endpoint, payload;
        const sectionData = currentSettings[sectionKey] || {};

        switch(sectionKey) {
            case 'subtitles':
                endpoint = '/admin/api/test/subtitles';
                payload = {
                    username: sectionData.openSubtitlesUsername || '',
                    password: sectionData.openSubtitlesPassword || ''
                };
                break;
            default:
                btn.disabled = false;
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection';
                resultSpan.textContent = 'Unknown section';
                resultSpan.className = 'test-result error';
                return;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            btn.disabled = false;
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection';

            if (result.success) {
                resultSpan.textContent = result.message || 'Success';
                resultSpan.className = 'test-result success';
            } else {
                resultSpan.textContent = result.error || 'Test failed';
                resultSpan.className = 'test-result error';
            }
        } catch (e) {
            btn.disabled = false;
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection';
            resultSpan.textContent = 'Error: ' + e.message;
            resultSpan.className = 'test-result error';
        }
    }
    function renderSection(sectionKey, sectionDef) {
        const isOpen = window.location.hash === '#'+sectionKey;
        const errorCount = getSectionErrorCount(sectionKey);
        const sectionMessages = validationErrors[sectionKey]?.messages || [];
        const hasChanges = sectionHasChanges(sectionKey);

        // Warning badge for section header
        const warningBadge = errorCount > 0 ? '<span class="section-warning">'+errorCount+'</span>' : '';

        // Save button for section header (only show when section has changes and not a custom section)
        const saveBtn = (hasChanges && !sectionDef.custom) ? '<button class="section-save-btn" onclick="saveSection(\''+sectionKey+'\', event)" title="Save changes"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg> Save</button>' : '';

        // Section-level validation messages
        let messagesHtml = '';
        if (sectionMessages.length > 0) {
            messagesHtml = sectionMessages.map(msg =>
                '<div class="section-validation-msg"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+msg+'</div>'
            ).join('');
        }

        // Handle custom sections (like profiles, userAccounts)
        let contentHtml;
        if (sectionDef.custom && sectionKey === 'profiles') {
            contentHtml = renderProfilesSection();
        } else if (sectionDef.custom && sectionKey === 'userAccounts') {
            contentHtml = renderUserAccountsSection();
        } else {
            contentHtml = sectionDef.is_array ? renderArraySection(sectionKey, sectionDef) : '<div class="grid grid-2">'+renderObjectSection(sectionKey, sectionDef)+'</div>';
        }

        // Add clear cache button for cache section
        if (sectionKey === 'cache') {
            contentHtml += '<div class="cache-actions" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);"><button class="btn btn-secondary" id="clear-cache-btn" onclick="clearMetadataCache()"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Clear Metadata Cache</button><p class="form-hint" style="margin-top: 0.5rem;">Remove all cached metadata and posters. Fresh data will be fetched from TVDB/TMDB on next request.</p></div>';
        }
        let nestedHtml = '';
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            // Only render as nested if parent matches AND section doesn't have its own group
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (selectedUserId && !perUserSections.includes(nestedKey)) continue;
                nestedHtml += '<div style="margin-top: 1.5rem;"><h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">'+nestedDef.label+'</h3>'+renderArraySection(nestedKey, nestedDef)+'</div>';
            }
        }
        return '<div class="section '+(isOpen ? 'open' : '')+(hasChanges ? ' has-changes' : '')+'" id="section-'+sectionKey+'"><div class="section-header" onclick="toggleSection(this)"><div class="section-title">'+getIcon(sectionDef.icon)+sectionDef.label+warningBadge+'</div><div class="section-header-actions">'+saveBtn+'<svg class="section-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></div></div><div class="section-content">'+messagesHtml+contentHtml+nestedHtml+'</div></div>';
    }

    // Profile management functions
    async function loadProfiles() {
        try {
            const response = await fetch(basePath + '/api/profiles');
            if (response.ok) {
                profilesData = await response.json();
            } else {
                console.error('Failed to load profiles');
                profilesData = [];
            }
        } catch (e) {
            console.error('Error loading profiles:', e);
            profilesData = [];
        }
    }

    // Account management functions
    async function loadAccounts() {
        try {
            const response = await fetch(basePath + '/api/accounts');
            if (response.ok) {
                accountsData = await response.json();
            } else {
                console.error('Failed to load accounts');
                accountsData = [];
            }
        } catch (e) {
            console.error('Error loading accounts:', e);
            accountsData = [];
        }
    }

    async function checkDefaultPassword() {
        try {
            const response = await fetch(basePath + '/api/accounts/default-password');
            if (response.ok) {
                const data = await response.json();
                hasDefaultPassword = data.hasDefaultPassword;
            }
        } catch (e) {
            console.error('Error checking default password:', e);
        }
    }

    async function createAccount(username, password) {
        try {
            const response = await fetch(basePath + '/api/accounts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            if (response.ok) {
                const created = await response.json();
                accountsData.push(created);
                showToast('Account created successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to create account', 'error');
            }
        } catch (e) {
            showToast('Error creating account: ' + e.message, 'error');
        }
    }

    async function deleteAccount(accountId) {
        if (!confirm('Delete this account? All associated profiles will be reassigned to the default account.')) {
            return;
        }
        try {
            const response = await fetch(basePath + '/api/accounts?accountId=' + encodeURIComponent(accountId), {
                method: 'DELETE'
            });
            if (response.ok) {
                accountsData = accountsData.filter(a => a.id !== accountId);
                await loadAccounts(); // Reload to get updated profile assignments
                showToast('Account deleted');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to delete account', 'error');
            }
        } catch (e) {
            showToast('Error deleting account: ' + e.message, 'error');
        }
    }

    async function resetAccountPassword(accountId, newPassword) {
        try {
            const response = await fetch(basePath + '/api/accounts/password?accountId=' + encodeURIComponent(accountId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password: newPassword })
            });
            if (response.ok) {
                showToast('Password reset successfully');
                if (accountsData.find(a => a.id === accountId)?.isMaster) {
                    hasDefaultPassword = false;
                }
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to reset password', 'error');
            }
        } catch (e) {
            showToast('Error resetting password: ' + e.message, 'error');
        }
    }

    async function reassignProfile(profileId, newAccountId) {
        try {
            const response = await fetch(basePath + '/api/profiles/reassign?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ accountId: newAccountId })
            });
            if (response.ok) {
                await loadAccounts(); // Reload to get updated assignments
                showToast('Profile reassigned');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to reassign profile', 'error');
            }
        } catch (e) {
            showToast('Error reassigning profile: ' + e.message, 'error');
        }
    }

    function handleCreateAccountSubmit(event) {
        event.preventDefault();
        const usernameInput = document.getElementById('new-account-username');
        const passwordInput = document.getElementById('new-account-password');
        const username = usernameInput.value.trim();
        const password = passwordInput.value;
        if (!username) {
            showToast('Username is required', 'error');
            return;
        }
        if (password.length < 4) {
            showToast('Password must be at least 4 characters', 'error');
            return;
        }
        createAccount(username, password);
        usernameInput.value = '';
        passwordInput.value = '';
        document.getElementById('add-account-form').style.display = 'none';
    }

    function handleResetPasswordSubmit(event, accountId) {
        event.preventDefault();
        const input = document.getElementById('password-input-' + accountId);
        const password = input.value;
        if (password.length < 4) {
            showToast('Password must be at least 4 characters', 'error');
            return;
        }
        resetAccountPassword(accountId, password);
        input.value = '';
    }

    function toggleAddAccountForm() {
        const form = document.getElementById('add-account-form');
        if (form) {
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                const input = document.getElementById('new-account-username');
                if (input) input.focus();
            }
        }
    }

    function togglePasswordResetForm(accountId) {
        const formEl = document.getElementById('password-form-' + accountId);
        if (formEl) {
            const isHidden = formEl.style.display === 'none';
            formEl.style.display = isHidden ? 'flex' : 'none';
            if (isHidden) {
                const input = document.getElementById('password-input-' + accountId);
                if (input) input.focus();
            }
        }
    }

    function renderUserAccountsSection() {
        // Show warning if admin has default password
        let warningHtml = '';
        if (hasDefaultPassword) {
            warningHtml = '<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger, #ef4444); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;">' +
                '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--danger, #ef4444)" stroke-width="2" style="flex-shrink: 0;">' +
                '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>' +
                '<line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>' +
                '<div><strong style="color: var(--danger, #ef4444);">Security Warning</strong>' +
                '<p style="margin: 0.25rem 0 0; color: var(--text-secondary); font-size: 0.875rem;">The admin account is using the default password. Please change it immediately.</p></div></div>';
        }

        const accountsHtml = accountsData.map(account => {
            const isMaster = account.isMaster;
            const profileCount = (account.profiles || []).length;
            const initial = (account.username || 'A').charAt(0).toUpperCase();

            // Render profiles for this account
            const profilesListHtml = (account.profiles || []).map(profile => {
                const avatarColor = profile.color || '#3B82F6';
                const profileInitial = (profile.name || 'P').charAt(0).toUpperCase();

                // Account selector for reassignment
                const accountOptions = accountsData.map(a =>
                    '<option value="' + a.id + '"' + (a.id === account.id ? ' selected' : '') + '>' +
                    a.username + (a.isMaster ? ' (Master)' : '') + '</option>'
                ).join('');

                return '<div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: var(--bg-primary); border-radius: 6px;">' +
                    '<div style="width: 28px; height: 28px; border-radius: 50%; background: ' + avatarColor + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.75rem; flex-shrink: 0;">' + profileInitial + '</div>' +
                    '<span style="flex: 1; font-size: 0.875rem;">' + profile.name + '</span>' +
                    '<select class="form-select" style="width: 150px; padding: 0.25rem 0.5rem; font-size: 0.75rem;" onchange="reassignProfile(\'' + profile.id + '\', this.value)">' + accountOptions + '</select>' +
                    '</div>';
            }).join('');

            const profilesSection = profileCount > 0
                ? '<div style="margin-top: 0.75rem;"><div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">Profiles (' + profileCount + ')</div><div style="display: flex; flex-direction: column; gap: 0.5rem;">' + profilesListHtml + '</div></div>'
                : '<div style="margin-top: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">No profiles assigned</div>';

            const deleteBtn = !isMaster
                ? '<button class="btn btn-sm btn-icon btn-danger" onclick="deleteAccount(\'' + account.id + '\')" title="Delete account">' + icons.trash + '</button>'
                : '<button class="btn btn-sm btn-icon" disabled title="Cannot delete master account" style="opacity: 0.5; cursor: not-allowed;">' + icons.trash + '</button>';

            const masterBadge = isMaster ? '<span style="background: var(--accent); color: white; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 500; margin-left: 0.5rem;">Master</span>' : '';

            return '<div class="array-item">' +
                '<div class="array-item-header" style="flex-wrap: wrap; gap: 0.75rem;">' +
                '<div class="array-item-title" style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 200px;">' +
                '<div style="width: 40px; height: 40px; border-radius: 50%; background: ' + (isMaster ? 'var(--accent)' : '#6B7280') + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 1.125rem; flex-shrink: 0;">' + initial + '</div>' +
                '<div style="flex: 1;">' +
                '<div style="font-weight: 600;">' + account.username + masterBadge + '</div>' +
                '</div>' +
                '</div>' +
                '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                '<button class="btn btn-sm" onclick="togglePasswordResetForm(\'' + account.id + '\')" title="Reset password">' + icons.key + ' Reset Password</button>' +
                deleteBtn +
                '</div>' +
                '</div>' +
                '<div style="padding: 0 1rem 1rem;">' +
                '<form id="password-form-' + account.id + '" onsubmit="handleResetPasswordSubmit(event, \'' + account.id + '\')" style="display: none; gap: 0.5rem; align-items: center; margin-bottom: 0.75rem;">' +
                '<input type="password" id="password-input-' + account.id + '" class="form-input" placeholder="New password" style="width: 200px;">' +
                '<button type="submit" class="btn btn-sm btn-primary">Set</button>' +
                '<button type="button" class="btn btn-sm" onclick="togglePasswordResetForm(\'' + account.id + '\')">Cancel</button>' +
                '</form>' +
                profilesSection +
                '</div>' +
                '</div>';
        }).join('');

        const addButton = '<button class="btn btn-primary" onclick="toggleAddAccountForm()" style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">' +
            icons.plus + ' Add Account</button>';

        const addAccountForm = '<div id="add-account-form" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">' +
            '<form onsubmit="handleCreateAccountSubmit(event)">' +
            '<div style="margin-bottom: 1rem;">' +
            '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Username</label>' +
            '<input type="text" id="new-account-username" class="form-input" placeholder="Enter username" style="width: 100%;">' +
            '</div>' +
            '<div style="margin-bottom: 1rem;">' +
            '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Password</label>' +
            '<input type="password" id="new-account-password" class="form-input" placeholder="Enter password" style="width: 100%;">' +
            '</div>' +
            '<div style="display: flex; gap: 0.5rem;">' +
            '<button type="submit" class="btn btn-sm btn-primary">Create Account</button>' +
            '<button type="button" class="btn btn-sm" onclick="toggleAddAccountForm()">Cancel</button>' +
            '</div>' +
            '</form>' +
            '</div>';

        return warningHtml + '<div class="array-items">' + accountsHtml + '</div>' + addButton + addAccountForm;
    }

    async function setProfilePin(profileId, pin) {
        try {
            const response = await fetch(basePath + '/api/profiles/pin?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pin: pin })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('PIN set successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to set PIN', 'error');
            }
        } catch (e) {
            showToast('Error setting PIN: ' + e.message, 'error');
        }
    }

    async function clearProfilePin(profileId) {
        try {
            const response = await fetch(basePath + '/api/profiles/pin?profileId=' + encodeURIComponent(profileId), {
                method: 'DELETE'
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('PIN removed successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to remove PIN', 'error');
            }
        } catch (e) {
            showToast('Error removing PIN: ' + e.message, 'error');
        }
    }

    // Profile colors matching the mobile app
    const profileColors = [
        { name: 'Blue', value: '#3B82F6' },
        { name: 'Purple', value: '#8B5CF6' },
        { name: 'Pink', value: '#EC4899' },
        { name: 'Red', value: '#EF4444' },
        { name: 'Orange', value: '#F97316' },
        { name: 'Yellow', value: '#EAB308' },
        { name: 'Green', value: '#22C55E' },
        { name: 'Teal', value: '#14B8A6' },
    ];

    async function createProfile(name, color) {
        try {
            const response = await fetch(basePath + '/api/profiles', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name, color: color })
            });
            if (response.ok) {
                const created = await response.json();
                profilesData.push(created);
                showToast('Profile created successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to create profile', 'error');
            }
        } catch (e) {
            showToast('Error creating profile: ' + e.message, 'error');
        }
    }

    async function renameProfile(profileId, newName) {
        try {
            const response = await fetch(basePath + '/api/profiles?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('Profile renamed successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to rename profile', 'error');
            }
        } catch (e) {
            showToast('Error renaming profile: ' + e.message, 'error');
        }
    }

    async function deleteProfile(profileId) {
        if (!confirm('Delete this profile? This action cannot be undone.')) {
            return;
        }
        try {
            const response = await fetch(basePath + '/api/profiles?profileId=' + encodeURIComponent(profileId), {
                method: 'DELETE'
            });
            if (response.ok) {
                profilesData = profilesData.filter(p => p.id !== profileId);
                showToast('Profile deleted successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to delete profile', 'error');
            }
        } catch (e) {
            showToast('Error deleting profile: ' + e.message, 'error');
        }
    }

    async function setProfileColor(profileId, color) {
        try {
            const response = await fetch(basePath + '/api/profiles/color?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ color: color })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('Color updated');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to update color', 'error');
            }
        } catch (e) {
            showToast('Error updating color: ' + e.message, 'error');
        }
    }

    async function setKidsProfile(profileId, isKids) {
        try {
            const response = await fetch(basePath + '/api/profiles/kids?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ isKidsProfile: isKids })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast(isKids ? 'Kids profile enabled' : 'Kids profile disabled');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to update kids profile setting', 'error');
            }
        } catch (e) {
            showToast('Error updating kids profile: ' + e.message, 'error');
        }
    }

    function customizeKidsProfile(profileId) {
        // Placeholder for kids profile customization
        // This will be implemented later with content restrictions, etc.
        showToast('Kids profile customization coming soon!', 'info');
    }

    function handleCreateProfileSubmit(event) {
        event.preventDefault();
        const nameInput = document.getElementById('new-profile-name');
        const colorInput = document.querySelector('input[name="new-profile-color"]:checked');
        const name = nameInput.value.trim();
        if (!name) {
            showToast('Profile name is required', 'error');
            return;
        }
        const color = colorInput ? colorInput.value : profileColors[0].value;
        createProfile(name, color);
        nameInput.value = '';
    }

    function handleRenameProfileSubmit(event, profileId) {
        event.preventDefault();
        const input = document.getElementById('rename-input-' + profileId);
        const newName = input.value.trim();
        if (!newName) {
            showToast('Profile name is required', 'error');
            return;
        }
        renameProfile(profileId, newName);
    }

    function toggleRenameForm(profileId) {
        const formEl = document.getElementById('rename-form-' + profileId);
        const displayEl = document.getElementById('name-display-' + profileId);
        if (formEl && displayEl) {
            const isEditing = formEl.style.display !== 'none';
            formEl.style.display = isEditing ? 'none' : 'flex';
            displayEl.style.display = isEditing ? 'block' : 'none';
            if (!isEditing) {
                const input = document.getElementById('rename-input-' + profileId);
                if (input) input.focus();
            }
        }
    }

    function toggleAddProfileForm() {
        const form = document.getElementById('add-profile-form');
        if (form) {
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                const input = document.getElementById('new-profile-name');
                if (input) input.focus();
            }
        }
    }

    async function clearMetadataCache() {
        const btn = document.getElementById('clear-cache-btn');
        if (!btn) return;

        if (!confirm('Clear all cached metadata and posters? This will force fresh data to be fetched from TVDB/TMDB.')) {
            return;
        }

        const originalHtml = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Clearing...';

        try {
            const response = await fetch(basePath + '/api/cache/clear', {
                method: 'POST'
            });
            const result = await response.json();
            if (response.ok) {
                showToast('Metadata cache cleared successfully');
            } else {
                showToast(result.error || 'Failed to clear cache', 'error');
            }
        } catch (e) {
            showToast('Error clearing cache: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        }
    }

    function handlePinFormSubmit(event, profileId) {
        event.preventDefault();
        const input = document.getElementById('pin-input-' + profileId);
        const pin = input.value.trim();
        if (pin.length < 4) {
            showToast('PIN must be at least 4 characters', 'error');
            return;
        }
        setProfilePin(profileId, pin);
        input.value = '';
    }

    function renderProfilesSection() {
        const canDelete = profilesData.length > 1;

        // Render color picker dots
        function renderColorPicker(profileId, currentColor) {
            return '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">' +
                profileColors.map(c => {
                    const isSelected = c.value === currentColor;
                    const border = isSelected ? '2px solid white' : '2px solid transparent';
                    const boxShadow = isSelected ? '0 0 0 2px var(--accent)' : 'none';
                    return '<button type="button" onclick="setProfileColor(\'' + profileId + '\', \'' + c.value + '\')" ' +
                        'style="width: 24px; height: 24px; border-radius: 50%; background: ' + c.value + '; border: ' + border + '; box-shadow: ' + boxShadow + '; cursor: pointer; padding: 0;" ' +
                        'title="' + c.name + '"></button>';
                }).join('') +
                '</div>';
        }

        // Render the add profile form
        function renderAddProfileForm() {
            return '<div id="add-profile-form" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">' +
                '<form onsubmit="handleCreateProfileSubmit(event)">' +
                '<div style="margin-bottom: 1rem;">' +
                '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Profile Name</label>' +
                '<input type="text" id="new-profile-name" class="form-input" placeholder="Enter profile name" style="width: 100%;">' +
                '</div>' +
                '<div style="margin-bottom: 1rem;">' +
                '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Color</label>' +
                '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">' +
                profileColors.map((c, i) => {
                    const checked = i === 0 ? ' checked' : '';
                    return '<label style="cursor: pointer;">' +
                        '<input type="radio" name="new-profile-color" value="' + c.value + '"' + checked + ' style="display: none;">' +
                        '<span style="display: block; width: 32px; height: 32px; border-radius: 50%; background: ' + c.value + '; border: 2px solid transparent;" ' +
                        'class="color-option" title="' + c.name + '"></span>' +
                        '</label>';
                }).join('') +
                '</div>' +
                '</div>' +
                '<div style="display: flex; gap: 0.5rem;">' +
                '<button type="submit" class="btn btn-sm btn-primary">Create Profile</button>' +
                '<button type="button" class="btn btn-sm" onclick="toggleAddProfileForm()">Cancel</button>' +
                '</div>' +
                '</form>' +
                '</div>';
        }

        const profilesHtml = profilesData.map(profile => {
            const avatarColor = profile.color || '#3B82F6';
            const initial = (profile.name || 'U').charAt(0).toUpperCase();
            const pinStatus = profile.hasPin
                ? '<span style="display: inline-flex; align-items: center; gap: 0.25rem; color: var(--success); font-size: 0.875rem;">' + icons.lock + ' PIN Protected</span>'
                : '<span style="display: inline-flex; align-items: center; gap: 0.25rem; color: var(--text-secondary); font-size: 0.875rem;">' + icons.unlock + ' No PIN</span>';

            const pinActions = profile.hasPin
                ? '<button class="btn btn-sm btn-danger" onclick="if(confirm(\'Remove PIN from this profile?\')) clearProfilePin(\'' + profile.id + '\')">Remove PIN</button>'
                : '<form onsubmit="handlePinFormSubmit(event, \'' + profile.id + '\')" style="display: flex; gap: 0.5rem; align-items: center;">' +
                  '<input type="password" id="pin-input-' + profile.id + '" class="form-input" placeholder="Enter PIN" style="width: 120px;">' +
                  '<button type="submit" class="btn btn-sm btn-primary">Set PIN</button>' +
                  '</form>';

            const deleteBtn = canDelete
                ? '<button class="btn btn-sm btn-icon btn-danger" onclick="deleteProfile(\'' + profile.id + '\')" title="Delete profile">' + icons.trash + '</button>'
                : '<button class="btn btn-sm btn-icon" disabled title="Cannot delete last profile" style="opacity: 0.5; cursor: not-allowed;">' + icons.trash + '</button>';

            const kidsToggle = '<label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">' +
                '<input type="checkbox" ' + (profile.isKidsProfile ? 'checked' : '') + ' onchange="setKidsProfile(\'' + profile.id + '\', this.checked)" style="width: 16px; height: 16px;">' +
                '<span style="font-size: 0.875rem;">This is a kids profile</span>' +
                '</label>';

            const kidsCustomizeBtn = profile.isKidsProfile
                ? '<button class="btn btn-sm btn-primary" onclick="customizeKidsProfile(\'' + profile.id + '\')" style="margin-top: 0.5rem;">Customize Kids Settings</button>'
                : '';

            return '<div class="array-item">' +
                '<div class="array-item-header profile-header" style="flex-wrap: wrap; gap: 0.75rem;">' +
                '<div class="array-item-title" style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 200px;">' +
                '<div style="width: 40px; height: 40px; border-radius: 50%; background: ' + avatarColor + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 1.125rem; flex-shrink: 0;">' + initial + '</div>' +
                '<div style="flex: 1;">' +
                '<div id="name-display-' + profile.id + '" style="font-weight: 600;">' + profile.name + (profile.isKidsProfile ? ' <span style="background: var(--accent); color: white; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 500;">Kids</span>' : '') + '</div>' +
                '<form id="rename-form-' + profile.id + '" onsubmit="handleRenameProfileSubmit(event, \'' + profile.id + '\')" style="display: none; gap: 0.5rem; align-items: center;">' +
                '<input type="text" id="rename-input-' + profile.id + '" class="form-input" value="' + profile.name + '" style="width: 150px; padding: 0.25rem 0.5rem;">' +
                '<button type="submit" class="btn btn-sm btn-icon btn-primary" title="Save">' + icons.check + '</button>' +
                '<button type="button" class="btn btn-sm btn-icon" onclick="toggleRenameForm(\'' + profile.id + '\')" title="Cancel">' + icons.x + '</button>' +
                '</form>' +
                '<div style="font-size: 0.75rem; color: var(--text-secondary);">ID: ' + profile.id + '</div>' +
                '</div>' +
                '</div>' +
                '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                '<button class="btn btn-sm btn-icon" onclick="toggleRenameForm(\'' + profile.id + '\')" title="Rename profile">' + icons.edit + '</button>' +
                deleteBtn +
                '</div>' +
                '</div>' +
                '<div style="padding: 0 1rem 1rem; display: grid; gap: 1rem;">' +
                '<div>' +
                '<div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">Color</div>' +
                renderColorPicker(profile.id, avatarColor) +
                '</div>' +
                '<div>' +
                '<div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">PIN Protection</div>' +
                '<div style="margin-bottom: 0.5rem;">' + pinStatus + '</div>' +
                '<div>' + pinActions + '</div>' +
                '</div>' +
                '<div>' +
                '<div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">Kids Profile</div>' +
                '<div>' + kidsToggle + kidsCustomizeBtn + '</div>' +
                '</div>' +
                '</div>' +
                '</div>';
        }).join('');

        const addButton = '<button class="btn btn-primary" onclick="toggleAddProfileForm()" style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">' +
            icons.plus + ' Add Profile</button>';

        return '<div class="array-items">' + profilesHtml + '</div>' + addButton + renderAddProfileForm();
    }

    function renderSettings() {
        const container = document.getElementById('settingsContainer');

        // Run validation before rendering
        validationErrors = validateSettings();

        // Save currently open sections before re-rendering
        const openSections = new Set();
        container.querySelectorAll('.section.open').forEach(section => {
            const id = section.id.replace('section-', '');
            if (id) openSections.add(id);
        });

        // Add info banner when user or client is selected
        let bannerHtml = '';
        if (selectedClientId) {
            const client = clientsForUser.find(c => c.id === selectedClientId);
            const clientName = client ? client.name : selectedClientId;
            bannerHtml = '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;"><div style="display: flex; align-items: center; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#8b5cf6" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg><span>Editing device-specific settings for <strong>' + clientName + '</strong></span></div><p style="margin: 0.5rem 0 0; font-size: 0.8rem; color: var(--text-muted);">Fields show <span class="inheritance-badge overridden" style="font-size: 0.6rem;">Device</span> when overridden here, or <span class="inheritance-badge inherited" style="font-size: 0.6rem;">From Profile</span> / <span class="inheritance-badge inherited" style="font-size: 0.6rem;">From Global</span> when inherited. Click ↩ to reset an override.</p></div>';
        } else if (selectedUserId) {
            bannerHtml = '<div style="background: var(--accent-bg, #2563eb20); border: 1px solid var(--accent, #2563eb); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;"><div style="display: flex; align-items: center; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--accent, #2563eb)" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg><span>Editing profile-specific settings</span></div><p style="margin: 0.5rem 0 0; font-size: 0.8rem; color: var(--text-muted);">Fields show <span class="inheritance-badge overridden" style="font-size: 0.6rem;">Profile</span> when overridden here, or <span class="inheritance-badge inherited" style="font-size: 0.6rem;">From Global</span> when using the default. Click ↩ to reset an override.</p></div>';
        }

        // Add validation warning banner if there are issues
        const totalErrors = Object.keys(validationErrors).length;
        if (totalErrors > 0 && !selectedUserId) {
            const errorSections = Object.keys(validationErrors).map(key => {
                const sectionDef = schema[key];
                return sectionDef?.label || key;
            }).join(', ');
            bannerHtml += '<div style="background: rgba(234, 179, 8, 0.1); border: 1px solid var(--warning, #eab308); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--warning, #eab308)" stroke-width="2" style="flex-shrink: 0; margin-top: 2px;"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><div><strong style="color: var(--warning, #eab308);">Configuration warning</strong><p style="margin: 0.25rem 0 0; color: var(--text-secondary); font-size: 0.875rem;">Some recommended settings may be incomplete. Issues found in: '+errorSections+'</p></div></div>';
        }

        // Render sections grouped by their group property
        // Sections with their own group are shown at top level, even if they have a parent (for data access)
        let html = bannerHtml;

        // Sections that can be configured per-client (subset of perUserSections)
        const clientSections = ['filtering'];

        for (const group of groups) {
            const groupSections = Object.entries(schema).filter(([key, def]) => {
                if (def.group !== group.id) return false;
                // If a client is selected, only show client-configurable sections
                if (selectedClientId && !clientSections.includes(key)) return false;
                // If a user is selected (but not client), show per-user sections
                if (selectedUserId && !selectedClientId && !perUserSections.includes(key)) return false;
                return true;
            }).sort((a, b) => (a[1].order ?? 999) - (b[1].order ?? 999));

            if (groupSections.length === 0) continue;

            html += '<div class="settings-group"><h2 class="group-title">'+group.label+'</h2><div class="group-sections">'+groupSections.map(([key, def]) => renderSection(key, def)).join('')+'</div></div>';
        }

        container.innerHTML = html;

        // Restore previously open sections
        openSections.forEach(sectionKey => {
            const section = document.getElementById('section-'+sectionKey);
            if (section) section.classList.add('open');
        });

        if (window.location.hash) {
            const section = document.getElementById('section-'+window.location.hash.substring(1));
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    }
    async function saveAllSettings() {
        try {
            if (selectedClientId && clientSettings !== null) {
                // Save client-specific settings
                const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(selectedClientId) + '/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(clientSettings)
                });
                if (response.ok) {
                    originalClientSettings = JSON.parse(JSON.stringify(clientSettings));
                    showToast('Client settings saved successfully');
                    // Update client override indicator
                    const hasOverrides = Object.keys(clientSettings).some(k => clientSettings[k] !== undefined && clientSettings[k] !== null);
                    const clientInList = clientsForUser.find(c => c.id === selectedClientId);
                    if (clientInList) clientInList.hasOverrides = hasOverrides;
                    updateClientDropdownIndicators();
                    updateRevertButtonVisibility();
                } else {
                    const result = await response.json().catch(() => ({}));
                    showToast(result.error || 'Failed to save client settings', 'error');
                }
            } else if (selectedUserId && userSettings) {
                // Save user-specific settings
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(userSettings)
                });
                if (response.ok) {
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                    showToast('User settings saved successfully');
                    // Update user override indicator (settings were saved, so they have overrides now)
                    if (userOverrides) userOverrides[selectedUserId] = true;
                    updateUserDropdownIndicators();
                    updateClientDropdownIndicators(); // Update "Profile Defaults" indicator
                    updateRevertButtonVisibility();
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save user settings', 'error');
                }
            } else {
                // Save global settings
                const response = await fetch(basePath + '/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    showToast('Settings saved successfully');
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                }
            }
        } catch (e) { showToast('Failed to save settings: ' + e.message, 'error'); }
    }
    function resetSettings() {
        if (confirm('Reset all changes? This will revert to the last saved settings.')) {
            if (selectedClientId && originalClientSettings !== null) {
                clientSettings = JSON.parse(JSON.stringify(originalClientSettings));
            } else if (selectedUserId && originalUserSettings) {
                userSettings = JSON.parse(JSON.stringify(originalUserSettings));
            } else {
                currentSettings = JSON.parse(JSON.stringify(originalSettings));
            }
            renderSettings();
            showToast('Settings reset to last saved state');
        }
    }
    document.addEventListener('DOMContentLoaded', async () => {
        if (isAdmin) {
            await Promise.all([loadProfiles(), loadAccounts(), checkDefaultPassword()]);
            // Check if browser restored a selected user (form state restoration)
            const selector = document.getElementById('userSelector');
            if (selector && selector.value) {
                await handleUserChange(selector.value);
                return; // handleUserChange will call renderSettings
            }
            // Recalculate all user overrides on initial load (compare actual values to global)
            // This fixes the indicator showing for profiles with saved settings that match global
            await recalculateAllUserOverrides();
        } else {
            await loadProfiles();
            // For non-admin, auto-select the first profile
            const selector = document.getElementById('userSelector');
            if (selector && selector.options.length > 0) {
                selectedUserId = selector.options[0].value;
                selector.value = selectedUserId;
                await handleUserChange(selectedUserId);
                return; // handleUserChange will call renderSettings
            }
        }
        renderSettings();
    });
    window.addEventListener('hashchange', () => {
        const hash = window.location.hash.substring(1);
        if (hash) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('open'));
            const section = document.getElementById('section-'+hash);
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    });
</script>
{{end}}
{{end}}
