{{template "base" .}}

{{define "title"}}Settings - {{if .IsAdmin}}strmr Admin{{else}}strmr account{{end}}{{end}}

{{define "content"}}
{{if .NoProfiles}}
<div class="page-header">
    <h1>Settings</h1>
    <p>Configure profile settings</p>
</div>
<div class="card" style="margin-top: 2rem;">
    <div class="card-body" style="text-align: center; padding: 3rem;">
        <svg viewBox="0 0 24 24" width="64" height="64" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 1rem; opacity: 0.5;">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
            <circle cx="12" cy="7" r="4"/>
        </svg>
        <h2 style="margin-bottom: 0.5rem;">No Profiles</h2>
        <p style="color: var(--text-muted); margin-bottom: 1.5rem;">You don't have any profiles associated with your account yet. Create a profile to view this page.</p>
    </div>
</div>
{{else}}
<div class="page-header page-header-flex" style="display: flex; align-items: center; justify-content: space-between;">
    <div>
        <h1>Settings</h1>
        <p>{{if .IsAdmin}}Configure your strmr server{{else}}Configure profile settings{{end}}</p>
    </div>
    <div class="page-header-controls" style="display: flex; gap: 0.5rem; align-items: center;">
        <select id="userSelector" class="form-select" style="min-width: 180px;" onchange="handleUserChange(this.value)">
            {{if .IsAdmin}}<option value="">Global Defaults</option>{{end}}
            {{range .Users}}
            <option value="{{.ID}}" data-has-overrides="{{if index $.UserOverrides .ID}}true{{else}}false{{end}}">{{.Name}}{{if index $.UserOverrides .ID}} ●{{end}}</option>
            {{end}}
        </select>
        <select id="clientSelector" class="form-select" style="min-width: 180px; display: none;" onchange="handleClientChange(this.value)">
            <option value="">Profile Defaults</option>
        </select>
        <button id="identifyClientBtn" class="btn btn-secondary" style="display: none;" onclick="identifyClient()" title="Send ping to identify this device">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            Identify
        </button>
        <button id="revertBtn" class="btn btn-secondary" style="display: none;" onclick="revertToGlobal()" title="Reset all settings to inherit from parent defaults">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
            </svg>
            Revert
        </button>
        <button id="propagateBtn" class="btn btn-secondary" style="display: none;" onclick="propagateSettings()" title="Propagate settings to children">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14"/>
                <path d="M19 12l-7 7-7-7"/>
            </svg>
            Propagate
        </button>
        <button class="btn btn-primary" onclick="saveAllSettings()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save
        </button>
    </div>
</div>

<div id="settingsContainer">
    <div style="display: flex; align-items: center; justify-content: center; padding: 2rem;">
        <div class="spinner"></div>
    </div>
</div>
{{end}}
{{end}}

{{define "scripts"}}
{{if not .NoProfiles}}
<script>
    let currentSettings = {{json .Settings}};
    let schema = {{json .Schema}};
    let groups = {{json .Groups}};
    let originalSettings = JSON.parse(JSON.stringify(currentSettings));
    let selectedUserId = '';
    let userSettings = null;
    let originalUserSettings = null;
    let selectedClientId = '';
    let clientSettings = null;
    let originalClientSettings = null;
    let clientsForUser = []; // Clients for the selected user
    let profilesData = []; // Profiles with PIN status
    let accountsData = []; // User accounts with profiles
    let hasDefaultPassword = false; // Whether admin has default password
    let userOverrides = {{json .UserOverrides}}; // Map of userId -> hasOverrides
    const isAdmin = {{json .IsAdmin}};
    const basePath = {{json .BasePath}};

    // Sections that are per-user (when a user is selected, only show these)
    // Note: liveTV settings (favorites, hidden channels) are managed in-app, not via this UI
    const perUserSections = ['playback', 'homeShelves', 'homeShelves.shelves', 'filtering', 'liveTV', 'display', 'network'];

    // Validation state - stores errors by section and field
    let validationErrors = {};

    // Check if a value is empty/missing
    function isEmpty(val) {
        if (val === undefined || val === null) return true;
        if (typeof val === 'string') return val.trim() === '';
        if (typeof val === 'number') return false; // 0 is valid for numbers
        if (Array.isArray(val)) return val.length === 0;
        return false;
    }

    // Check if an array has at least one enabled item
    function hasEnabledItem(arr) {
        if (!Array.isArray(arr)) return false;
        return arr.some(item => item.enabled === true);
    }

    // Validate all settings and return errors object
    function validateSettings() {
        const errors = {};

        // Skip validation for user-specific settings or non-admin users
        if (selectedUserId || !isAdmin) return errors;

        const serviceMode = currentSettings.streaming?.serviceMode || 'debrid';
        const needsDebrid = serviceMode === 'debrid' || serviceMode === 'hybrid';
        const needsUsenet = serviceMode === 'usenet' || serviceMode === 'hybrid';

        // Server Settings - all required
        const serverErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.server?.host)) serverErrors.fields.host = 'Host is required';
        if (isEmpty(currentSettings.server?.port) && currentSettings.server?.port !== 0) serverErrors.fields.port = 'Port is required';
        if (Object.keys(serverErrors.fields).length > 0) errors.server = serverErrors;

        // Streaming - all required
        const streamingErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.streaming?.serviceMode)) streamingErrors.fields.serviceMode = 'Service mode is required';
        if (Object.keys(streamingErrors.fields).length > 0) errors.streaming = streamingErrors;

        // Debrid Providers - at least one enabled if debrid/hybrid mode
        if (needsDebrid) {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                errors.debridProviders = {
                    fields: {},
                    messages: ['At least one enabled debrid provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Usenet Providers - at least one enabled if usenet/hybrid mode
        if (needsUsenet) {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                errors.usenet = {
                    fields: {},
                    messages: ['At least one enabled usenet provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Streaming - if service priority selected, must have enabled provider of that type
        const servicePriority = currentSettings.streaming?.servicePriority;
        if (servicePriority === 'usenet') {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                if (!errors.streaming) errors.streaming = { fields: {}, messages: [] };
                errors.streaming.fields.servicePriority = 'Usenet priority requires an enabled usenet provider';
            }
        } else if (servicePriority === 'debrid') {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                if (!errors.streaming) errors.streaming = { fields: {}, messages: [] };
                errors.streaming.fields.servicePriority = 'Debrid priority requires an enabled debrid provider';
            }
        }

        // Indexers - required if usenet/hybrid mode
        if (needsUsenet) {
            const indexers = currentSettings.indexers || [];
            if (!hasEnabledItem(indexers)) {
                errors.indexers = {
                    fields: {},
                    messages: ['At least one enabled indexer is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Torrent Scrapers - required if debrid/hybrid mode
        if (needsDebrid) {
            const scrapers = currentSettings.torrentScrapers || [];
            if (!hasEnabledItem(scrapers)) {
                errors.torrentScrapers = {
                    fields: {},
                    messages: ['At least one enabled scraper is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Metadata - all required
        const metadataErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.metadata?.tvdbApiKey)) metadataErrors.fields.tvdbApiKey = 'TVDB API Key is required';
        if (isEmpty(currentSettings.metadata?.tmdbApiKey)) metadataErrors.fields.tmdbApiKey = 'TMDB API Key is required';
        if (Object.keys(metadataErrors.fields).length > 0) errors.metadata = metadataErrors;

        // Cache - all required
        const cacheErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.cache?.directory)) cacheErrors.fields.directory = 'Cache directory is required';
        if (Object.keys(cacheErrors.fields).length > 0) errors.cache = cacheErrors;

        // Import Settings - all required (numbers can be 0, so just check existence)
        const importErrors = { fields: {}, messages: [] };
        if (currentSettings.import?.rarMaxWorkers === undefined) importErrors.fields.rarMaxWorkers = 'RAR Max Workers is required';
        if (currentSettings.import?.rarMaxCacheSizeMb === undefined) importErrors.fields.rarMaxCacheSizeMb = 'RAR Cache Size is required';
        if (currentSettings.import?.rarMaxMemoryGB === undefined) importErrors.fields.rarMaxMemoryGB = 'RAR Max Memory is required';
        if (Object.keys(importErrors.fields).length > 0) errors.import = importErrors;

        return errors;
    }

    // Get error count for a section
    function getSectionErrorCount(sectionKey) {
        const sectionErrors = validationErrors[sectionKey];
        if (!sectionErrors) return 0;
        const fieldCount = Object.keys(sectionErrors.fields || {}).length;
        const msgCount = (sectionErrors.messages || []).length;
        return fieldCount + msgCount;
    }

    // Check if a specific field has an error
    function getFieldError(sectionKey, fieldKey) {
        return validationErrors[sectionKey]?.fields?.[fieldKey] || null;
    }

    async function handleUserChange(userId) {
        selectedUserId = userId;
        // Clear client selection when user changes
        selectedClientId = '';
        clientSettings = null;
        originalClientSettings = null;
        clientsForUser = [];

        const clientSelector = document.getElementById('clientSelector');
        const identifyBtn = document.getElementById('identifyClientBtn');

        // Always hide identify button when user changes (no client selected yet)
        if (identifyBtn) identifyBtn.style.display = 'none';

        if (userId) {
            // Load user-specific settings
            try {
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(userId));
                if (response.ok) {
                    userSettings = await response.json();
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                } else {
                    showToast('Failed to load user settings', 'error');
                    userSettings = null;
                    originalUserSettings = null;
                }
            } catch (e) {
                showToast('Failed to load user settings: ' + e.message, 'error');
                userSettings = null;
                originalUserSettings = null;
            }

            // Load clients for this user
            await loadClientsForUser(userId);

            // Recalculate whether profile has actual overrides (compare values, not just record existence)
            recalculateUserOverrides(userId);
            updateUserDropdownIndicators();

            // Show client selector if there are clients
            if (clientsForUser.length > 0) {
                const profileHasOverrides = userOverrides && userOverrides[userId];
                clientSelector.innerHTML = `<option value="">Profile Defaults${profileHasOverrides ? ' ●' : ''}</option>` +
                    clientsForUser.map(c => `<option value="${c.id}">${c.name}${c.hasOverrides ? ' ●' : ''}</option>`).join('');
                clientSelector.style.display = 'block';
            } else {
                clientSelector.style.display = 'none';
            }
        } else {
            userSettings = null;
            originalUserSettings = null;
            clientSelector.style.display = 'none';
        }
        renderSettings();
        updateRevertButtonVisibility();
    }

    async function loadClientsForUser(userId) {
        try {
            const response = await fetch(basePath + '/api/clients?userId=' + encodeURIComponent(userId), {
                credentials: 'same-origin'
            });
            if (response.ok) {
                clientsForUser = await response.json() || [];
                // Recalculate hasOverrides for each client by loading their settings
                await recalculateAllClientOverrides();
            } else {
                clientsForUser = [];
            }
        } catch (e) {
            console.warn('Failed to load clients:', e);
            clientsForUser = [];
        }
    }

    // Recalculate hasOverrides for all clients in the list
    async function recalculateAllClientOverrides() {
        for (const client of clientsForUser) {
            try {
                const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(client.id) + '/settings', {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const settings = await response.json();
                    // Check if any client fields have actual values that differ from inherited
                    let hasActualOverrides = false;

                    // Check filtering fields
                    for (const key of clientFilterFields) {
                        const clientVal = settings[key];
                        // Skip if value is empty/null (means "inherit")
                        if (normalizeForComparison(clientVal) === null) continue;

                        // Get the effective inherited value
                        const globalVal = currentSettings.filtering ? currentSettings.filtering[key] : undefined;
                        let inheritedVal;

                        if (selectedUserId && userSettings && userSettings.filtering) {
                            const profileVal = userSettings.filtering[key];
                            if (profileVal !== undefined && profileVal !== null &&
                                !deepEqual(normalizeForComparison(profileVal), normalizeForComparison(globalVal))) {
                                inheritedVal = profileVal;
                            } else {
                                inheritedVal = globalVal;
                            }
                        } else {
                            inheritedVal = globalVal;
                        }

                        if (!deepEqual(normalizeForComparison(clientVal), normalizeForComparison(inheritedVal))) {
                            hasActualOverrides = true;
                            break;
                        }
                    }

                    // Check network fields (simpler - just check if set and non-empty)
                    if (!hasActualOverrides) {
                        for (const key of clientNetworkFields) {
                            const clientVal = settings[key];
                            if (clientVal !== undefined && clientVal !== null && clientVal !== '') {
                                hasActualOverrides = true;
                                break;
                            }
                        }
                    }
                    client.hasOverrides = hasActualOverrides;
                }
            } catch (e) {
                console.warn('Failed to load settings for client', client.id, e);
            }
        }
    }

    // Recalculate hasOverrides for all users on page load
    // This compares actual values to global defaults, not just record existence
    async function recalculateAllUserOverrides() {
        if (!userOverrides) return;

        const userIds = Object.keys(userOverrides).filter(id => userOverrides[id]);
        for (const userId of userIds) {
            try {
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(userId), {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const settings = await response.json();
                    if (!settings || Object.keys(settings).length === 0) {
                        userOverrides[userId] = false;
                        continue;
                    }

                    // Check all per-user sections for any actual differences
                    let hasActualOverrides = false;

                    // Check filtering section
                    if (settings.filtering) {
                        const globalFiltering = currentSettings.filtering || {};
                        for (const key of Object.keys(settings.filtering)) {
                            const profileVal = normalizeForComparison(settings.filtering[key]);
                            // If profile value is null (empty/inherit), skip - not an override
                            if (profileVal === null) continue;
                            const globalVal = normalizeForComparison(globalFiltering[key]);
                            if (!deepEqual(profileVal, globalVal)) {
                                hasActualOverrides = true;
                                break;
                            }
                        }
                    }

                    // Check playback section
                    if (!hasActualOverrides && settings.playback) {
                        const globalPlayback = currentSettings.playback || {};
                        for (const key of Object.keys(settings.playback)) {
                            const profileVal = normalizeForComparison(settings.playback[key]);
                            // If profile value is null (empty/inherit), skip - not an override
                            if (profileVal === null) continue;
                            const globalVal = normalizeForComparison(globalPlayback[key]);
                            if (!deepEqual(profileVal, globalVal)) {
                                hasActualOverrides = true;
                                break;
                            }
                        }
                    }

                    // Check homeShelves section - use lenient comparison for shelves
                    if (!hasActualOverrides && settings.homeShelves) {
                        const globalHomeShelves = currentSettings.homeShelves || {};
                        if (!homeShelvesEqual(settings.homeShelves, globalHomeShelves)) {
                            hasActualOverrides = true;
                        }
                    }

                    userOverrides[userId] = hasActualOverrides;
                } else {
                    userOverrides[userId] = false;
                }
            } catch (e) {
                console.warn('Failed to load settings for user', userId, e);
            }
        }
        updateUserDropdownIndicators();
    }

    async function handleClientChange(clientId) {
        selectedClientId = clientId;
        const identifyBtn = document.getElementById('identifyClientBtn');
        if (clientId) {
            // Load client-specific settings
            try {
                const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(clientId) + '/settings', {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    clientSettings = await response.json();
                    originalClientSettings = JSON.parse(JSON.stringify(clientSettings));
                } else {
                    clientSettings = {};
                    originalClientSettings = {};
                }
            } catch (e) {
                console.warn('Failed to load client settings:', e);
                clientSettings = {};
                originalClientSettings = {};
            }
            // Recalculate whether client has actual overrides (compare values, not just record existence)
            recalculateClientOverrides(clientId);
            updateClientDropdownIndicators();
            // Show identify button when a client is selected
            if (identifyBtn) identifyBtn.style.display = 'inline-flex';
        } else {
            clientSettings = null;
            originalClientSettings = null;
            // Hide identify button when no client selected
            if (identifyBtn) identifyBtn.style.display = 'none';
        }
        renderSettings();
        updateRevertButtonVisibility();
    }

    async function identifyClient() {
        if (!selectedClientId) return;
        const btn = document.getElementById('identifyClientBtn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Sending...';
        try {
            const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(selectedClientId) + '/ping', {
                method: 'POST',
                credentials: 'same-origin'
            });
            if (response.ok) {
                showToast('Ping sent! If the device is on the settings page, it will flash.');
            } else {
                showToast('Failed to send ping', 'error');
            }
        } catch (e) {
            showToast('Failed to send ping: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }

    // Update revert button visibility based on selection and overrides
    function updateRevertButtonVisibility() {
        const revertBtn = document.getElementById('revertBtn');
        const propagateBtn = document.getElementById('propagateBtn');

        let showRevert = false;
        let hasOverrides = false;

        if (selectedClientId && clientSettings) {
            // Check if client has any overrides
            hasOverrides = Object.keys(clientSettings).some(k => clientSettings[k] !== undefined && clientSettings[k] !== null);
            showRevert = hasOverrides;
        } else if (selectedUserId) {
            // Check if user/profile has overrides
            hasOverrides = userOverrides && userOverrides[selectedUserId];
            showRevert = hasOverrides;
        }

        if (revertBtn) {
            revertBtn.style.display = showRevert ? 'inline-flex' : 'none';
            revertBtn.title = selectedClientId
                ? 'Reset all device settings to profile defaults'
                : 'Reset all profile settings to global defaults';
        }

        // Propagate button: show at global level or profile level (not client level)
        // Only show for admin users
        if (propagateBtn && isAdmin) {
            let showPropagate = false;
            if (!selectedClientId) {
                // At global level (no user selected) or profile level (user selected)
                // Show propagate if there are profiles/clients to propagate to
                if (!selectedUserId) {
                    // Global level - always show if there are users
                    showPropagate = true;
                } else {
                    // Profile level - show if there are clients for this user
                    showPropagate = clientsForUser.length > 0;
                }
            }
            propagateBtn.style.display = showPropagate ? 'inline-flex' : 'none';
            propagateBtn.title = selectedUserId
                ? 'Propagate profile settings to all devices'
                : 'Propagate global settings to all profiles and devices';
        }
    }

    // Revert all settings to parent defaults (global for profile, profile for client)
    async function revertToGlobal() {
        const isClient = !!selectedClientId;
        const target = isClient ? 'device' : 'profile';
        const parentName = isClient ? 'profile' : 'global';

        if (!confirm(`Are you sure you want to reset all ${target} settings to ${parentName} defaults? This cannot be undone.`)) {
            return;
        }

        const btn = document.getElementById('revertBtn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Resetting...';

        try {
            let response;
            if (isClient) {
                // Reset client settings
                response = await fetch(basePath + '/api/clients/' + encodeURIComponent(selectedClientId) + '/settings', {
                    method: 'DELETE',
                    credentials: 'same-origin'
                });
            } else {
                // Reset user/profile settings
                response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'DELETE',
                    credentials: 'same-origin'
                });
            }

            if (response.ok) {
                showToast(`${isClient ? 'Device' : 'Profile'} settings reset to ${parentName} defaults`);

                // Update local state
                if (isClient) {
                    clientSettings = {};
                    originalClientSettings = {};
                    // Update client in the list
                    const clientInList = clientsForUser.find(c => c.id === selectedClientId);
                    if (clientInList) clientInList.hasOverrides = false;
                    updateClientDropdownIndicators();
                } else {
                    userSettings = null;
                    originalUserSettings = null;
                    // Update user overrides tracking
                    if (userOverrides) userOverrides[selectedUserId] = false;
                    updateUserDropdownIndicators();
                    updateClientDropdownIndicators(); // Update "Profile Defaults" indicator
                }

                updateRevertButtonVisibility();
                renderSettings();
            } else {
                const err = await response.text();
                showToast('Failed to reset settings: ' + err, 'error');
            }
        } catch (e) {
            showToast('Failed to reset settings: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }

    // Propagate settings from global to all profiles+clients, or from profile to its clients
    async function propagateSettings() {
        const isProfileLevel = !!selectedUserId;
        const targetDesc = isProfileLevel
            ? 'all devices for this profile'
            : 'all profiles and their devices';

        if (!confirm(`Are you sure you want to propagate current settings to ${targetDesc}? This will overwrite their filter settings.`)) {
            return;
        }

        const btn = document.getElementById('propagateBtn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Propagating...';

        try {
            let url = basePath + '/api/settings/propagate';
            if (isProfileLevel) {
                url += '?userId=' + encodeURIComponent(selectedUserId);
            }

            const response = await fetch(url, {
                method: 'POST',
                credentials: 'same-origin'
            });

            if (response.ok) {
                const result = await response.json();
                showToast(result.message || 'Settings propagated successfully');

                // Refresh the view to show updated states
                if (isProfileLevel) {
                    // Reload clients for this user
                    await loadClientsForUser(selectedUserId);
                    updateClientDropdownIndicators();
                } else {
                    // At global level, all profiles now have overrides
                    // Mark all users as having overrides
                    const userSelector = document.getElementById('userSelector');
                    if (userSelector) {
                        Array.from(userSelector.options).forEach(option => {
                            if (option.value) {
                                userOverrides[option.value] = true;
                            }
                        });
                    }
                    updateUserDropdownIndicators();
                }

                updateRevertButtonVisibility();
            } else {
                const err = await response.text();
                showToast('Failed to propagate settings: ' + err, 'error');
            }
        } catch (e) {
            showToast('Failed to propagate settings: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }

    // Update the user dropdown to show/hide override indicators
    function updateUserDropdownIndicators() {
        const userSelector = document.getElementById('userSelector');
        if (!userSelector) return;

        Array.from(userSelector.options).forEach(option => {
            if (!option.value) return; // Skip "Global Defaults" option
            const hasOverride = userOverrides && userOverrides[option.value];
            const currentText = option.text.replace(/ ●$/, ''); // Remove existing indicator
            option.text = hasOverride ? currentText + ' ●' : currentText;
            option.dataset.hasOverrides = hasOverride ? 'true' : 'false';
        });
    }

    // Update the client dropdown to show/hide override indicators
    function updateClientDropdownIndicators() {
        const clientSelector = document.getElementById('clientSelector');
        if (!clientSelector) return;

        // Update "Profile Defaults" option
        const profileDefaultsOption = clientSelector.querySelector('option[value=""]');
        if (profileDefaultsOption && selectedUserId) {
            const profileHasOverrides = userOverrides && userOverrides[selectedUserId];
            profileDefaultsOption.text = profileHasOverrides ? 'Profile Defaults ●' : 'Profile Defaults';
        }

        // Update individual client options
        clientsForUser.forEach(client => {
            const option = clientSelector.querySelector(`option[value="${client.id}"]`);
            if (option) {
                const currentText = option.text.replace(/ ●$/, '');
                option.text = client.hasOverrides ? currentText + ' ●' : currentText;
            }
        });
    }

    // Check if user settings have any actual differences from global settings
    // This recalculates userOverrides based on actual value comparison, not just record existence
    function recalculateUserOverrides(userId) {
        if (!userId || !userSettings) {
            if (userOverrides) userOverrides[userId] = false;
            return;
        }

        // Check all per-user sections for any actual differences
        let hasActualOverrides = false;

        // Check filtering section
        if (userSettings.filtering) {
            const globalFiltering = currentSettings.filtering || {};
            for (const key of Object.keys(userSettings.filtering)) {
                const profileVal = normalizeForComparison(userSettings.filtering[key]);
                // If profile value is null (empty/inherit), skip - not an override
                if (profileVal === null) continue;
                const globalVal = normalizeForComparison(globalFiltering[key]);
                if (!deepEqual(profileVal, globalVal)) {
                    hasActualOverrides = true;
                    break;
                }
            }
        }

        // Check playback section
        if (!hasActualOverrides && userSettings.playback) {
            const globalPlayback = currentSettings.playback || {};
            for (const key of Object.keys(userSettings.playback)) {
                const profileVal = normalizeForComparison(userSettings.playback[key]);
                // If profile value is null (empty/inherit), skip - not an override
                if (profileVal === null) continue;
                const globalVal = normalizeForComparison(globalPlayback[key]);
                if (!deepEqual(profileVal, globalVal)) {
                    hasActualOverrides = true;
                    break;
                }
            }
        }

        // Check homeShelves section - use lenient comparison for shelves
        if (!hasActualOverrides && userSettings.homeShelves) {
            const globalHomeShelves = currentSettings.homeShelves || {};
            if (!homeShelvesEqual(userSettings.homeShelves, globalHomeShelves)) {
                hasActualOverrides = true;
            }
        }

        if (userOverrides) userOverrides[userId] = hasActualOverrides;
    }

    // Recalculate whether a client has actual overrides (compare to profile/global values)
    function recalculateClientOverrides(clientId) {
        const client = clientsForUser.find(c => c.id === clientId);
        if (!client || !clientSettings) {
            if (client) client.hasOverrides = false;
            return;
        }

        // Check if any client fields have actual values that differ from inherited
        let hasActualOverrides = false;

        // Check filtering fields
        for (const key of clientFilterFields) {
            const clientVal = clientSettings[key];
            // Skip if value is empty/null (means "inherit")
            if (normalizeForComparison(clientVal) === null) continue;

            // Get the effective inherited value using the same logic as getInheritedValue
            // First check if profile has a value that differs from global
            let inheritedVal;
            const globalVal = currentSettings.filtering ? currentSettings.filtering[key] : undefined;

            if (selectedUserId && userSettings && userSettings.filtering) {
                const profileVal = userSettings.filtering[key];
                // Use profile value if it's set AND differs from global
                if (profileVal !== undefined && profileVal !== null &&
                    !deepEqual(normalizeForComparison(profileVal), normalizeForComparison(globalVal))) {
                    inheritedVal = profileVal;
                } else {
                    inheritedVal = globalVal;
                }
            } else {
                inheritedVal = globalVal;
            }

            if (!deepEqual(normalizeForComparison(clientVal), normalizeForComparison(inheritedVal))) {
                hasActualOverrides = true;
                break;
            }
        }

        // Check network fields (simpler - just check if set and non-empty)
        if (!hasActualOverrides) {
            for (const key of clientNetworkFields) {
                const clientVal = clientSettings[key];
                if (clientVal !== undefined && clientVal !== null && clientVal !== '') {
                    hasActualOverrides = true;
                    break;
                }
            }
        }

        client.hasOverrides = hasActualOverrides;
    }

    const icons = {
        'server': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>',
        'download': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>',
        'search': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        'magnet': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><path d="M22 7l-10 7L2 7"/></svg>',
        'film': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/></svg>',
        'database': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>',
        'folder': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
        'play-circle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>',
        'cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
        'upload': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>',
        'download-cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="8 17 12 21 16 17"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"/></svg>',
        'shuffle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>',
        'play': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>',
        'tv': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>',
        'layout': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>',
        'list': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        'filter': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>',
        'monitor': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>',
        'users': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>',
        'lock': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>',
        'unlock': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>',
        'edit': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
        'trash': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>',
        'plus': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>',
        'check': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>',
        'x': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>',
        'shield': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>',
        'key': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>',
        'wifi': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>',
    };

    function getIcon(name) { return icons[name] || icons['server']; }

    // Map section keys to user settings structure
    function mapToUserSettingsPath(path) {
        // homeShelves.shelves.0.enabled -> homeShelves.shelves.0.enabled (same)
        // playback.preferredPlayer -> playback.preferredPlayer (same)
        // filtering.maxSizeMovieGb -> filtering.maxSizeMovieGb (same)
        return path;
    }

    // Map filtering field paths to client settings keys
    const clientFilterFields = ['maxSizeMovieGb', 'maxSizeEpisodeGb', 'maxResolution', 'hdrDvPolicy', 'prioritizeHdr', 'filterOutTerms', 'preferredTerms', 'bypassFilteringForAioStreamsOnly'];
    // Map network field paths to client settings keys
    const clientNetworkFields = ['homeWifiSSID', 'homeBackendUrl', 'remoteBackendUrl'];

    function getClientSettingsKey(path) {
        // filtering.maxSizeMovieGb -> maxSizeMovieGb
        // network.homeWifiSSID -> homeWifiSSID
        const keys = path.split('.');
        if (keys.length === 2) {
            if (keys[0] === 'filtering' && clientFilterFields.includes(keys[1])) {
                return keys[1];
            }
            if (keys[0] === 'network' && clientNetworkFields.includes(keys[1])) {
                return keys[1];
            }
        }
        return null;
    }

    function getValue(path) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If client selected and this is a client-supported filtering field
        const clientKey = getClientSettingsKey(path);
        if (selectedClientId && clientSettings && clientKey) {
            // Return client setting if set, otherwise fall through to profile/global
            if (clientSettings[clientKey] !== undefined && clientSettings[clientKey] !== null) {
                return clientSettings[clientKey];
            }
        }

        // If user selected and this is a per-user section, check userSettings first
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let val = userSettings;
            let found = true;
            for (const key of keys) {
                if (val === undefined || val === null || !(key in val)) {
                    found = false;
                    break;
                }
                val = val[key];
            }
            // Only return if the value was found; otherwise fall through to global
            if (found && val !== undefined) {
                return val;
            }
        }

        // Fall through to global settings
        let val = currentSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return undefined;
            val = val[key];
        }
        return val;
    }

    function setValue(path, value) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If client selected and this is a client-supported filtering field
        const clientKey = getClientSettingsKey(path);
        if (selectedClientId && clientSettings !== null && clientKey) {
            clientSettings[clientKey] = value;
            return;
        }

        // If user selected and this is a per-user section, update userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            // Get global value for comparison
            let globalVal = currentSettings;
            for (const key of keys) {
                if (globalVal === undefined || globalVal === null) break;
                globalVal = globalVal[key];
            }

            // If value matches global (after normalization), delete instead of set
            const normValue = normalizeForComparison(value);
            const normGlobal = normalizeForComparison(globalVal);
            if (deepEqual(normValue, normGlobal)) {
                // Value matches global - remove from userSettings to inherit
                let obj = userSettings;
                for (let i = 0; i < keys.length - 1; i++) {
                    if (obj[keys[i]] === undefined) return; // Path doesn't exist
                    obj = obj[keys[i]];
                }
                delete obj[keys[keys.length - 1]];
                return;
            }

            let obj = userSettings;
            for (let i = 0; i < keys.length - 1; i++) {
                if (obj[keys[i]] === undefined) obj[keys[i]] = {};
                obj = obj[keys[i]];
            }
            obj[keys[keys.length - 1]] = value;
            return;
        }

        // Otherwise update global settings
        let obj = currentSettings;
        for (let i = 0; i < keys.length - 1; i++) {
            if (obj[keys[i]] === undefined) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
    }

    // Check if a client setting is explicitly set (not inherited)
    function isClientSettingSet(fieldKey) {
        if (!selectedClientId || !clientSettings) return false;
        return clientSettings[fieldKey] !== undefined && clientSettings[fieldKey] !== null;
    }

    // Check if a client value is actually different from what it would inherit
    function isClientValueDifferent(fieldKey) {
        if (!selectedClientId || !clientSettings) return false;
        const clientVal = clientSettings[fieldKey];
        if (clientVal === undefined || clientVal === null) return false;

        // Get the effective inherited value (profile if different from global, otherwise global)
        const globalVal = currentSettings.filtering ? currentSettings.filtering[fieldKey] : undefined;
        let inheritedVal;

        if (selectedUserId && userSettings && userSettings.filtering) {
            const profileVal = userSettings.filtering[fieldKey];
            // Use profile value if it's set AND differs from global
            if (profileVal !== undefined && profileVal !== null &&
                !deepEqual(normalizeForComparison(profileVal), normalizeForComparison(globalVal))) {
                inheritedVal = profileVal;
            } else {
                inheritedVal = globalVal;
            }
        } else {
            inheritedVal = globalVal;
        }

        return !deepEqual(normalizeForComparison(clientVal), normalizeForComparison(inheritedVal));
    }

    // Clear a client setting (revert to profile default)
    function clearClientSetting(fieldKey) {
        if (selectedClientId && clientSettings) {
            delete clientSettings[fieldKey];
            renderSettings();
        }
    }

    // Check if a user/profile setting is explicitly set (exists in userSettings)
    function isUserSettingSet(path) {
        if (!selectedUserId || !userSettings) return false;
        const keys = path.split('.');
        let val = userSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return false;
            if (typeof val !== 'object') return false;
            if (!(key in val)) return false;
            val = val[key];
        }
        // Value exists in userSettings (even if it's false, 0, or empty string)
        return true;
    }

    // Normalize empty values for comparison (treat undefined, null, [], "" as equivalent "empty")
    function normalizeForComparison(val) {
        if (val === undefined || val === null) return null;
        if (Array.isArray(val) && val.length === 0) return null;
        if (typeof val === 'string' && val.trim() === '') return null;
        return val;
    }

    // Check if profile value is different from global (actual override)
    function isProfileValueDifferent(path) {
        if (!selectedUserId || !userSettings) return false;
        const keys = path.split('.');
        const topKey = keys[0];

        // Get profile value
        let profileVal = userSettings;
        for (const key of keys) {
            if (profileVal === undefined || profileVal === null) return false;
            if (typeof profileVal !== 'object' || !(key in profileVal)) return false;
            profileVal = profileVal[key];
        }

        // Get global value
        let globalVal = currentSettings;
        for (const key of keys) {
            if (globalVal === undefined || globalVal === null) {
                globalVal = undefined;
                break;
            }
            globalVal = globalVal[key];
        }

        // Normalize and compare - treat empty arrays/strings/null/undefined as equivalent
        const normProfile = normalizeForComparison(profileVal);
        // If profile value is null (empty/inherit), it's not an override
        if (normProfile === null) return false;
        const normGlobal = normalizeForComparison(globalVal);

        return !deepEqual(normProfile, normGlobal);
    }

    // Get the inherited value (what value would be used if current level override is removed)
    function getInheritedValue(path) {
        const keys = path.split('.');
        const topKey = keys[0];
        const clientKey = getClientSettingsKey(path);

        // If we're at client level, inherited value is from profile or global
        if (selectedClientId && clientKey) {
            // Get profile value if set, otherwise global
            if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
                let val = userSettings;
                for (const key of keys) {
                    if (val === undefined || val === null) break;
                    val = val[key];
                }
                if (val !== undefined && val !== null) return { value: val, source: 'profile' };
            }
            // Fall through to global
            let val = currentSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return { value: undefined, source: 'global' };
                val = val[key];
            }
            return { value: val, source: 'global' };
        }

        // If we're at profile level, inherited value is from global
        if (selectedUserId && perUserSections.includes(topKey)) {
            let val = currentSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return { value: undefined, source: 'global' };
                val = val[key];
            }
            return { value: val, source: 'global' };
        }

        return { value: undefined, source: 'global' };
    }

    // Get inheritance information for a field
    // Returns: { source: 'client'|'profile'|'global', isOverridden: boolean, inheritedFrom: string|null }
    function getInheritanceInfo(path) {
        const keys = path.split('.');
        const topKey = keys[0];
        const clientKey = getClientSettingsKey(path);

        // Check if we're editing client settings and this field supports client override
        if (selectedClientId && clientSettings && clientKey) {
            // Check if client has a value that's actually different from what it would inherit
            if (isClientValueDifferent(clientKey)) {
                // Value is set at client level AND differs from inherited - check what it would inherit from
                const profileHasOverride = isUserSettingSet(path) && isProfileValueDifferent(path);
                return { source: 'client', isOverridden: true, inheritedFrom: profileHasOverride ? 'profile' : 'global' };
            }
            // Value is inherited (either not set, or set but same as inherited) - check if from profile or global
            if (isUserSettingSet(path) && isProfileValueDifferent(path)) {
                return { source: 'profile', isOverridden: false, inheritedFrom: null };
            }
            return { source: 'global', isOverridden: false, inheritedFrom: null };
        }

        // Check if we're editing profile settings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            // Check if profile has this setting AND it's different from global
            if (isUserSettingSet(path) && isProfileValueDifferent(path)) {
                return { source: 'profile', isOverridden: true, inheritedFrom: 'global' };
            }
            return { source: 'global', isOverridden: false, inheritedFrom: null };
        }

        // We're at global level
        return { source: 'global', isOverridden: false, inheritedFrom: null };
    }

    // Clear a profile setting (revert to global default)
    function clearProfileSetting(path) {
        if (!selectedUserId || !userSettings) return;
        const keys = path.split('.');
        if (keys.length === 2) {
            const [section, field] = keys;
            if (userSettings[section]) {
                delete userSettings[section][field];
                renderSettings();
            }
        }
    }

    // Format a value for display in tooltip
    function formatValueForTooltip(value) {
        if (value === undefined || value === null) return 'not set';
        if (typeof value === 'boolean') return value ? 'Yes' : 'No';
        if (Array.isArray(value)) {
            if (value.length === 0) return 'none';
            return value.join(', ');
        }
        if (typeof value === 'number') return String(value);
        if (typeof value === 'string') return value || 'empty';
        return String(value);
    }

    // Render inheritance badge for a field
    function renderInheritanceBadge(path, fieldDef) {
        // Only show inheritance info when editing profile or client settings
        if (!selectedUserId && !selectedClientId) return '';

        const info = getInheritanceInfo(path);
        const inherited = getInheritedValue(path);
        const clientKey = getClientSettingsKey(path);

        let badgeHtml = '';
        let resetBtn = '';

        if (info.isOverridden) {
            // Show that this value overrides a parent level
            const sourceLabel = info.source === 'client' ? 'Device' : 'Profile';
            const inheritedLabel = info.inheritedFrom === 'profile' ? 'profile' : 'global';
            const inheritedValueStr = formatValueForTooltip(inherited.value);
            const tooltip = 'Overrides ' + inheritedLabel + ' default: ' + inheritedValueStr;
            badgeHtml = '<span class="inheritance-badge overridden" title="' + tooltip.replace(/"/g, '&quot;') + '">' + sourceLabel + '</span>';

            // Add reset button
            if (info.source === 'client' && clientKey) {
                resetBtn = '<button type="button" class="inheritance-reset" onclick="clearClientSetting(\'' + clientKey + '\')" title="Reset to ' + inheritedLabel + ' value: ' + inheritedValueStr.replace(/"/g, '&quot;') + '">↩</button>';
            } else if (info.source === 'profile') {
                resetBtn = '<button type="button" class="inheritance-reset" onclick="clearProfileSetting(\'' + path + '\')" title="Reset to global value: ' + inheritedValueStr.replace(/"/g, '&quot;') + '">↩</button>';
            }
        } else {
            // Show where value is inherited from
            const sourceLabel = info.source === 'profile' ? 'From Profile' : 'From Global';
            badgeHtml = '<span class="inheritance-badge inherited" title="Using ' + info.source + ' default">' + sourceLabel + '</span>';
        }

        return '<span class="inheritance-wrapper">' + badgeHtml + resetBtn + '</span>';
    }
    function renderInput(fieldKey, fieldDef, value, basePath, sectionKey) {
        const id = (basePath + '_' + fieldKey).replace(/\./g, '_');
        const isReadonly = fieldDef.readonly ? 'readonly' : '';
        const fieldError = getFieldError(sectionKey, fieldKey);
        const invalidClass = fieldError ? ' invalid' : '';
        switch (fieldDef.type) {
            case 'boolean':
                // Handle both boolean and string "true"/"false" values
                const isChecked = value === true || value === 'true';
                return '<label class="toggle"><input type="checkbox" id="'+id+'" '+(isChecked ? 'checked' : '')+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.checked)"><span class="toggle-slider"></span></label>';
            case 'select':
                const options = fieldDef.options.map(opt => {
                    const optValue = typeof opt === 'object' ? opt.value : opt;
                    const optLabel = typeof opt === 'object' ? opt.label : opt;
                    return '<option value="'+optValue+'" '+(value === optValue ? 'selected' : '')+'>'+optLabel+'</option>';
                }).join('');
                return '<select class="form-select'+invalidClass+'" id="'+id+'" onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">'+options+'</select>';
            case 'number':
                return '<input type="number" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || 0)+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', parseFloat(this.value) || 0)">';
            case 'password':
                return '<input type="password" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
            case 'tags':
                const tags = Array.isArray(value) ? value : [];
                const tagsHtml = tags.map(tag => '<span class="tag">'+tag+'<span class="tag-remove" onclick="removeTag(\''+basePath+'\', \''+fieldKey+'\', \''+tag+'\')">&times;</span></span>').join('');
                return '<div class="tags-input'+invalidClass+'" id="'+id+'_container">'+tagsHtml+'<input type="text" placeholder="Add tag..." onkeydown="handleTagInput(event, \''+basePath+'\', \''+fieldKey+'\')"></div>';
            case 'checkboxes':
                const selectedValues = Array.isArray(value) ? value : [];
                const checkboxesHtml = (fieldDef.options || []).map(opt => {
                    const optValue = typeof opt === 'object' ? opt.value : opt;
                    const optLabel = typeof opt === 'object' ? opt.label : opt;
                    const isDisabled = typeof opt === 'object' && opt.disabled;
                    const isChecked = selectedValues.includes(optValue) ? 'checked' : '';
                    const disabledAttr = isDisabled ? 'disabled' : '';
                    const disabledClass = isDisabled ? ' checkbox-option-disabled' : '';
                    return '<label class="checkbox-option'+disabledClass+'"><input type="checkbox" value="'+optValue+'" '+isChecked+' '+disabledAttr+' onchange="handleCheckboxChange(\''+basePath+'\', \''+fieldKey+'\', \''+optValue+'\', this.checked)"><span>'+optLabel+'</span></label>';
                }).join('');
                return '<div class="checkboxes-group'+invalidClass+'" id="'+id+'_container">'+checkboxesHtml+'</div>';
            default:
                return '<input type="text" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
        }
    }
    function handleFieldChange(basePath, fieldKey, value) {
        // For nested config fields (e.g., config.autoClearQueue), convert booleans to strings
        // because Config is map[string]string in Go
        if (fieldKey.startsWith('config.') && typeof value === 'boolean') {
            value = value ? 'true' : 'false';
        }
        setValue(basePath ? basePath+'.'+fieldKey : fieldKey, value);
        // Re-render to update validation indicators (renderSettings runs validation)
        renderSettings();
    }
    function handleTagInput(event, basePath, fieldKey) {
        if (event.key === 'Enter' || event.key === ',') {
            event.preventDefault();
            const tag = event.target.value.trim();
            if (tag) { addTag(basePath, fieldKey, tag); event.target.value = ''; }
        }
    }
    function addTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = getValue(fullPath) || [];
        if (!tags.includes(tag)) { tags.push(tag); setValue(fullPath, tags); renderSettings(); }
    }
    function removeTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = (getValue(fullPath) || []).filter(t => t !== tag);
        setValue(fullPath, tags);
        renderSettings();
    }
    function handleCheckboxChange(basePath, fieldKey, optionValue, isChecked) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let values = getValue(fullPath) || [];
        if (!Array.isArray(values)) values = [];
        if (isChecked && !values.includes(optionValue)) {
            values.push(optionValue);
        } else if (!isChecked) {
            values = values.filter(v => v !== optionValue);
        }
        setValue(fullPath, values);
        renderSettings();
    }
    function addArrayItem(sectionKey) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr;
        if (sectionDef.parent) {
            if (!targetSettings[sectionDef.parent]) targetSettings[sectionDef.parent] = {};
            arr = targetSettings[sectionDef.parent][sectionDef.key] || [];
            targetSettings[sectionDef.parent][sectionDef.key] = arr;
        } else {
            arr = targetSettings[sectionKey] || [];
            targetSettings[sectionKey] = arr;
        }
        const newItem = {};
        for (const [fieldKey, fieldDef] of Object.entries(sectionDef.fields)) {
            switch (fieldDef.type) {
                case 'boolean': newItem[fieldKey] = false; break;
                case 'number': newItem[fieldKey] = 0; break;
                case 'select':
                    const firstOpt = fieldDef.options?.[0];
                    newItem[fieldKey] = typeof firstOpt === 'object' ? firstOpt.value : (firstOpt || '');
                    break;
                default: newItem[fieldKey] = '';
            }
        }
        arr.push(newItem);
        renderSettings();
    }
    function removeArrayItem(sectionKey, index) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr = sectionDef.parent ? targetSettings[sectionDef.parent]?.[sectionDef.key] : targetSettings[sectionKey];
        if (arr && arr.length > index) { arr.splice(index, 1); renderSettings(); }
    }
    // Test provider functions
    async function testProvider(sectionKey, index) {
        const btn = document.getElementById('test-btn-'+sectionKey+'-'+index);
        const resultSpan = document.getElementById('test-result-'+sectionKey+'-'+index);
        if (!btn) return;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Testing...';
        resultSpan.textContent = '';
        resultSpan.className = 'test-result';

        let endpoint, payload;
        const sectionDef = schema[sectionKey];
        let items;

        if (sectionDef.parent) {
            items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
        } else {
            items = currentSettings[sectionKey] || [];
        }
        const item = items[index];
        if (!item) {
            btn.disabled = false;
            btn.textContent = 'Test';
            resultSpan.textContent = 'Item not found';
            resultSpan.className = 'test-result error';
            return;
        }

        switch(sectionKey) {
            case 'indexers':
                endpoint = '/admin/api/test/indexer';
                payload = { url: item.url, apiKey: item.apiKey, name: item.name };
                break;
            case 'torrentScrapers':
                endpoint = '/admin/api/test/scraper';
                payload = { name: item.name, type: item.type, url: item.url, apiKey: item.apiKey };
                break;
            case 'usenet':
                endpoint = '/admin/api/test/usenet-provider';
                payload = {
                    name: item.name,
                    host: item.host,
                    port: item.port,
                    ssl: item.ssl,
                    username: item.username,
                    password: item.password
                };
                break;
            case 'debridProviders':
                endpoint = '/admin/api/test/debrid-provider';
                payload = { name: item.name, provider: item.provider, apiKey: item.apiKey };
                break;
            default:
                btn.disabled = false;
                btn.textContent = 'Test';
                resultSpan.textContent = 'Unknown section';
                resultSpan.className = 'test-result error';
                return;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            btn.disabled = false;
            btn.textContent = 'Test';

            if (result.success) {
                resultSpan.textContent = result.message || 'Success';
                resultSpan.className = 'test-result success';
            } else {
                resultSpan.textContent = result.error || 'Test failed';
                resultSpan.className = 'test-result error';
            }
        } catch (e) {
            btn.disabled = false;
            btn.textContent = 'Test';
            resultSpan.textContent = 'Error: ' + e.message;
            resultSpan.className = 'test-result error';
        }
    }

    // Testable sections
    const testableSections = ['indexers', 'torrentScrapers', 'usenet', 'debridProviders'];

    // Deep equality check for comparing values
    function deepEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return a == b;
        if (typeof a !== typeof b) return false;
        if (typeof a !== 'object') return false;
        if (Array.isArray(a) !== Array.isArray(b)) return false;

        if (Array.isArray(a)) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) return false;
            }
            return true;
        }

        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) return false;

        for (const key of keysA) {
            if (!keysB.includes(key) || !deepEqual(a[key], b[key])) return false;
        }
        return true;
    }

    // Compare two shelf objects - considers them equal if core properties match
    // This handles cases where profile shelf is missing type/listUrl but otherwise matches global
    function shelfEqual(profileShelf, globalShelf) {
        if (!profileShelf || !globalShelf) return profileShelf === globalShelf;
        // Core properties must match
        if (profileShelf.id !== globalShelf.id) return false;
        if (profileShelf.name !== globalShelf.name) return false;
        if (profileShelf.enabled !== globalShelf.enabled) return false;
        if (profileShelf.order !== globalShelf.order) return false;
        // If profile has type/listUrl, they must match global
        if (profileShelf.type && profileShelf.type !== globalShelf.type) return false;
        if (profileShelf.listUrl && profileShelf.listUrl !== globalShelf.listUrl) return false;
        return true;
    }

    // Compare two shelf arrays - considers them equal if all shelves match (using shelfEqual)
    function shelvesEqual(profileShelves, globalShelves) {
        if (!profileShelves || !globalShelves) return profileShelves === globalShelves;
        if (profileShelves.length !== globalShelves.length) return false;
        // Sort both arrays by ID for consistent comparison
        const sortedProfile = [...profileShelves].sort((a, b) => a.id.localeCompare(b.id));
        const sortedGlobal = [...globalShelves].sort((a, b) => a.id.localeCompare(b.id));
        for (let i = 0; i < sortedProfile.length; i++) {
            if (!shelfEqual(sortedProfile[i], sortedGlobal[i])) return false;
        }
        return true;
    }

    // Compare homeShelves sections - uses shelvesEqual for shelves array
    function homeShelvesEqual(profileHomeShelves, globalHomeShelves) {
        if (!profileHomeShelves || !globalHomeShelves) return profileHomeShelves === globalHomeShelves;
        // Compare shelves using lenient comparison
        if (!shelvesEqual(profileHomeShelves.shelves, globalHomeShelves.shelves)) return false;
        // Compare trendingMovieSource
        const profileTMS = profileHomeShelves.trendingMovieSource || '';
        const globalTMS = globalHomeShelves.trendingMovieSource || '';
        if (profileTMS !== globalTMS) return false;
        return true;
    }

    // Strip values from userSettings that match global settings (treat as inherited)
    // This ensures we only store actual overrides, not duplicate values
    function stripInheritedValues(userSettings, globalSettings) {
        if (!userSettings || !globalSettings) return userSettings;

        const stripped = {};
        // Only process per-user sections (top-level only, skip nested like 'homeShelves.shelves')
        const topLevelPerUserSections = ['playback', 'homeShelves', 'filtering', 'liveTV', 'display'];

        for (const section of topLevelPerUserSections) {
            if (!userSettings[section]) continue;

            const globalSection = globalSettings[section];
            if (!globalSection) {
                // No global equivalent, keep user settings
                stripped[section] = userSettings[section];
                console.log('stripInheritedValues: keeping entire section (no global)', section);
                continue;
            }

            // For each field in the user's section, only keep if different from global
            const sectionStripped = {};
            for (const [key, value] of Object.entries(userSettings[section])) {
                const globalValue = globalSection[key];
                // Normalize before comparing - treat empty strings/arrays as "inherit from global"
                const normValue = normalizeForComparison(value);
                const normGlobal = normalizeForComparison(globalValue);
                // If profile value normalizes to null, it means "inherit" - don't store it
                if (normValue === null) {
                    console.log('stripInheritedValues: skipping null value', section, key, value);
                    continue;
                }
                // Use lenient comparison for shelves array (handles missing type/listUrl properties)
                let isEqual;
                if (section === 'homeShelves' && key === 'shelves') {
                    isEqual = shelvesEqual(value, globalValue);
                } else {
                    isEqual = deepEqual(normValue, normGlobal);
                }
                // Keep if different from global
                if (!isEqual) {
                    console.log('stripInheritedValues: keeping different value', section, key, 'profile:', normValue, 'global:', normGlobal);
                    sectionStripped[key] = value;
                } else {
                    console.log('stripInheritedValues: skipping same value', section, key);
                }
            }

            // Only include section if it has actual overrides
            if (Object.keys(sectionStripped).length > 0) {
                stripped[section] = sectionStripped;
            }
        }

        return stripped;
    }

    // Check if a specific section has unsaved changes
    function sectionHasChanges(sectionKey) {
        const sectionDef = schema[sectionKey];
        if (!sectionDef) return false;

        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        let hasDirectChanges = false;

        if (selectedUserId && isPerUserSection) {
            // Compare user settings
            if (!userSettings || !originalUserSettings) return false;

            if (sectionDef.parent) {
                const currentVal = userSettings[sectionDef.parent]?.[sectionDef.key];
                const originalVal = originalUserSettings[sectionDef.parent]?.[sectionDef.key];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            } else {
                const currentVal = userSettings[sectionKey];
                const originalVal = originalUserSettings[sectionKey];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            }
        } else {
            // Compare global settings
            if (sectionDef.parent) {
                const currentVal = currentSettings[sectionDef.parent]?.[sectionDef.key];
                const originalVal = originalSettings[sectionDef.parent]?.[sectionDef.key];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            } else {
                const currentVal = currentSettings[sectionKey];
                const originalVal = originalSettings[sectionKey];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            }
        }

        if (hasDirectChanges) return true;

        // Also check nested sections that are rendered within this section
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (sectionHasChanges(nestedKey)) return true;
            }
        }

        return false;
    }

    // Save a specific section (still saves all, but used for UX)
    async function saveSection(sectionKey, event) {
        event.stopPropagation(); // Don't toggle section when clicking save

        const btn = event.target.closest('.section-save-btn');
        if (!btn) return;

        const originalHtml = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span>';

        try {
            if (selectedUserId && userSettings) {
                // Save user-specific settings (strip values matching global to keep as inherited)
                const strippedSettings = stripInheritedValues(userSettings, currentSettings);
                console.log('Saving user settings - before strip:', JSON.stringify(userSettings));
                console.log('Saving user settings - after strip:', JSON.stringify(strippedSettings));
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(strippedSettings)
                });
                if (response.ok) {
                    // Update local state with stripped values
                    userSettings = strippedSettings;
                    originalUserSettings = JSON.parse(JSON.stringify(strippedSettings));
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
                    showToast('Settings saved successfully');
                    // Recalculate override status from actual values to ensure consistency
                    recalculateUserOverrides(selectedUserId);
                    updateUserDropdownIndicators();
                    updateClientDropdownIndicators();
                    updateRevertButtonVisibility();
                    setTimeout(() => renderSettings(), 500);
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save settings', 'error');
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            } else {
                // Save global settings
                const response = await fetch(basePath + '/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
                    showToast('Settings saved successfully');
                    setTimeout(() => renderSettings(), 500);
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            }
        } catch (e) {
            showToast('Failed to save settings: ' + e.message, 'error');
            btn.innerHTML = originalHtml;
            btn.disabled = false;
        }
    }

    function renderArraySection(sectionKey, sectionDef) {
        let items, basePath;
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        if (sectionDef.parent) {
            // For nested array sections like homeShelves.shelves
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionDef.parent]?.[sectionDef.key] || [];
            } else {
                items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
            }
            basePath = sectionDef.parent+'.'+sectionDef.key;
        } else {
            // For top-level array sections
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionKey] || [];
            } else {
                items = currentSettings[sectionKey] || [];
            }
            basePath = sectionKey;
        }
        const isTestable = testableSections.includes(sectionKey);
        const itemsHtml = items.map((item, index) => {
            const fieldsHtml = Object.entries(sectionDef.fields)
                .sort((a, b) => (a[1].order || 0) - (b[1].order || 0))
                .map(([fieldKey, fieldDef]) => {
                const showWhen = fieldDef.showWhen;
                if (showWhen) {
                    let shouldShow = false;
                    if (typeof showWhen === 'string' && showWhen.includes('=')) {
                        // Simple string format: "field=value"
                        const [field, value] = showWhen.split('=');
                        shouldShow = item[field] === value;
                    } else if (showWhen.operator === 'or' && Array.isArray(showWhen.conditions)) {
                        shouldShow = showWhen.conditions.some(cond => item[cond.field] === cond.value);
                    } else if (showWhen.field) {
                        shouldShow = item[showWhen.field] === showWhen.value;
                    }
                    if (!shouldShow) return '';
                }
                // Handle nested field paths like "config.autoClearQueue"
                let fieldValue;
                if (fieldKey.includes('.')) {
                    const parts = fieldKey.split('.');
                    fieldValue = parts.reduce((obj, key) => obj?.[key], item);
                } else {
                    fieldValue = item[fieldKey];
                }
                return '<div class="form-group'+(fieldDef.type === 'boolean' ? ' form-group-toggle' : '')+'"><label class="form-label">'+fieldDef.label+'</label>'+renderInput(fieldKey, fieldDef, fieldValue, basePath+'.'+index, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+'</div>';
            }).join('');
            const testBtn = isTestable ? '<button id="test-btn-'+sectionKey+'-'+index+'" class="btn btn-sm btn-secondary" onclick="testProvider(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test</button>' : '';
            const testResult = isTestable ? '<span id="test-result-'+sectionKey+'-'+index+'" class="test-result"></span>' : '';
            return '<div class="array-item"><div class="array-item-header"><div class="array-item-title">'+(item.name || item.id || 'Item '+(index+1))+'</div><div class="array-item-actions">'+testBtn+testResult+'<button class="btn btn-sm btn-danger" onclick="removeArrayItem(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button></div></div><div class="grid grid-2">'+fieldsHtml+'</div></div>';
        }).join('');
        return '<div class="array-items">'+itemsHtml+'<button class="add-item-btn" onclick="addArrayItem(\''+sectionKey+'\')"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add '+sectionDef.label.replace(/s$/, '')+'</button></div>';
    }
    // Render provider priority reorder UI for streaming section
    function renderProviderPriorityUI() {
        const multiProviderMode = getValue('streaming.multiProviderMode') || 'fastest';
        if (multiProviderMode !== 'preferred') return '';

        const debridProviders = currentSettings.streaming?.debridProviders || [];
        const enabledCount = debridProviders.filter(p => p.enabled && p.apiKey).length;
        if (enabledCount < 2) return '';

        const rows = debridProviders.map((p, i) => {
            const isEnabled = p.enabled && p.apiKey;
            const nameStyle = isEnabled ? '' : 'color: #666;';
            const disabledLabel = isEnabled ? '' : ' (disabled)';
            return '<div class="priority-row" data-index="'+i+'">'+
                '<span class="priority-handle">☰</span>'+
                '<span class="priority-num">'+(i+1)+'.</span>'+
                '<span class="priority-name" style="'+nameStyle+'">'+(p.name || p.provider || 'Provider '+(i+1))+disabledLabel+'</span>'+
            '</div>';
        }).join('');

        const styles = '<style>'+
            '.priority-container{position:relative;}'+
            '.priority-row{display:flex;align-items:center;padding:10px 12px;background:rgba(255,255,255,0.05);border-radius:6px;margin-bottom:6px;user-select:none;transition:transform 0.15s ease,box-shadow 0.15s ease,background 0.15s ease;}'+
            '.priority-row.dragging{background:rgba(138,43,226,0.3);box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:100;transform:scale(1.02);}'+
            '.priority-row.drag-over{border-top:2px solid #8a2be2;margin-top:-2px;}'+
            '.priority-handle{color:#666;margin-right:12px;font-size:16px;cursor:grab;touch-action:none;padding:8px;margin:-8px;margin-right:4px;}'+
            '.priority-handle:active{cursor:grabbing;}'+
            '.priority-num{color:#888;margin-right:10px;min-width:24px;text-align:right;}'+
            '.priority-name{flex:1;}'+
            '</style>';

        return '<div style="margin-top:16px;padding-top:16px;border-top:1px solid var(--border-color);">'+
            styles+
            '<label class="form-label">Provider Priority</label>'+
            '<p class="form-hint" style="margin-bottom:8px;">Drag to reorder. #1 has highest priority when multiple have cached results.</p>'+
            '<div class="priority-container" id="priorityContainer">'+rows+'</div>'+
            '</div>';
    }

    // Render home shelves order UI with drag-and-drop
    function renderShelvesOrderUI() {
        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        let inheritanceSource = 'global'; // Track where shelves come from
        let isInherited = false;

        if (selectedUserId && userSettings && isPerUserSection) {
            // Check if profile has its own shelves configured
            const profileShelves = userSettings.homeShelves?.shelves;
            const globalShelves = currentSettings.homeShelves?.shelves || [];

            if (profileShelves && profileShelves.length > 0) {
                // Profile has custom shelves - check if they differ from global (lenient comparison)
                if (!shelvesEqual(profileShelves, globalShelves)) {
                    shelves = profileShelves;
                    inheritanceSource = 'profile';
                    isInherited = false;
                } else {
                    // Profile shelves match global - treat as inherited
                    shelves = globalShelves;
                    inheritanceSource = 'global';
                    isInherited = true;
                }
            } else {
                // Profile doesn't have shelves - inherit from global
                shelves = globalShelves;
                inheritanceSource = 'global';
                isInherited = true;
            }
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        if (!shelves.length) return '<p class="form-hint">No shelves configured.</p>';

        // Build inheritance badge for section
        let inheritanceBadgeHtml = '';
        if (selectedUserId) {
            if (isInherited) {
                inheritanceBadgeHtml = '<span class="inheritance-badge inherited" title="Using global default" style="margin-left:8px;font-size:11px;padding:2px 8px;background:rgba(100,100,100,0.3);border-radius:4px;color:#aaa;">From Global</span>';
            } else {
                inheritanceBadgeHtml = '<span class="inheritance-badge overridden" title="Profile has custom configuration" style="margin-left:8px;font-size:11px;padding:2px 8px;background:rgba(138,43,226,0.3);border-radius:4px;color:#c9a0dc;">Profile</span>' +
                    '<button type="button" class="inheritance-reset" onclick="resetShelvesToGlobal()" title="Reset to global defaults" style="margin-left:4px;background:none;border:none;color:#888;cursor:pointer;font-size:14px;">↩</button>';
            }
        }

        // Sort by order for display
        const sortedShelves = [...shelves].sort((a, b) => (a.order || 0) - (b.order || 0));

        const rows = sortedShelves.map((s, i) => {
            const enabledClass = s.enabled ? '' : ' disabled';
            const toggleChecked = s.enabled ? 'checked' : '';
            const isCustom = !!s.listUrl;
            const isTrending = s.id === 'trending-movies' || s.id === 'trending-tv';
            const canFilter = isCustom || isTrending; // Shelves that support hideUnreleased filter
            const typeLabel = isCustom ? '<span class="shelf-type-badge">'+getShelfTypeLabel(s.type)+'</span>' : '';
            const filterBadge = s.hideUnreleased ? '<span class="shelf-filter-badge" title="Hide Unreleased enabled">🎬</span>' : '';

            let actionsHtml = '';
            if (isCustom) {
                // Custom lists: edit and delete
                actionsHtml = '<div class="shelf-actions">'+
                    '<button class="shelf-edit-btn" onclick="editCustomShelf(\''+s.id+'\')" title="Edit">✎</button>'+
                    '<button class="shelf-delete-btn" onclick="deleteCustomShelf(\''+s.id+'\')" title="Delete">×</button>'+
                '</div>';
            } else if (isTrending) {
                // Trending shelves: only edit (for hideUnreleased toggle)
                actionsHtml = '<div class="shelf-actions">'+
                    '<button class="shelf-edit-btn" onclick="editTrendingShelf(\''+s.id+'\')" title="Filter Settings">⚙</button>'+
                '</div>';
            }

            // Use display index (i) for drag reordering, store shelf ID for reference
            return '<div class="shelf-row'+enabledClass+'" data-index="'+i+'" data-id="'+s.id+'">'+
                '<span class="shelf-handle">☰</span>'+
                '<span class="shelf-name">'+s.name+typeLabel+filterBadge+'</span>'+
                '<label class="shelf-toggle"><input type="checkbox" '+toggleChecked+' onchange="toggleShelfEnabled(\''+s.id+'\', this.checked)"><span class="toggle-slider"></span></label>'+
                actionsHtml+
            '</div>';
        }).join('');

        const styles = '<style>'+
            '.shelves-container{position:relative;}'+
            '.shelf-row{display:flex;align-items:center;padding:10px 12px;background:rgba(255,255,255,0.05);border-radius:6px;margin-bottom:6px;user-select:none;transition:transform 0.15s ease,box-shadow 0.15s ease,background 0.15s ease,opacity 0.15s ease;}'+
            '.shelf-row.dragging{background:rgba(138,43,226,0.3);box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:100;transform:scale(1.02);}'+
            '.shelf-row.drag-over{border-top:2px solid #8a2be2;margin-top:-2px;}'+
            '.shelf-row.disabled{opacity:0.5;}'+
            '.shelf-handle{color:#666;margin-right:12px;font-size:16px;cursor:grab;touch-action:none;padding:8px;margin:-8px;margin-right:4px;}'+
            '.shelf-handle:active{cursor:grabbing;}'+
            '.shelf-name{flex:1;font-weight:500;display:flex;align-items:center;gap:8px;}'+
            '.shelf-type-badge{font-size:10px;padding:2px 6px;background:rgba(138,43,226,0.3);border-radius:4px;color:#c9a0dc;font-weight:normal;}'+
            '.shelf-filter-badge{font-size:12px;margin-left:4px;opacity:0.8;}'+
            '.shelf-toggle{position:relative;display:inline-block;width:40px;height:22px;cursor:pointer;}'+
            '.shelf-toggle input{opacity:0;width:0;height:0;}'+
            '.toggle-slider{position:absolute;top:0;left:0;right:0;bottom:0;background-color:#444;border-radius:22px;transition:0.3s;}'+
            '.toggle-slider:before{position:absolute;content:"";height:16px;width:16px;left:3px;bottom:3px;background-color:white;border-radius:50%;transition:0.3s;}'+
            '.shelf-toggle input:checked + .toggle-slider{background-color:#8a2be2;}'+
            '.shelf-toggle input:checked + .toggle-slider:before{transform:translateX(18px);}'+
            '.shelf-edit-btn{background:rgba(255,255,255,0.08);border:none;color:#aaa;font-size:16px;cursor:pointer;padding:8px 10px;line-height:1;border-radius:6px;min-width:36px;min-height:36px;display:flex;align-items:center;justify-content:center;margin-left:8px;}'+
            '.shelf-edit-btn:hover{color:#8a2be2;background:rgba(138,43,226,0.15);}'+
            '.shelf-delete-btn{background:rgba(255,255,255,0.08);border:none;color:#aaa;font-size:18px;cursor:pointer;padding:8px 10px;line-height:1;border-radius:6px;min-width:36px;min-height:36px;display:flex;align-items:center;justify-content:center;margin-left:4px;}'+
            '.shelf-delete-btn:hover{color:#e94560;background:rgba(233,69,96,0.15);}'+
            '.shelf-actions{display:flex;align-items:center;}'+
            '@media(max-width:768px){'+
                '.shelf-row{flex-wrap:wrap;}'+
                '.shelf-actions{width:100%;margin-top:8px;padding-left:28px;gap:8px;}'+
                '.shelf-edit-btn,.shelf-delete-btn{min-width:44px;min-height:44px;font-size:20px;padding:10px 12px;margin-left:0;}'+
                '.add-custom-list-form .form-row{flex-wrap:wrap;}'+
                '.add-custom-list-form .form-group{flex:none !important;width:100%;}'+
                '.add-custom-list-form button{width:100%;margin-bottom:0;margin-top:4px;}'+
            '}'+
            '.add-custom-list-form{margin-top:16px;padding:16px;background:rgba(255,255,255,0.03);border-radius:8px;border:1px dashed rgba(255,255,255,0.1);}'+
            '.add-custom-list-form .form-row{display:flex;gap:12px;align-items:flex-end;}'+
            '.add-custom-list-form .form-group{flex:1;}'+
            '.add-custom-list-form input{width:100%;padding:8px 12px;background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white;font-size:14px;}'+
            '.add-custom-list-form button{padding:8px 16px;background:#8a2be2;border:none;border-radius:6px;color:white;cursor:pointer;white-space:nowrap;}'+
            '.add-custom-list-form button:hover{background:#9b3ce6;}'+
            // Inherited styling - greyed out when inheriting from global
            '.shelves-inherited .shelf-row{opacity:0.6;background:rgba(100,116,139,0.08);border:1px solid rgba(100,116,139,0.25);}'+
            '.shelves-inherited .shelf-handle{color:#555;}'+
            '.shelves-inherited .shelf-name{color:#888;}'+
            '.shelves-inherited .toggle-slider{opacity:0.6;background:rgba(100,116,139,0.2);}'+
            '.shelves-inherited .shelf-toggle input:checked + .toggle-slider{opacity:0.6;background:rgba(99,102,241,0.5);}'+
            '.shelves-inherited .add-custom-list-form{opacity:0.6;}'+
            '.shelves-inherited .add-custom-list-form input,.shelves-inherited .add-custom-list-form select,.shelves-inherited .add-custom-list-form button{opacity:0.7;}'+
            '.add-custom-list-form select{width:100%;padding:8px 12px;background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white;font-size:14px;cursor:pointer;}'+
            '.add-custom-list-form select option{background:#1a1a2e;color:white;}'+
            '</style>';

        const addCustomListForm = '<div class="add-custom-list-form">'+
            '<h4 style="margin:0 0 12px 0;font-size:14px;font-weight:500;">Add Custom List</h4>'+
            '<div class="form-row">'+
                '<div class="form-group">'+
                    '<label class="form-label" style="font-size:12px;margin-bottom:4px;">Type</label>'+
                    '<select id="newShelfType">'+
                        '<option value="mdblist">MDBList</option>'+
                    '</select>'+
                '</div>'+
                '<div class="form-group">'+
                    '<label class="form-label" style="font-size:12px;margin-bottom:4px;">Name</label>'+
                    '<input type="text" id="newShelfName" placeholder="My Custom List">'+
                '</div>'+
                '<div class="form-group" style="flex:2;">'+
                    '<label class="form-label" style="font-size:12px;margin-bottom:4px;">URL</label>'+
                    '<input type="text" id="newShelfUrl" placeholder="https://mdblist.com/lists/username/list-name/json">'+
                '</div>'+
                '<div class="form-group" style="flex:0 0 80px;">'+
                    '<label class="form-label" style="font-size:12px;margin-bottom:4px;">Limit</label>'+
                    '<input type="number" id="newShelfLimit" placeholder="0" min="0" max="500" value="0">'+
                '</div>'+
                '<div class="form-group" style="flex:0 0 auto;display:flex;flex-direction:column;align-items:flex-start;">'+
                    '<label class="form-label" style="font-size:12px;margin-bottom:4px;">Hide Unreleased</label>'+
                    '<label style="display:flex;align-items:center;cursor:pointer;margin-bottom:1rem;" title="Filter out movies not yet available for home viewing, and upcoming/in-production series"><input type="checkbox" id="newShelfHideUnreleased" style="margin-right:6px;"><span style="font-size:12px;color:#888;">🎬</span></label>'+
                '</div>'+
                '<button onclick="addCustomShelf()" style="margin-bottom:1rem;">Add</button>'+
            '</div>'+
            '<p class="form-hint" style="margin-top:8px;font-size:11px;">Example: https://mdblist.com/lists/garycrawfordgc/top-movies-of-the-week/json<br><span style="color:#9b9b9b;">🎬 Hide Unreleased: Only show movies available for home viewing (streaming/digital/physical) and exclude upcoming series.</span></p>'+
        '</div>';

        // Add inherited class to wrapper when inheriting from global
        const inheritedClass = (selectedUserId && isInherited) ? ' shelves-inherited' : '';

        return styles+
            '<div class="shelves-wrapper'+inheritedClass+'">'+
            '<div style="display:flex;align-items:center;margin-bottom:8px;"><p class="form-hint" style="margin:0;">Drag to reorder. Toggle to show/hide shelves on the home screen.</p>'+inheritanceBadgeHtml+'</div>'+
            '<div class="shelves-container" id="shelvesContainer">'+rows+'</div>'+
            addCustomListForm+
            '</div>';
    }

    // Reset profile shelves to global defaults
    function resetShelvesToGlobal() {
        if (!selectedUserId || !userSettings) return;
        // Remove shelves from userSettings to inherit from global
        if (userSettings.homeShelves) {
            delete userSettings.homeShelves.shelves;
            // Clean up empty homeShelves object
            if (Object.keys(userSettings.homeShelves).length === 0) {
                delete userSettings.homeShelves;
            }
        }
        renderSettings();
    }

    // Ensure profile has its own copy of shelves before editing
    // This copies global shelves to profile if profile doesn't have custom shelves
    function ensureProfileShelves() {
        if (!selectedUserId || !userSettings) return false;
        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        if (!isPerUserSection) return false;

        // Check if profile already has shelves
        if (userSettings.homeShelves?.shelves && userSettings.homeShelves.shelves.length > 0) {
            return true; // Already has shelves
        }

        // Copy global shelves to profile
        const globalShelves = currentSettings.homeShelves?.shelves || [];
        if (!userSettings.homeShelves) userSettings.homeShelves = {};
        // Deep copy to avoid modifying global
        userSettings.homeShelves.shelves = JSON.parse(JSON.stringify(globalShelves));
        return true;
    }

    // Toggle shelf enabled state
    function toggleShelfEnabled(shelfId, enabled) {
        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            // Ensure profile has its own shelves before editing
            ensureProfileShelves();
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        const shelf = shelves.find(s => s.id === shelfId);
        if (shelf) {
            shelf.enabled = enabled;
            renderSettings();
        }
    }

    // Validate shelf URL based on type
    function validateShelfUrl(type, url) {
        switch (type) {
            case 'mdblist':
                if (!url.includes('mdblist.com/lists/')) {
                    alert('Invalid MDBList URL. Format: https://mdblist.com/lists/{username}/{list-name}');
                    return false;
                }
                return true;
            default:
                return true;
        }
    }

    // Auto-fix shelf URL based on type
    function fixShelfUrl(type, url) {
        url = url.replace(/\/+$/, '');
        switch (type) {
            case 'mdblist':
                if (!url.endsWith('/json')) {
                    url = url + '/json';
                }
                return url;
            default:
                return url;
        }
    }

    // Get display label for shelf type
    function getShelfTypeLabel(type) {
        switch (type) {
            case 'mdblist': return 'MDBList';
            default: return type;
        }
    }

    // Add custom shelf
    function addCustomShelf() {
        const typeSelect = document.getElementById('newShelfType');
        const nameInput = document.getElementById('newShelfName');
        const urlInput = document.getElementById('newShelfUrl');
        const limitInput = document.getElementById('newShelfLimit');
        const hideUnreleasedInput = document.getElementById('newShelfHideUnreleased');
        const shelfType = typeSelect?.value || 'mdblist';
        const name = nameInput?.value?.trim();
        let url = urlInput?.value?.trim();
        const limit = parseInt(limitInput?.value || '0', 10) || 0;
        const hideUnreleased = hideUnreleasedInput?.checked || false;

        if (!name || !url) {
            alert('Please enter both a name and URL');
            return;
        }

        // Validate URL based on type
        if (!validateShelfUrl(shelfType, url)) {
            return;
        }

        // Auto-fix URL based on type
        url = fixShelfUrl(shelfType, url);

        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            // Ensure profile has its own shelves before adding
            ensureProfileShelves();
            shelves = userSettings.homeShelves.shelves;
        } else {
            if (!currentSettings.homeShelves) currentSettings.homeShelves = {};
            if (!currentSettings.homeShelves.shelves) currentSettings.homeShelves.shelves = [];
            shelves = currentSettings.homeShelves.shelves;
        }

        // Generate unique ID from URL
        const urlParts = url.split('/');
        const listName = urlParts[urlParts.length - 2] || 'custom';
        const id = shelfType + '-' + listName + '-' + Date.now();

        // Add new shelf at the end
        const maxOrder = Math.max(...shelves.map(s => s.order || 0), -1);
        shelves.push({
            id: id,
            name: name,
            enabled: true,
            order: maxOrder + 1,
            type: shelfType,
            listUrl: url,
            limit: limit,
            hideUnreleased: hideUnreleased
        });

        // Clear inputs
        if (typeSelect) typeSelect.value = 'mdblist';
        nameInput.value = '';
        urlInput.value = '';
        if (limitInput) limitInput.value = '0';
        if (hideUnreleasedInput) hideUnreleasedInput.checked = false;

        renderSettings();
    }

    // Delete custom shelf
    function deleteCustomShelf(shelfId) {
        if (!confirm('Delete this custom list?')) return;

        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            // Ensure profile has its own shelves before deleting
            ensureProfileShelves();
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        const index = shelves.findIndex(s => s.id === shelfId);
        if (index !== -1) {
            shelves.splice(index, 1);
            renderSettings();
        }
    }

    // Edit custom shelf - shows inline edit form
    function editCustomShelf(shelfId) {
        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            ensureProfileShelves();
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        const shelf = shelves.find(s => s.id === shelfId);
        if (!shelf) return;

        // Create modal HTML
        const modalHtml = `
            <div id="editShelfModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:10000;">
                <div style="background:#1a1a2e;border-radius:12px;padding:24px;max-width:500px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,0.5);">
                    <h3 style="margin:0 0 16px 0;font-size:18px;font-weight:600;">Edit ${getShelfTypeLabel(shelf.type)} List</h3>
                    <div style="margin-bottom:12px;">
                        <label class="form-label" style="font-size:12px;margin-bottom:4px;display:block;">Name</label>
                        <input type="text" id="editShelfName" value="${shelf.name.replace(/"/g, '&quot;')}" style="width:100%;padding:8px 12px;background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white;font-size:14px;box-sizing:border-box;">
                    </div>
                    <div style="margin-bottom:12px;">
                        <label class="form-label" style="font-size:12px;margin-bottom:4px;display:block;">URL</label>
                        <input type="text" id="editShelfUrl" value="${(shelf.listUrl || '').replace(/"/g, '&quot;')}" style="width:100%;padding:8px 12px;background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white;font-size:14px;box-sizing:border-box;">
                    </div>
                    <div style="margin-bottom:12px;">
                        <label class="form-label" style="font-size:12px;margin-bottom:4px;display:block;">Item Limit <span style="color:#888;font-weight:normal;">(0 = unlimited)</span></label>
                        <input type="number" id="editShelfLimit" value="${shelf.limit || 0}" min="0" max="500" style="width:100%;padding:8px 12px;background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white;font-size:14px;box-sizing:border-box;">
                    </div>
                    <div style="margin-bottom:16px;">
                        <label style="display:flex;align-items:center;cursor:pointer;">
                            <input type="checkbox" id="editShelfHideUnreleased" ${shelf.hideUnreleased ? 'checked' : ''} style="margin-right:8px;">
                            <span style="font-size:14px;">Hide Unreleased</span>
                            <span style="font-size:11px;color:#888;margin-left:8px;">(Filter out movies not yet available for home viewing, and upcoming series)</span>
                        </label>
                    </div>
                    <div style="display:flex;gap:12px;justify-content:flex-end;">
                        <button onclick="closeEditShelfModal()" style="padding:8px 16px;background:rgba(255,255,255,0.1);border:none;border-radius:6px;color:white;cursor:pointer;">Cancel</button>
                        <button onclick="saveEditedShelf('${shelfId}')" style="padding:8px 16px;background:#8a2be2;border:none;border-radius:6px;color:white;cursor:pointer;">Save</button>
                    </div>
                </div>
            </div>
        `;

        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Focus the name input
        document.getElementById('editShelfName').focus();

        // Close on escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeEditShelfModal();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);

        // Close on backdrop click
        document.getElementById('editShelfModal').addEventListener('click', (e) => {
            if (e.target.id === 'editShelfModal') {
                closeEditShelfModal();
            }
        });
    }

    function closeEditShelfModal() {
        const modal = document.getElementById('editShelfModal');
        if (modal) modal.remove();
    }

    // Edit trending shelf - simplified modal for hideUnreleased only
    function editTrendingShelf(shelfId) {
        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            ensureProfileShelves();
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        const shelf = shelves.find(s => s.id === shelfId);
        if (!shelf) return;

        const shelfName = shelf.name || (shelfId === 'trending-movies' ? 'Trending Movies' : 'Trending TV Shows');

        // Create modal HTML
        const modalHtml = `
            <div id="editShelfModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:10000;">
                <div style="background:#1a1a2e;border-radius:12px;padding:24px;max-width:400px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,0.5);">
                    <h3 style="margin:0 0 16px 0;font-size:18px;font-weight:600;">${shelfName} - Filter Settings</h3>
                    <div style="margin-bottom:16px;">
                        <label style="display:flex;align-items:flex-start;cursor:pointer;">
                            <input type="checkbox" id="editShelfHideUnreleased" ${shelf.hideUnreleased ? 'checked' : ''} style="margin-right:10px;margin-top:3px;">
                            <div>
                                <span style="font-size:14px;font-weight:500;">Hide Unreleased</span>
                                <p style="font-size:12px;color:#888;margin:4px 0 0 0;">Filter out movies not yet available for home viewing, and series that are upcoming or in production.</p>
                            </div>
                        </label>
                    </div>
                    <div style="display:flex;gap:12px;justify-content:flex-end;">
                        <button onclick="closeEditShelfModal()" style="padding:8px 16px;background:rgba(255,255,255,0.1);border:none;border-radius:6px;color:white;cursor:pointer;">Cancel</button>
                        <button onclick="saveTrendingShelf('${shelfId}')" style="padding:8px 16px;background:#8a2be2;border:none;border-radius:6px;color:white;cursor:pointer;">Save</button>
                    </div>
                </div>
            </div>
        `;

        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Close on escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeEditShelfModal();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);

        // Close on backdrop click
        document.getElementById('editShelfModal').addEventListener('click', (e) => {
            if (e.target.id === 'editShelfModal') {
                closeEditShelfModal();
            }
        });
    }

    function saveTrendingShelf(shelfId) {
        const hideUnreleasedInput = document.getElementById('editShelfHideUnreleased');
        const hideUnreleased = hideUnreleasedInput?.checked || false;

        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        const shelf = shelves.find(s => s.id === shelfId);
        if (!shelf) return;

        shelf.hideUnreleased = hideUnreleased;
        closeEditShelfModal();
        renderSettings();
    }

    function saveEditedShelf(shelfId) {
        const nameInput = document.getElementById('editShelfName');
        const urlInput = document.getElementById('editShelfUrl');
        const limitInput = document.getElementById('editShelfLimit');
        const hideUnreleasedInput = document.getElementById('editShelfHideUnreleased');
        const name = nameInput?.value?.trim();
        let url = urlInput?.value?.trim();
        const limit = parseInt(limitInput?.value || '0', 10) || 0;
        const hideUnreleased = hideUnreleasedInput?.checked || false;

        if (!name || !url) {
            alert('Please enter both a name and URL');
            return;
        }

        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        const shelf = shelves.find(s => s.id === shelfId);
        if (!shelf) return;

        // Validate URL based on existing type
        if (!validateShelfUrl(shelf.type, url)) {
            return;
        }

        // Auto-fix URL based on existing type
        url = fixShelfUrl(shelf.type, url);

        shelf.name = name;
        shelf.listUrl = url;
        shelf.limit = limit;
        shelf.hideUnreleased = hideUnreleased;
        closeEditShelfModal();
        renderSettings();
    }

    // Drag and drop state
    let dragState = null;
    let dragType = null; // 'priority' or 'shelves'

    function initDragDrop() {
        initPriorityDragDrop();
        initShelvesDragDrop();
    }

    function initPriorityDragDrop() {
        const container = document.getElementById('priorityContainer');
        if (!container) return;

        container.addEventListener('touchstart', (e) => handleDragStart(e, 'priority'), {passive: false});
        container.addEventListener('touchmove', handleDragMove, {passive: false});
        container.addEventListener('touchend', handleDragEnd);
        container.addEventListener('mousedown', (e) => handleDragStart(e, 'priority'));
    }

    function initShelvesDragDrop() {
        const container = document.getElementById('shelvesContainer');
        if (!container) return;

        container.addEventListener('touchstart', (e) => handleDragStart(e, 'shelves'), {passive: false});
        container.addEventListener('touchmove', handleDragMove, {passive: false});
        container.addEventListener('touchend', handleDragEnd);
        container.addEventListener('mousedown', (e) => handleDragStart(e, 'shelves'));
    }

    // Shared mouse event listeners (added once)
    let dragListenersAdded = false;
    function ensureDragListeners() {
        if (dragListenersAdded) return;
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
        dragListenersAdded = true;
    }

    function handleDragStart(e, type) {
        const rowClass = type === 'priority' ? '.priority-row' : '.shelf-row';
        const handleClass = type === 'priority' ? '.priority-handle' : '.shelf-handle';
        const row = e.target.closest(rowClass);
        if (!row) return;

        // Only start drag when touching/clicking the drag handle (prevents accidental drag while scrolling on mobile)
        if (!e.target.closest(handleClass)) return;

        // Don't start drag if clicking on interactive elements
        if (e.target.closest('.shelf-toggle') || e.target.closest('.shelf-edit-btn') || e.target.closest('.shelf-delete-btn')) return;

        e.preventDefault();
        ensureDragListeners();

        const touch = e.touches ? e.touches[0] : e;
        const rect = row.getBoundingClientRect();

        dragState = {
            row: row,
            index: parseInt(row.dataset.index),
            startY: touch.clientY,
            offsetY: touch.clientY - rect.top,
            rowHeight: rect.height + 6 // include margin
        };
        dragType = type;

        row.classList.add('dragging');
    }

    function handleDragMove(e) {
        if (!dragState) return;
        e.preventDefault();

        const containerId = dragType === 'priority' ? 'priorityContainer' : 'shelvesContainer';
        const rowClass = dragType === 'priority' ? '.priority-row' : '.shelf-row';

        const touch = e.touches ? e.touches[0] : e;
        const container = document.getElementById(containerId);
        if (!container) return;

        const rows = container.querySelectorAll(rowClass);
        const containerRect = container.getBoundingClientRect();

        // Calculate new position
        const y = touch.clientY - containerRect.top - dragState.offsetY;
        let newIndex = Math.round(y / dragState.rowHeight);
        newIndex = Math.max(0, Math.min(newIndex, rows.length - 1));

        // Update visual feedback
        rows.forEach((r, i) => {
            r.classList.remove('drag-over');
            if (i === newIndex && i !== dragState.index) {
                r.classList.add('drag-over');
            }
        });

        dragState.newIndex = newIndex;
    }

    function handleDragEnd(e) {
        if (!dragState) return;

        const containerId = dragType === 'priority' ? 'priorityContainer' : 'shelvesContainer';
        const rowClass = dragType === 'priority' ? '.priority-row' : '.shelf-row';

        const container = document.getElementById(containerId);
        if (container) {
            const rows = container.querySelectorAll(rowClass);
            rows.forEach(r => r.classList.remove('dragging', 'drag-over'));
        }

        // Perform the reorder if position changed
        if (dragState.newIndex !== undefined && dragState.newIndex !== dragState.index) {
            if (dragType === 'priority') {
                const providers = currentSettings.streaming?.debridProviders || [];
                const [moved] = providers.splice(dragState.index, 1);
                providers.splice(dragState.newIndex, 0, moved);
            } else if (dragType === 'shelves') {
                reorderShelves(dragState.index, dragState.newIndex);
            }
            renderSettings();
        }

        dragState = null;
        dragType = null;
    }

    function reorderShelves(fromIndex, toIndex) {
        const isPerUserSection = perUserSections.includes('homeShelves.shelves');
        let shelves;
        if (selectedUserId && userSettings && isPerUserSection) {
            // Ensure profile has its own shelves before reordering
            ensureProfileShelves();
            shelves = userSettings.homeShelves?.shelves || [];
        } else {
            shelves = currentSettings.homeShelves?.shelves || [];
        }

        // Sort shelves by current order to get display order
        const sortedShelves = [...shelves].sort((a, b) => (a.order || 0) - (b.order || 0));

        // Get the shelf being moved based on display position
        const movedShelf = sortedShelves[fromIndex];
        if (!movedShelf) return;

        // Remove from sorted list and insert at new position
        sortedShelves.splice(fromIndex, 1);
        sortedShelves.splice(toIndex, 0, movedShelf);

        // Update order values based on new positions
        sortedShelves.forEach((shelf, i) => {
            const originalShelf = shelves.find(s => s.id === shelf.id);
            if (originalShelf) {
                originalShelf.order = i;
            }
        });
    }

    function renderObjectSection(sectionKey, sectionDef) {
        // Use getValue for proper three-tier cascade (global → profile → client)
        const fieldsHtml = Object.entries(sectionDef.fields)
            .sort((a, b) => (a[1].order || 0) - (b[1].order || 0))
            .map(([fieldKey, fieldDef]) => {
                const fieldError = getFieldError(sectionKey, fieldKey);
                const invalidClass = fieldError ? ' invalid' : '';
                const errorHtml = fieldError ? '<div class="validation-message"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+fieldError+'</div>' : '';
                const fieldValue = getValue(sectionKey + '.' + fieldKey);
                const fieldPath = sectionKey + '.' + fieldKey;
                const inheritanceBadge = renderInheritanceBadge(fieldPath, fieldDef);
                // Add inheritance class for visual styling when editing profile/client
                const inheritanceInfo = getInheritanceInfo(fieldPath);
                const inheritanceClass = (selectedUserId || selectedClientId)
                    ? (inheritanceInfo.isOverridden ? ' field-overridden' : ' field-inherited')
                    : '';
                return '<div class="form-group'+(fieldDef.type === 'boolean' ? ' form-group-toggle' : '')+invalidClass+inheritanceClass+'"><label class="form-label"><span>'+fieldDef.label+'</span>'+inheritanceBadge+'</label>'+renderInput(fieldKey, fieldDef, fieldValue, sectionKey, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+errorHtml+'</div>';
            }).join('');

        // Add provider priority UI for streaming section
        let customHtml = '';
        if (sectionKey === 'streaming') {
            customHtml = renderProviderPriorityUI();
        }

        // Add test button for testable object sections
        let testHtml = '';
        if (sectionDef.testable) {
            testHtml = '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.75rem;">'+
                '<button id="test-btn-'+sectionKey+'" class="btn btn-secondary" onclick="testObjectSection(\''+sectionKey+'\')">'+
                '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection</button>'+
                '<span id="test-result-'+sectionKey+'" class="test-result"></span></div>';
        }
        return fieldsHtml + customHtml + testHtml;
    }

    // Test object section (non-array sections like subtitles)
    async function testObjectSection(sectionKey) {
        const btn = document.getElementById('test-btn-'+sectionKey);
        const resultSpan = document.getElementById('test-result-'+sectionKey);
        if (!btn) return;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Testing...';
        resultSpan.textContent = '';
        resultSpan.className = 'test-result';

        let endpoint, payload;
        const sectionData = currentSettings[sectionKey] || {};

        switch(sectionKey) {
            case 'subtitles':
                endpoint = '/admin/api/test/subtitles';
                payload = {
                    username: sectionData.openSubtitlesUsername || '',
                    password: sectionData.openSubtitlesPassword || ''
                };
                break;
            default:
                btn.disabled = false;
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection';
                resultSpan.textContent = 'Unknown section';
                resultSpan.className = 'test-result error';
                return;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            btn.disabled = false;
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection';

            if (result.success) {
                resultSpan.textContent = result.message || 'Success';
                resultSpan.className = 'test-result success';
            } else {
                resultSpan.textContent = result.error || 'Test failed';
                resultSpan.className = 'test-result error';
            }
        } catch (e) {
            btn.disabled = false;
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test Connection';
            resultSpan.textContent = 'Error: ' + e.message;
            resultSpan.className = 'test-result error';
        }
    }
    function renderSection(sectionKey, sectionDef) {
        const isOpen = window.location.hash === '#'+sectionKey;
        const errorCount = getSectionErrorCount(sectionKey);
        const sectionMessages = validationErrors[sectionKey]?.messages || [];
        const hasChanges = sectionHasChanges(sectionKey);

        // Check if this section is disabled (coming soon)
        const isDisabled = sectionKey === 'network';
        const disabledClass = isDisabled ? ' disabled' : '';

        // Warning badge for section header
        const warningBadge = errorCount > 0 ? '<span class="section-warning">'+errorCount+'</span>' : '';

        // Save button for section header (only show when section has changes and not a custom section)
        const saveBtn = (hasChanges && !sectionDef.custom && !isDisabled) ? '<button class="section-save-btn" onclick="saveSection(\''+sectionKey+'\', event)" title="Save changes"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg> Save</button>' : '';

        // Section-level validation messages
        let messagesHtml = '';
        if (sectionMessages.length > 0) {
            messagesHtml = sectionMessages.map(msg =>
                '<div class="section-validation-msg"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+msg+'</div>'
            ).join('');
        }

        // Coming soon notice for disabled sections
        let comingSoonHtml = '';
        if (isDisabled) {
            comingSoonHtml = '<div class="section-coming-soon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Coming in app version 1.4.x - Requires native app update</div>';
        }

        // Handle custom sections (like profiles, userAccounts)
        let contentHtml;
        if (sectionDef.custom && sectionKey === 'profiles') {
            contentHtml = renderProfilesSection();
        } else if (sectionDef.custom && sectionKey === 'userAccounts') {
            contentHtml = renderUserAccountsSection();
        } else {
            contentHtml = sectionDef.is_array ? renderArraySection(sectionKey, sectionDef) : '<div class="grid grid-2">'+renderObjectSection(sectionKey, sectionDef)+'</div>';
        }

        // Add clear cache button for cache section
        if (sectionKey === 'cache') {
            contentHtml += '<div class="cache-actions" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);"><button class="btn btn-secondary" id="clear-cache-btn" onclick="clearMetadataCache()"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Clear Metadata Cache</button><p class="form-hint" style="margin-top: 0.5rem;">Remove all cached metadata and posters. Fresh data will be fetched from TVDB/TMDB on next request.</p></div>';
        }
        let nestedHtml = '';
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            // Only render as nested if parent matches AND section doesn't have its own group
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (selectedUserId && !perUserSections.includes(nestedKey)) continue;
                // Use custom shelves UI for home shelves configuration
                const nestedContent = nestedKey === 'homeShelves.shelves' ? renderShelvesOrderUI() : renderArraySection(nestedKey, nestedDef);
                nestedHtml += '<div style="margin-top: 1.5rem;"><h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">'+nestedDef.label+'</h3>'+nestedContent+'</div>';
            }
        }
        return '<div class="section '+(isOpen ? 'open' : '')+(hasChanges ? ' has-changes' : '')+disabledClass+'" id="section-'+sectionKey+'"><div class="section-header" onclick="toggleSection(this)"><div class="section-title">'+getIcon(sectionDef.icon)+sectionDef.label+warningBadge+'</div><div class="section-header-actions">'+saveBtn+'<svg class="section-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></div></div><div class="section-content">'+comingSoonHtml+messagesHtml+contentHtml+nestedHtml+'</div></div>';
    }

    // Profile management functions
    async function loadProfiles() {
        try {
            const response = await fetch(basePath + '/api/profiles');
            if (response.ok) {
                profilesData = await response.json();
            } else {
                console.error('Failed to load profiles');
                profilesData = [];
            }
        } catch (e) {
            console.error('Error loading profiles:', e);
            profilesData = [];
        }
    }

    // Account management functions
    async function loadAccounts() {
        try {
            const response = await fetch(basePath + '/api/accounts');
            if (response.ok) {
                accountsData = await response.json();
            } else {
                console.error('Failed to load accounts');
                accountsData = [];
            }
        } catch (e) {
            console.error('Error loading accounts:', e);
            accountsData = [];
        }
    }

    async function checkDefaultPassword() {
        try {
            const response = await fetch(basePath + '/api/accounts/default-password');
            if (response.ok) {
                const data = await response.json();
                hasDefaultPassword = data.hasDefaultPassword;
            }
        } catch (e) {
            console.error('Error checking default password:', e);
        }
    }

    async function createAccount(username, password) {
        try {
            const response = await fetch(basePath + '/api/accounts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            if (response.ok) {
                const created = await response.json();
                accountsData.push(created);
                showToast('Account created successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to create account', 'error');
            }
        } catch (e) {
            showToast('Error creating account: ' + e.message, 'error');
        }
    }

    async function deleteAccount(accountId) {
        if (!confirm('Delete this account? All associated profiles will be reassigned to the default account.')) {
            return;
        }
        try {
            const response = await fetch(basePath + '/api/accounts?accountId=' + encodeURIComponent(accountId), {
                method: 'DELETE'
            });
            if (response.ok) {
                accountsData = accountsData.filter(a => a.id !== accountId);
                await loadAccounts(); // Reload to get updated profile assignments
                showToast('Account deleted');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to delete account', 'error');
            }
        } catch (e) {
            showToast('Error deleting account: ' + e.message, 'error');
        }
    }

    async function resetAccountPassword(accountId, newPassword) {
        try {
            const response = await fetch(basePath + '/api/accounts/password?accountId=' + encodeURIComponent(accountId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password: newPassword })
            });
            if (response.ok) {
                showToast('Password reset successfully');
                if (accountsData.find(a => a.id === accountId)?.isMaster) {
                    hasDefaultPassword = false;
                }
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to reset password', 'error');
            }
        } catch (e) {
            showToast('Error resetting password: ' + e.message, 'error');
        }
    }

    async function reassignProfile(profileId, newAccountId) {
        try {
            const response = await fetch(basePath + '/api/profiles/reassign?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ accountId: newAccountId })
            });
            if (response.ok) {
                await loadAccounts(); // Reload to get updated assignments
                showToast('Profile reassigned');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to reassign profile', 'error');
            }
        } catch (e) {
            showToast('Error reassigning profile: ' + e.message, 'error');
        }
    }

    function handleCreateAccountSubmit(event) {
        event.preventDefault();
        const usernameInput = document.getElementById('new-account-username');
        const passwordInput = document.getElementById('new-account-password');
        const username = usernameInput.value.trim();
        const password = passwordInput.value;
        if (!username) {
            showToast('Username is required', 'error');
            return;
        }
        if (password.length < 4) {
            showToast('Password must be at least 4 characters', 'error');
            return;
        }
        createAccount(username, password);
        usernameInput.value = '';
        passwordInput.value = '';
        document.getElementById('add-account-form').style.display = 'none';
    }

    function handleResetPasswordSubmit(event, accountId) {
        event.preventDefault();
        const input = document.getElementById('password-input-' + accountId);
        const password = input.value;
        if (password.length < 4) {
            showToast('Password must be at least 4 characters', 'error');
            return;
        }
        resetAccountPassword(accountId, password);
        input.value = '';
    }

    function toggleAddAccountForm() {
        const form = document.getElementById('add-account-form');
        if (form) {
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                const input = document.getElementById('new-account-username');
                if (input) input.focus();
            }
        }
    }

    function togglePasswordResetForm(accountId) {
        const formEl = document.getElementById('password-form-' + accountId);
        if (formEl) {
            const isHidden = formEl.style.display === 'none';
            formEl.style.display = isHidden ? 'flex' : 'none';
            if (isHidden) {
                const input = document.getElementById('password-input-' + accountId);
                if (input) input.focus();
            }
        }
    }

    function renderUserAccountsSection() {
        // Show warning if admin has default password
        let warningHtml = '';
        if (hasDefaultPassword) {
            warningHtml = '<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger, #ef4444); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;">' +
                '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--danger, #ef4444)" stroke-width="2" style="flex-shrink: 0;">' +
                '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>' +
                '<line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>' +
                '<div><strong style="color: var(--danger, #ef4444);">Security Warning</strong>' +
                '<p style="margin: 0.25rem 0 0; color: var(--text-secondary); font-size: 0.875rem;">The admin account is using the default password. Please change it immediately.</p></div></div>';
        }

        const accountsHtml = accountsData.map(account => {
            const isMaster = account.isMaster;
            const profileCount = (account.profiles || []).length;
            const initial = (account.username || 'A').charAt(0).toUpperCase();

            // Render profiles for this account
            const profilesListHtml = (account.profiles || []).map(profile => {
                const avatarColor = profile.color || '#3B82F6';
                const profileInitial = (profile.name || 'P').charAt(0).toUpperCase();

                // Account selector for reassignment
                const accountOptions = accountsData.map(a =>
                    '<option value="' + a.id + '"' + (a.id === account.id ? ' selected' : '') + '>' +
                    a.username + (a.isMaster ? ' (Master)' : '') + '</option>'
                ).join('');

                return '<div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: var(--bg-primary); border-radius: 6px;">' +
                    '<div style="width: 28px; height: 28px; border-radius: 50%; background: ' + avatarColor + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.75rem; flex-shrink: 0;">' + profileInitial + '</div>' +
                    '<span style="flex: 1; font-size: 0.875rem;">' + profile.name + '</span>' +
                    '<select class="form-select" style="width: 150px; padding: 0.25rem 0.5rem; font-size: 0.75rem;" onchange="reassignProfile(\'' + profile.id + '\', this.value)">' + accountOptions + '</select>' +
                    '</div>';
            }).join('');

            const profilesSection = profileCount > 0
                ? '<div style="margin-top: 0.75rem;"><div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">Profiles (' + profileCount + ')</div><div style="display: flex; flex-direction: column; gap: 0.5rem;">' + profilesListHtml + '</div></div>'
                : '<div style="margin-top: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">No profiles assigned</div>';

            const deleteBtn = !isMaster
                ? '<button class="btn btn-sm btn-icon btn-danger" onclick="deleteAccount(\'' + account.id + '\')" title="Delete account">' + icons.trash + '</button>'
                : '<button class="btn btn-sm btn-icon" disabled title="Cannot delete master account" style="opacity: 0.5; cursor: not-allowed;">' + icons.trash + '</button>';

            const masterBadge = isMaster ? '<span style="background: var(--accent); color: white; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 500; margin-left: 0.5rem;">Master</span>' : '';

            return '<div class="array-item">' +
                '<div class="array-item-header" style="flex-wrap: wrap; gap: 0.75rem;">' +
                '<div class="array-item-title" style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 200px;">' +
                '<div style="width: 40px; height: 40px; border-radius: 50%; background: ' + (isMaster ? 'var(--accent)' : '#6B7280') + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 1.125rem; flex-shrink: 0;">' + initial + '</div>' +
                '<div style="flex: 1;">' +
                '<div style="font-weight: 600;">' + account.username + masterBadge + '</div>' +
                '</div>' +
                '</div>' +
                '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                '<button class="btn btn-sm" onclick="togglePasswordResetForm(\'' + account.id + '\')" title="Reset password">' + icons.key + ' Reset Password</button>' +
                deleteBtn +
                '</div>' +
                '</div>' +
                '<div style="padding: 0 1rem 1rem;">' +
                '<form id="password-form-' + account.id + '" onsubmit="handleResetPasswordSubmit(event, \'' + account.id + '\')" style="display: none; gap: 0.5rem; align-items: center; margin-bottom: 0.75rem;">' +
                '<input type="password" id="password-input-' + account.id + '" class="form-input" placeholder="New password" style="width: 200px;">' +
                '<button type="submit" class="btn btn-sm btn-primary">Set</button>' +
                '<button type="button" class="btn btn-sm" onclick="togglePasswordResetForm(\'' + account.id + '\')">Cancel</button>' +
                '</form>' +
                profilesSection +
                '</div>' +
                '</div>';
        }).join('');

        const addButton = '<button class="btn btn-primary" onclick="toggleAddAccountForm()" style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">' +
            icons.plus + ' Add Account</button>';

        const addAccountForm = '<div id="add-account-form" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">' +
            '<form onsubmit="handleCreateAccountSubmit(event)">' +
            '<div style="margin-bottom: 1rem;">' +
            '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Username</label>' +
            '<input type="text" id="new-account-username" class="form-input" placeholder="Enter username" style="width: 100%;">' +
            '</div>' +
            '<div style="margin-bottom: 1rem;">' +
            '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Password</label>' +
            '<input type="password" id="new-account-password" class="form-input" placeholder="Enter password" style="width: 100%;">' +
            '</div>' +
            '<div style="display: flex; gap: 0.5rem;">' +
            '<button type="submit" class="btn btn-sm btn-primary">Create Account</button>' +
            '<button type="button" class="btn btn-sm" onclick="toggleAddAccountForm()">Cancel</button>' +
            '</div>' +
            '</form>' +
            '</div>';

        return warningHtml + '<div class="array-items">' + accountsHtml + '</div>' + addButton + addAccountForm;
    }

    async function setProfilePin(profileId, pin) {
        try {
            const response = await fetch(basePath + '/api/profiles/pin?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pin: pin })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('PIN set successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to set PIN', 'error');
            }
        } catch (e) {
            showToast('Error setting PIN: ' + e.message, 'error');
        }
    }

    async function clearProfilePin(profileId) {
        try {
            const response = await fetch(basePath + '/api/profiles/pin?profileId=' + encodeURIComponent(profileId), {
                method: 'DELETE'
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('PIN removed successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to remove PIN', 'error');
            }
        } catch (e) {
            showToast('Error removing PIN: ' + e.message, 'error');
        }
    }

    // Profile colors matching the mobile app
    const profileColors = [
        { name: 'Blue', value: '#3B82F6' },
        { name: 'Purple', value: '#8B5CF6' },
        { name: 'Pink', value: '#EC4899' },
        { name: 'Red', value: '#EF4444' },
        { name: 'Orange', value: '#F97316' },
        { name: 'Yellow', value: '#EAB308' },
        { name: 'Green', value: '#22C55E' },
        { name: 'Teal', value: '#14B8A6' },
    ];

    async function createProfile(name, color) {
        try {
            const response = await fetch(basePath + '/api/profiles', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name, color: color })
            });
            if (response.ok) {
                const created = await response.json();
                profilesData.push(created);
                showToast('Profile created successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to create profile', 'error');
            }
        } catch (e) {
            showToast('Error creating profile: ' + e.message, 'error');
        }
    }

    async function renameProfile(profileId, newName) {
        try {
            const response = await fetch(basePath + '/api/profiles?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('Profile renamed successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to rename profile', 'error');
            }
        } catch (e) {
            showToast('Error renaming profile: ' + e.message, 'error');
        }
    }

    async function deleteProfile(profileId) {
        if (!confirm('Delete this profile? This action cannot be undone.')) {
            return;
        }
        try {
            const response = await fetch(basePath + '/api/profiles?profileId=' + encodeURIComponent(profileId), {
                method: 'DELETE'
            });
            if (response.ok) {
                profilesData = profilesData.filter(p => p.id !== profileId);
                showToast('Profile deleted successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to delete profile', 'error');
            }
        } catch (e) {
            showToast('Error deleting profile: ' + e.message, 'error');
        }
    }

    async function setProfileColor(profileId, color) {
        try {
            const response = await fetch(basePath + '/api/profiles/color?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ color: color })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('Color updated');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to update color', 'error');
            }
        } catch (e) {
            showToast('Error updating color: ' + e.message, 'error');
        }
    }

    async function setKidsProfile(profileId, isKids) {
        try {
            const response = await fetch(basePath + '/api/profiles/kids?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ isKidsProfile: isKids })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast(isKids ? 'Kids profile enabled' : 'Kids profile disabled');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to update kids profile setting', 'error');
            }
        } catch (e) {
            showToast('Error updating kids profile: ' + e.message, 'error');
        }
    }

    function customizeKidsProfile(profileId) {
        // Placeholder for kids profile customization
        // This will be implemented later with content restrictions, etc.
        showToast('Kids profile customization coming soon!', 'info');
    }

    function handleCreateProfileSubmit(event) {
        event.preventDefault();
        const nameInput = document.getElementById('new-profile-name');
        const colorInput = document.querySelector('input[name="new-profile-color"]:checked');
        const name = nameInput.value.trim();
        if (!name) {
            showToast('Profile name is required', 'error');
            return;
        }
        const color = colorInput ? colorInput.value : profileColors[0].value;
        createProfile(name, color);
        nameInput.value = '';
    }

    function handleRenameProfileSubmit(event, profileId) {
        event.preventDefault();
        const input = document.getElementById('rename-input-' + profileId);
        const newName = input.value.trim();
        if (!newName) {
            showToast('Profile name is required', 'error');
            return;
        }
        renameProfile(profileId, newName);
    }

    function toggleRenameForm(profileId) {
        const formEl = document.getElementById('rename-form-' + profileId);
        const displayEl = document.getElementById('name-display-' + profileId);
        if (formEl && displayEl) {
            const isEditing = formEl.style.display !== 'none';
            formEl.style.display = isEditing ? 'none' : 'flex';
            displayEl.style.display = isEditing ? 'block' : 'none';
            if (!isEditing) {
                const input = document.getElementById('rename-input-' + profileId);
                if (input) input.focus();
            }
        }
    }

    function toggleAddProfileForm() {
        const form = document.getElementById('add-profile-form');
        if (form) {
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                const input = document.getElementById('new-profile-name');
                if (input) input.focus();
            }
        }
    }

    async function clearMetadataCache() {
        const btn = document.getElementById('clear-cache-btn');
        if (!btn) return;

        if (!confirm('Clear all cached metadata and posters? This will force fresh data to be fetched from TVDB/TMDB.')) {
            return;
        }

        const originalHtml = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Clearing...';

        try {
            const response = await fetch(basePath + '/api/cache/clear', {
                method: 'POST'
            });
            const result = await response.json();
            if (response.ok) {
                showToast('Metadata cache cleared successfully');
            } else {
                showToast(result.error || 'Failed to clear cache', 'error');
            }
        } catch (e) {
            showToast('Error clearing cache: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        }
    }

    function handlePinFormSubmit(event, profileId) {
        event.preventDefault();
        const input = document.getElementById('pin-input-' + profileId);
        const pin = input.value.trim();
        if (pin.length < 4) {
            showToast('PIN must be at least 4 characters', 'error');
            return;
        }
        setProfilePin(profileId, pin);
        input.value = '';
    }

    function renderProfilesSection() {
        const canDelete = profilesData.length > 1;

        // Render color picker dots
        function renderColorPicker(profileId, currentColor) {
            return '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">' +
                profileColors.map(c => {
                    const isSelected = c.value === currentColor;
                    const border = isSelected ? '2px solid white' : '2px solid transparent';
                    const boxShadow = isSelected ? '0 0 0 2px var(--accent)' : 'none';
                    return '<button type="button" onclick="setProfileColor(\'' + profileId + '\', \'' + c.value + '\')" ' +
                        'style="width: 24px; height: 24px; border-radius: 50%; background: ' + c.value + '; border: ' + border + '; box-shadow: ' + boxShadow + '; cursor: pointer; padding: 0;" ' +
                        'title="' + c.name + '"></button>';
                }).join('') +
                '</div>';
        }

        // Render the add profile form
        function renderAddProfileForm() {
            return '<div id="add-profile-form" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">' +
                '<form onsubmit="handleCreateProfileSubmit(event)">' +
                '<div style="margin-bottom: 1rem;">' +
                '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Profile Name</label>' +
                '<input type="text" id="new-profile-name" class="form-input" placeholder="Enter profile name" style="width: 100%;">' +
                '</div>' +
                '<div style="margin-bottom: 1rem;">' +
                '<label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">Color</label>' +
                '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">' +
                profileColors.map((c, i) => {
                    const checked = i === 0 ? ' checked' : '';
                    return '<label style="cursor: pointer;">' +
                        '<input type="radio" name="new-profile-color" value="' + c.value + '"' + checked + ' style="display: none;">' +
                        '<span style="display: block; width: 32px; height: 32px; border-radius: 50%; background: ' + c.value + '; border: 2px solid transparent;" ' +
                        'class="color-option" title="' + c.name + '"></span>' +
                        '</label>';
                }).join('') +
                '</div>' +
                '</div>' +
                '<div style="display: flex; gap: 0.5rem;">' +
                '<button type="submit" class="btn btn-sm btn-primary">Create Profile</button>' +
                '<button type="button" class="btn btn-sm" onclick="toggleAddProfileForm()">Cancel</button>' +
                '</div>' +
                '</form>' +
                '</div>';
        }

        const profilesHtml = profilesData.map(profile => {
            const avatarColor = profile.color || '#3B82F6';
            const initial = (profile.name || 'U').charAt(0).toUpperCase();
            const pinStatus = profile.hasPin
                ? '<span style="display: inline-flex; align-items: center; gap: 0.25rem; color: var(--success); font-size: 0.875rem;">' + icons.lock + ' PIN Protected</span>'
                : '<span style="display: inline-flex; align-items: center; gap: 0.25rem; color: var(--text-secondary); font-size: 0.875rem;">' + icons.unlock + ' No PIN</span>';

            const pinActions = profile.hasPin
                ? '<button class="btn btn-sm btn-danger" onclick="if(confirm(\'Remove PIN from this profile?\')) clearProfilePin(\'' + profile.id + '\')">Remove PIN</button>'
                : '<form onsubmit="handlePinFormSubmit(event, \'' + profile.id + '\')" style="display: flex; gap: 0.5rem; align-items: center;">' +
                  '<input type="password" id="pin-input-' + profile.id + '" class="form-input" placeholder="Enter PIN" style="width: 120px;">' +
                  '<button type="submit" class="btn btn-sm btn-primary">Set PIN</button>' +
                  '</form>';

            const deleteBtn = canDelete
                ? '<button class="btn btn-sm btn-icon btn-danger" onclick="deleteProfile(\'' + profile.id + '\')" title="Delete profile">' + icons.trash + '</button>'
                : '<button class="btn btn-sm btn-icon" disabled title="Cannot delete last profile" style="opacity: 0.5; cursor: not-allowed;">' + icons.trash + '</button>';

            const kidsToggle = '<label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">' +
                '<input type="checkbox" ' + (profile.isKidsProfile ? 'checked' : '') + ' onchange="setKidsProfile(\'' + profile.id + '\', this.checked)" style="width: 16px; height: 16px;">' +
                '<span style="font-size: 0.875rem;">This is a kids profile</span>' +
                '</label>';

            const kidsCustomizeBtn = profile.isKidsProfile
                ? '<button class="btn btn-sm btn-primary" onclick="customizeKidsProfile(\'' + profile.id + '\')" style="margin-top: 0.5rem;">Customize Kids Settings</button>'
                : '';

            return '<div class="array-item">' +
                '<div class="array-item-header profile-header" style="flex-wrap: wrap; gap: 0.75rem;">' +
                '<div class="array-item-title" style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 200px;">' +
                '<div style="width: 40px; height: 40px; border-radius: 50%; background: ' + avatarColor + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 1.125rem; flex-shrink: 0;">' + initial + '</div>' +
                '<div style="flex: 1;">' +
                '<div id="name-display-' + profile.id + '" style="font-weight: 600;">' + profile.name + (profile.isKidsProfile ? ' <span style="background: var(--accent); color: white; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 500;">Kids</span>' : '') + '</div>' +
                '<form id="rename-form-' + profile.id + '" onsubmit="handleRenameProfileSubmit(event, \'' + profile.id + '\')" style="display: none; gap: 0.5rem; align-items: center;">' +
                '<input type="text" id="rename-input-' + profile.id + '" class="form-input" value="' + profile.name + '" style="width: 150px; padding: 0.25rem 0.5rem;">' +
                '<button type="submit" class="btn btn-sm btn-icon btn-primary" title="Save">' + icons.check + '</button>' +
                '<button type="button" class="btn btn-sm btn-icon" onclick="toggleRenameForm(\'' + profile.id + '\')" title="Cancel">' + icons.x + '</button>' +
                '</form>' +
                '<div style="font-size: 0.75rem; color: var(--text-secondary);">ID: ' + profile.id + '</div>' +
                '</div>' +
                '</div>' +
                '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                '<button class="btn btn-sm btn-icon" onclick="toggleRenameForm(\'' + profile.id + '\')" title="Rename profile">' + icons.edit + '</button>' +
                deleteBtn +
                '</div>' +
                '</div>' +
                '<div style="padding: 0 1rem 1rem; display: grid; gap: 1rem;">' +
                '<div>' +
                '<div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">Color</div>' +
                renderColorPicker(profile.id, avatarColor) +
                '</div>' +
                '<div>' +
                '<div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">PIN Protection</div>' +
                '<div style="margin-bottom: 0.5rem;">' + pinStatus + '</div>' +
                '<div>' + pinActions + '</div>' +
                '</div>' +
                '<div>' +
                '<div style="font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem;">Kids Profile</div>' +
                '<div>' + kidsToggle + kidsCustomizeBtn + '</div>' +
                '</div>' +
                '</div>' +
                '</div>';
        }).join('');

        const addButton = '<button class="btn btn-primary" onclick="toggleAddProfileForm()" style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">' +
            icons.plus + ' Add Profile</button>';

        return '<div class="array-items">' + profilesHtml + '</div>' + addButton + renderAddProfileForm();
    }

    function renderSettings() {
        const container = document.getElementById('settingsContainer');

        // Run validation before rendering
        validationErrors = validateSettings();

        // Save currently open sections before re-rendering
        const openSections = new Set();
        container.querySelectorAll('.section.open').forEach(section => {
            const id = section.id.replace('section-', '');
            if (id) openSections.add(id);
        });

        // Add info banner when user or client is selected
        let bannerHtml = '';
        if (selectedClientId) {
            const client = clientsForUser.find(c => c.id === selectedClientId);
            const clientName = client ? client.name : selectedClientId;
            bannerHtml = '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;"><div style="display: flex; align-items: center; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#8b5cf6" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg><span>Editing device-specific settings for <strong>' + clientName + '</strong></span></div><p style="margin: 0.5rem 0 0; font-size: 0.8rem; color: var(--text-muted);">Fields show <span class="inheritance-badge overridden" style="font-size: 0.6rem;">Device</span> when overridden here, or <span class="inheritance-badge inherited" style="font-size: 0.6rem;">From Profile</span> / <span class="inheritance-badge inherited" style="font-size: 0.6rem;">From Global</span> when inherited. Click ↩ to reset an override.</p></div>';
        } else if (selectedUserId) {
            bannerHtml = '<div style="background: var(--accent-bg, #2563eb20); border: 1px solid var(--accent, #2563eb); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;"><div style="display: flex; align-items: center; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--accent, #2563eb)" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg><span>Editing profile-specific settings</span></div><p style="margin: 0.5rem 0 0; font-size: 0.8rem; color: var(--text-muted);">Fields show <span class="inheritance-badge overridden" style="font-size: 0.6rem;">Profile</span> when overridden here, or <span class="inheritance-badge inherited" style="font-size: 0.6rem;">From Global</span> when using the default. Click ↩ to reset an override.</p></div>';
        }

        // Add validation warning banner if there are issues
        const totalErrors = Object.keys(validationErrors).length;
        if (totalErrors > 0 && !selectedUserId) {
            const errorSections = Object.keys(validationErrors).map(key => {
                const sectionDef = schema[key];
                return sectionDef?.label || key;
            }).join(', ');
            bannerHtml += '<div style="background: rgba(234, 179, 8, 0.1); border: 1px solid var(--warning, #eab308); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--warning, #eab308)" stroke-width="2" style="flex-shrink: 0; margin-top: 2px;"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><div><strong style="color: var(--warning, #eab308);">Configuration warning</strong><p style="margin: 0.25rem 0 0; color: var(--text-secondary); font-size: 0.875rem;">Some recommended settings may be incomplete. Issues found in: '+errorSections+'</p></div></div>';
        }

        // Render sections grouped by their group property
        // Sections with their own group are shown at top level, even if they have a parent (for data access)
        let html = bannerHtml;

        // Sections that can be configured per-client (subset of perUserSections)
        const clientSections = ['filtering', 'network'];

        for (const group of groups) {
            const groupSections = Object.entries(schema).filter(([key, def]) => {
                if (def.group !== group.id) return false;
                // If a client is selected, only show client-configurable sections
                if (selectedClientId && !clientSections.includes(key)) return false;
                // If a user is selected (but not client), show per-user sections
                if (selectedUserId && !selectedClientId && !perUserSections.includes(key)) return false;
                return true;
            }).sort((a, b) => (a[1].order ?? 999) - (b[1].order ?? 999));

            if (groupSections.length === 0) continue;

            html += '<div class="settings-group"><h2 class="group-title">'+group.label+'</h2><div class="group-sections">'+groupSections.map(([key, def]) => renderSection(key, def)).join('')+'</div></div>';
        }

        container.innerHTML = html;

        // Restore previously open sections
        openSections.forEach(sectionKey => {
            const section = document.getElementById('section-'+sectionKey);
            if (section) section.classList.add('open');
        });

        if (window.location.hash) {
            const section = document.getElementById('section-'+window.location.hash.substring(1));
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }

        // Initialize drag-drop for provider priority and shelves
        initDragDrop();
    }
    async function saveAllSettings() {
        try {
            if (selectedClientId && clientSettings !== null) {
                // Save client-specific settings
                const response = await fetch(basePath + '/api/clients/' + encodeURIComponent(selectedClientId) + '/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(clientSettings)
                });
                if (response.ok) {
                    originalClientSettings = JSON.parse(JSON.stringify(clientSettings));
                    showToast('Client settings saved successfully');
                    // Update client override indicator
                    const hasOverrides = Object.keys(clientSettings).some(k => clientSettings[k] !== undefined && clientSettings[k] !== null);
                    const clientInList = clientsForUser.find(c => c.id === selectedClientId);
                    if (clientInList) clientInList.hasOverrides = hasOverrides;
                    updateClientDropdownIndicators();
                    updateRevertButtonVisibility();
                } else {
                    const result = await response.json().catch(() => ({}));
                    showToast(result.error || 'Failed to save client settings', 'error');
                }
            } else if (selectedUserId && userSettings) {
                // Save user-specific settings (strip values matching global to keep as inherited)
                const strippedSettings = stripInheritedValues(userSettings, currentSettings);
                const response = await fetch(basePath + '/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(strippedSettings)
                });
                if (response.ok) {
                    // Update local state with stripped values
                    userSettings = strippedSettings;
                    originalUserSettings = JSON.parse(JSON.stringify(strippedSettings));
                    showToast('User settings saved successfully');
                    // Recalculate override status from actual values to ensure consistency
                    recalculateUserOverrides(selectedUserId);
                    updateUserDropdownIndicators();
                    updateClientDropdownIndicators(); // Update "Profile Defaults" indicator
                    updateRevertButtonVisibility();
                    renderSettings(); // Re-render to update inherited field styling
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save user settings', 'error');
                }
            } else {
                // Save global settings
                const response = await fetch(basePath + '/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    showToast('Settings saved successfully');
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                }
            }
        } catch (e) { showToast('Failed to save settings: ' + e.message, 'error'); }
    }
    function resetSettings() {
        if (confirm('Reset all changes? This will revert to the last saved settings.')) {
            if (selectedClientId && originalClientSettings !== null) {
                clientSettings = JSON.parse(JSON.stringify(originalClientSettings));
            } else if (selectedUserId && originalUserSettings) {
                userSettings = JSON.parse(JSON.stringify(originalUserSettings));
            } else {
                currentSettings = JSON.parse(JSON.stringify(originalSettings));
            }
            renderSettings();
            showToast('Settings reset to last saved state');
        }
    }
    document.addEventListener('DOMContentLoaded', async () => {
        if (isAdmin) {
            await Promise.all([loadProfiles(), loadAccounts(), checkDefaultPassword()]);
            // Check if browser restored a selected user (form state restoration)
            const selector = document.getElementById('userSelector');
            if (selector && selector.value) {
                await handleUserChange(selector.value);
                return; // handleUserChange will call renderSettings
            }
            // Recalculate all user overrides on initial load (compare actual values to global)
            // This fixes the indicator showing for profiles with saved settings that match global
            await recalculateAllUserOverrides();
        } else {
            await loadProfiles();
            // For non-admin, auto-select the first profile
            const selector = document.getElementById('userSelector');
            if (selector && selector.options.length > 0) {
                selectedUserId = selector.options[0].value;
                selector.value = selectedUserId;
                await handleUserChange(selectedUserId);
                return; // handleUserChange will call renderSettings
            }
        }
        renderSettings();
    });
    window.addEventListener('hashchange', () => {
        const hash = window.location.hash.substring(1);
        if (hash) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('open'));
            const section = document.getElementById('section-'+hash);
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    });
</script>
{{end}}
{{end}}
