{{template "base" .}}

{{define "title"}}Settings - strmr Admin{{end}}

{{define "content"}}
<div class="page-header" style="display: flex; align-items: center; justify-content: space-between;">
    <div>
        <h1>Settings</h1>
        <p>Configure your strmr server</p>
    </div>
    <div style="display: flex; gap: 0.5rem; align-items: center;">
        <select id="userSelector" class="form-select" style="min-width: 180px;" onchange="handleUserChange(this.value)">
            <option value="">Global Defaults</option>
            {{range .Users}}
            <option value="{{.ID}}">{{.Name}}</option>
            {{end}}
        </select>
        <button class="btn btn-primary" onclick="saveAllSettings()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save
        </button>
    </div>
</div>

<div id="settingsContainer">
    <div style="display: flex; align-items: center; justify-content: center; padding: 2rem;">
        <div class="spinner"></div>
    </div>
</div>
{{end}}

{{define "scripts"}}
<script>
    let currentSettings = {{json .Settings}};
    let schema = {{json .Schema}};
    let groups = {{json .Groups}};
    let originalSettings = JSON.parse(JSON.stringify(currentSettings));
    let selectedUserId = '';
    let userSettings = null;
    let originalUserSettings = null;

    // Sections that are per-user (when a user is selected, only show these)
    // Note: liveTV settings (favorites, hidden channels) are managed in-app, not via this UI
    const perUserSections = ['playback', 'homeShelves', 'homeShelves.shelves', 'filtering', 'liveTV'];

    // Validation state - stores errors by section and field
    let validationErrors = {};

    // Check if a value is empty/missing
    function isEmpty(val) {
        if (val === undefined || val === null) return true;
        if (typeof val === 'string') return val.trim() === '';
        if (typeof val === 'number') return false; // 0 is valid for numbers
        if (Array.isArray(val)) return val.length === 0;
        return false;
    }

    // Check if an array has at least one enabled item
    function hasEnabledItem(arr) {
        if (!Array.isArray(arr)) return false;
        return arr.some(item => item.enabled === true);
    }

    // Validate all settings and return errors object
    function validateSettings() {
        const errors = {};

        // Skip validation for user-specific settings
        if (selectedUserId) return errors;

        const serviceMode = currentSettings.streaming?.serviceMode || 'debrid';
        const needsDebrid = serviceMode === 'debrid' || serviceMode === 'hybrid';
        const needsUsenet = serviceMode === 'usenet' || serviceMode === 'hybrid';

        // Server Settings - all required
        const serverErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.server?.host)) serverErrors.fields.host = 'Host is required';
        if (isEmpty(currentSettings.server?.port) && currentSettings.server?.port !== 0) serverErrors.fields.port = 'Port is required';
        if (isEmpty(currentSettings.server?.pin)) serverErrors.fields.pin = 'PIN is required';
        if (Object.keys(serverErrors.fields).length > 0) errors.server = serverErrors;

        // Streaming - all required
        const streamingErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.streaming?.serviceMode)) streamingErrors.fields.serviceMode = 'Service mode is required';
        if (Object.keys(streamingErrors.fields).length > 0) errors.streaming = streamingErrors;

        // Debrid Providers - at least one enabled if debrid/hybrid mode
        if (needsDebrid) {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                errors.debridProviders = {
                    fields: {},
                    messages: ['At least one enabled debrid provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Usenet Providers - at least one enabled if usenet/hybrid mode
        if (needsUsenet) {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                errors.usenet = {
                    fields: {},
                    messages: ['At least one enabled usenet provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Content Filtering - if service priority selected, must have enabled provider of that type
        const servicePriority = currentSettings.filtering?.servicePriority;
        if (servicePriority === 'usenet') {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                if (!errors.filtering) errors.filtering = { fields: {}, messages: [] };
                errors.filtering.fields.servicePriority = 'Usenet priority requires an enabled usenet provider';
            }
        } else if (servicePriority === 'debrid') {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                if (!errors.filtering) errors.filtering = { fields: {}, messages: [] };
                errors.filtering.fields.servicePriority = 'Debrid priority requires an enabled debrid provider';
            }
        }

        // Indexers - required if usenet/hybrid mode
        if (needsUsenet) {
            const indexers = currentSettings.indexers || [];
            if (!hasEnabledItem(indexers)) {
                errors.indexers = {
                    fields: {},
                    messages: ['At least one enabled indexer is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Torrent Scrapers - required if debrid/hybrid mode
        if (needsDebrid) {
            const scrapers = currentSettings.torrentScrapers || [];
            if (!hasEnabledItem(scrapers)) {
                errors.torrentScrapers = {
                    fields: {},
                    messages: ['At least one enabled scraper is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Metadata - all required
        const metadataErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.metadata?.tvdbApiKey)) metadataErrors.fields.tvdbApiKey = 'TVDB API Key is required';
        if (isEmpty(currentSettings.metadata?.tmdbApiKey)) metadataErrors.fields.tmdbApiKey = 'TMDB API Key is required';
        if (Object.keys(metadataErrors.fields).length > 0) errors.metadata = metadataErrors;

        // Cache - all required
        const cacheErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.cache?.directory)) cacheErrors.fields.directory = 'Cache directory is required';
        if (Object.keys(cacheErrors.fields).length > 0) errors.cache = cacheErrors;

        // Import Settings - all required (numbers can be 0, so just check existence)
        const importErrors = { fields: {}, messages: [] };
        if (currentSettings.import?.rarMaxWorkers === undefined) importErrors.fields.rarMaxWorkers = 'RAR Max Workers is required';
        if (currentSettings.import?.rarMaxCacheSizeMb === undefined) importErrors.fields.rarMaxCacheSizeMb = 'RAR Cache Size is required';
        if (currentSettings.import?.rarMaxMemoryGB === undefined) importErrors.fields.rarMaxMemoryGB = 'RAR Max Memory is required';
        if (Object.keys(importErrors.fields).length > 0) errors.import = importErrors;

        return errors;
    }

    // Get error count for a section
    function getSectionErrorCount(sectionKey) {
        const sectionErrors = validationErrors[sectionKey];
        if (!sectionErrors) return 0;
        const fieldCount = Object.keys(sectionErrors.fields || {}).length;
        const msgCount = (sectionErrors.messages || []).length;
        return fieldCount + msgCount;
    }

    // Check if a specific field has an error
    function getFieldError(sectionKey, fieldKey) {
        return validationErrors[sectionKey]?.fields?.[fieldKey] || null;
    }

    async function handleUserChange(userId) {
        selectedUserId = userId;
        if (userId) {
            // Load user-specific settings
            try {
                const response = await fetch('/admin/api/user-settings?userId=' + encodeURIComponent(userId));
                if (response.ok) {
                    userSettings = await response.json();
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                } else {
                    showToast('Failed to load user settings', 'error');
                    userSettings = null;
                    originalUserSettings = null;
                }
            } catch (e) {
                showToast('Failed to load user settings: ' + e.message, 'error');
                userSettings = null;
                originalUserSettings = null;
            }
        } else {
            userSettings = null;
            originalUserSettings = null;
        }
        renderSettings();
    }

    const icons = {
        'server': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>',
        'download': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>',
        'search': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        'magnet': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><path d="M22 7l-10 7L2 7"/></svg>',
        'film': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/></svg>',
        'database': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>',
        'folder': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
        'play-circle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>',
        'cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
        'upload': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>',
        'download-cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="8 17 12 21 16 17"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"/></svg>',
        'shuffle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>',
        'play': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>',
        'tv': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>',
        'layout': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>',
        'list': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        'filter': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>',
        'monitor': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>',
    };

    function getIcon(name) { return icons[name] || icons['server']; }

    // Map section keys to user settings structure
    function mapToUserSettingsPath(path) {
        // homeShelves.shelves.0.enabled -> homeShelves.shelves.0.enabled (same)
        // playback.preferredPlayer -> playback.preferredPlayer (same)
        // filtering.maxSizeMovieGb -> filtering.maxSizeMovieGb (same)
        return path;
    }

    function getValue(path) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If user selected and this is a per-user section, use userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let val = userSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return undefined;
                val = val[key];
            }
            return val;
        }

        // Otherwise use global settings
        let val = currentSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return undefined;
            val = val[key];
        }
        return val;
    }
    function setValue(path, value) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If user selected and this is a per-user section, update userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let obj = userSettings;
            for (let i = 0; i < keys.length - 1; i++) {
                if (obj[keys[i]] === undefined) obj[keys[i]] = {};
                obj = obj[keys[i]];
            }
            obj[keys[keys.length - 1]] = value;
            return;
        }

        // Otherwise update global settings
        let obj = currentSettings;
        for (let i = 0; i < keys.length - 1; i++) {
            if (obj[keys[i]] === undefined) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
    }
    function renderInput(fieldKey, fieldDef, value, basePath, sectionKey) {
        const id = (basePath + '_' + fieldKey).replace(/\./g, '_');
        const isReadonly = fieldDef.readonly ? 'readonly' : '';
        const fieldError = getFieldError(sectionKey, fieldKey);
        const invalidClass = fieldError ? ' invalid' : '';
        switch (fieldDef.type) {
            case 'boolean':
                return '<label class="toggle"><input type="checkbox" id="'+id+'" '+(value ? 'checked' : '')+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.checked)"><span class="toggle-slider"></span></label>';
            case 'select':
                const options = fieldDef.options.map(opt => '<option value="'+opt+'" '+(value === opt ? 'selected' : '')+'>'+opt+'</option>').join('');
                return '<select class="form-select'+invalidClass+'" id="'+id+'" onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">'+options+'</select>';
            case 'number':
                return '<input type="number" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || 0)+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', parseFloat(this.value) || 0)">';
            case 'password':
                return '<input type="password" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
            case 'tags':
                const tags = Array.isArray(value) ? value : [];
                const tagsHtml = tags.map(tag => '<span class="tag">'+tag+'<span class="tag-remove" onclick="removeTag(\''+basePath+'\', \''+fieldKey+'\', \''+tag+'\')">&times;</span></span>').join('');
                return '<div class="tags-input'+invalidClass+'" id="'+id+'_container">'+tagsHtml+'<input type="text" placeholder="Add tag..." onkeydown="handleTagInput(event, \''+basePath+'\', \''+fieldKey+'\')"></div>';
            default:
                return '<input type="text" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
        }
    }
    function handleFieldChange(basePath, fieldKey, value) {
        setValue(basePath ? basePath+'.'+fieldKey : fieldKey, value);
        // Re-render to update validation indicators (renderSettings runs validation)
        renderSettings();
    }
    function handleTagInput(event, basePath, fieldKey) {
        if (event.key === 'Enter' || event.key === ',') {
            event.preventDefault();
            const tag = event.target.value.trim();
            if (tag) { addTag(basePath, fieldKey, tag); event.target.value = ''; }
        }
    }
    function addTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = getValue(fullPath) || [];
        if (!tags.includes(tag)) { tags.push(tag); setValue(fullPath, tags); renderSettings(); }
    }
    function removeTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = (getValue(fullPath) || []).filter(t => t !== tag);
        setValue(fullPath, tags);
        renderSettings();
    }
    function addArrayItem(sectionKey) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr;
        if (sectionDef.parent) {
            if (!targetSettings[sectionDef.parent]) targetSettings[sectionDef.parent] = {};
            arr = targetSettings[sectionDef.parent][sectionDef.key] || [];
            targetSettings[sectionDef.parent][sectionDef.key] = arr;
        } else {
            arr = targetSettings[sectionKey] || [];
            targetSettings[sectionKey] = arr;
        }
        const newItem = {};
        for (const [fieldKey, fieldDef] of Object.entries(sectionDef.fields)) {
            switch (fieldDef.type) {
                case 'boolean': newItem[fieldKey] = false; break;
                case 'number': newItem[fieldKey] = 0; break;
                default: newItem[fieldKey] = '';
            }
        }
        arr.push(newItem);
        renderSettings();
    }
    function removeArrayItem(sectionKey, index) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr = sectionDef.parent ? targetSettings[sectionDef.parent]?.[sectionDef.key] : targetSettings[sectionKey];
        if (arr && arr.length > index) { arr.splice(index, 1); renderSettings(); }
    }
    function renderArraySection(sectionKey, sectionDef) {
        let items, basePath;
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        if (sectionDef.parent) {
            // For nested array sections like homeShelves.shelves
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionDef.parent]?.[sectionDef.key] || [];
            } else {
                items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
            }
            basePath = sectionDef.parent+'.'+sectionDef.key;
        } else {
            // For top-level array sections
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionKey] || [];
            } else {
                items = currentSettings[sectionKey] || [];
            }
            basePath = sectionKey;
        }
        const itemsHtml = items.map((item, index) => {
            const fieldsHtml = Object.entries(sectionDef.fields).map(([fieldKey, fieldDef]) => '<div class="form-group"><label class="form-label">'+fieldDef.label+'</label>'+renderInput(fieldKey, fieldDef, item[fieldKey], basePath+'.'+index, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+'</div>').join('');
            return '<div class="array-item"><div class="array-item-header"><div class="array-item-title">'+(item.name || item.id || 'Item '+(index+1))+'</div><div class="array-item-actions"><button class="btn btn-sm btn-danger" onclick="removeArrayItem(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button></div></div><div class="grid grid-2">'+fieldsHtml+'</div></div>';
        }).join('');
        return '<div class="array-items">'+itemsHtml+'<button class="add-item-btn" onclick="addArrayItem(\''+sectionKey+'\')"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add '+sectionDef.label.replace(/s$/, '')+'</button></div>';
    }
    function renderObjectSection(sectionKey, sectionDef) {
        // Use userSettings for per-user sections when a user is selected
        let sectionData;
        if (selectedUserId && userSettings && perUserSections.includes(sectionKey)) {
            sectionData = userSettings[sectionKey] || {};
        } else {
            sectionData = currentSettings[sectionKey] || {};
        }
        return Object.entries(sectionDef.fields).map(([fieldKey, fieldDef]) => {
            const fieldError = getFieldError(sectionKey, fieldKey);
            const invalidClass = fieldError ? ' invalid' : '';
            const errorHtml = fieldError ? '<div class="validation-message"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+fieldError+'</div>' : '';
            return '<div class="form-group'+invalidClass+'"><label class="form-label">'+fieldDef.label+'</label>'+renderInput(fieldKey, fieldDef, sectionData[fieldKey], sectionKey, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+errorHtml+'</div>';
        }).join('');
    }
    function renderSection(sectionKey, sectionDef) {
        const isOpen = window.location.hash === '#'+sectionKey;
        const errorCount = getSectionErrorCount(sectionKey);
        const sectionMessages = validationErrors[sectionKey]?.messages || [];

        // Warning badge for section header
        const warningBadge = errorCount > 0 ? '<span class="section-warning">'+errorCount+'</span>' : '';

        // Section-level validation messages
        let messagesHtml = '';
        if (sectionMessages.length > 0) {
            messagesHtml = sectionMessages.map(msg =>
                '<div class="section-validation-msg"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+msg+'</div>'
            ).join('');
        }

        const contentHtml = sectionDef.is_array ? renderArraySection(sectionKey, sectionDef) : '<div class="grid grid-2">'+renderObjectSection(sectionKey, sectionDef)+'</div>';
        let nestedHtml = '';
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            // Only render as nested if parent matches AND section doesn't have its own group
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (selectedUserId && !perUserSections.includes(nestedKey)) continue;
                nestedHtml += '<div style="margin-top: 1.5rem;"><h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">'+nestedDef.label+'</h3>'+renderArraySection(nestedKey, nestedDef)+'</div>';
            }
        }
        return '<div class="section '+(isOpen ? 'open' : '')+'" id="section-'+sectionKey+'"><div class="section-header" onclick="toggleSection(this)"><div class="section-title">'+getIcon(sectionDef.icon)+sectionDef.label+warningBadge+'</div><svg class="section-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></div><div class="section-content">'+messagesHtml+contentHtml+nestedHtml+'</div></div>';
    }

    function renderSettings() {
        const container = document.getElementById('settingsContainer');

        // Run validation before rendering
        validationErrors = validateSettings();

        // Save currently open sections before re-rendering
        const openSections = new Set();
        container.querySelectorAll('.section.open').forEach(section => {
            const id = section.id.replace('section-', '');
            if (id) openSections.add(id);
        });

        // Add info banner when user is selected
        let bannerHtml = '';
        if (selectedUserId) {
            bannerHtml = '<div style="background: var(--accent-bg, #2563eb20); border: 1px solid var(--accent, #2563eb); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--accent, #2563eb)" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg><span>Editing user-specific settings. Only Playback, Home Shelves, and Filtering are shown.</span></div>';
        }

        // Add validation error banner if there are errors
        const totalErrors = Object.keys(validationErrors).length;
        if (totalErrors > 0 && !selectedUserId) {
            const errorSections = Object.keys(validationErrors).map(key => {
                const sectionDef = schema[key];
                return sectionDef?.label || key;
            }).join(', ');
            bannerHtml += '<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--danger)" stroke-width="2" style="flex-shrink: 0; margin-top: 2px;"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg><div><strong style="color: var(--danger);">Required settings missing</strong><p style="margin: 0.25rem 0 0; color: var(--text-secondary); font-size: 0.875rem;">Please complete all required fields before saving. Issues found in: '+errorSections+'</p></div></div>';
        }

        // Render sections grouped by their group property
        // Sections with their own group are shown at top level, even if they have a parent (for data access)
        let html = bannerHtml;
        for (const group of groups) {
            const groupSections = Object.entries(schema).filter(([key, def]) => {
                if (def.group !== group.id) return false;
                if (selectedUserId && !perUserSections.includes(key)) return false;
                return true;
            }).sort((a, b) => (a[1].order ?? 999) - (b[1].order ?? 999));

            if (groupSections.length === 0) continue;

            html += '<div class="settings-group"><h2 class="group-title">'+group.label+'</h2><div class="group-sections">'+groupSections.map(([key, def]) => renderSection(key, def)).join('')+'</div></div>';
        }

        container.innerHTML = html;

        // Restore previously open sections
        openSections.forEach(sectionKey => {
            const section = document.getElementById('section-'+sectionKey);
            if (section) section.classList.add('open');
        });

        if (window.location.hash) {
            const section = document.getElementById('section-'+window.location.hash.substring(1));
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    }
    async function saveAllSettings() {
        // Check for validation errors (only for global settings)
        if (!selectedUserId) {
            validationErrors = validateSettings();
            if (Object.keys(validationErrors).length > 0) {
                showToast('Cannot save: Please fix all required fields first', 'error');
                renderSettings();
                // Scroll to top to show the error banner
                document.getElementById('settingsContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
                return;
            }
        }

        try {
            if (selectedUserId && userSettings) {
                // Save user-specific settings
                const response = await fetch('/admin/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(userSettings)
                });
                if (response.ok) {
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                    showToast('User settings saved successfully');
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save user settings', 'error');
                }
            } else {
                // Save global settings
                const response = await fetch('/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json', 'X-PIN': currentSettings.server?.pin || '' },
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    showToast('Settings saved successfully');
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                }
            }
        } catch (e) { showToast('Failed to save settings: ' + e.message, 'error'); }
    }
    function resetSettings() {
        if (confirm('Reset all changes? This will revert to the last saved settings.')) {
            if (selectedUserId && originalUserSettings) {
                userSettings = JSON.parse(JSON.stringify(originalUserSettings));
            } else {
                currentSettings = JSON.parse(JSON.stringify(originalSettings));
            }
            renderSettings();
            showToast('Settings reset to last saved state');
        }
    }
    document.addEventListener('DOMContentLoaded', () => { renderSettings(); });
    window.addEventListener('hashchange', () => {
        const hash = window.location.hash.substring(1);
        if (hash) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('open'));
            const section = document.getElementById('section-'+hash);
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    });
</script>
{{end}}
