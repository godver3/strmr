{{template "base" .}}

{{define "title"}}Settings - strmr Admin{{end}}

{{define "content"}}
<div class="page-header" style="display: flex; align-items: center; justify-content: space-between;">
    <div>
        <h1>Settings</h1>
        <p>Configure your strmr server</p>
    </div>
    <div style="display: flex; gap: 0.5rem; align-items: center;">
        <select id="userSelector" class="form-select" style="min-width: 180px;" onchange="handleUserChange(this.value)">
            <option value="">Global Defaults</option>
            {{range .Users}}
            <option value="{{.ID}}">{{.Name}}</option>
            {{end}}
        </select>
        <button class="btn btn-primary" onclick="saveAllSettings()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save
        </button>
    </div>
</div>

<div id="settingsContainer">
    <div style="display: flex; align-items: center; justify-content: center; padding: 2rem;">
        <div class="spinner"></div>
    </div>
</div>
{{end}}

{{define "scripts"}}
<script>
    let currentSettings = {{json .Settings}};
    let schema = {{json .Schema}};
    let groups = {{json .Groups}};
    let originalSettings = JSON.parse(JSON.stringify(currentSettings));
    let selectedUserId = '';
    let userSettings = null;
    let originalUserSettings = null;
    let profilesData = []; // Profiles with PIN status

    // Sections that are per-user (when a user is selected, only show these)
    // Note: liveTV settings (favorites, hidden channels) are managed in-app, not via this UI
    const perUserSections = ['playback', 'homeShelves', 'homeShelves.shelves', 'filtering', 'liveTV'];

    // Validation state - stores errors by section and field
    let validationErrors = {};

    // Check if a value is empty/missing
    function isEmpty(val) {
        if (val === undefined || val === null) return true;
        if (typeof val === 'string') return val.trim() === '';
        if (typeof val === 'number') return false; // 0 is valid for numbers
        if (Array.isArray(val)) return val.length === 0;
        return false;
    }

    // Check if an array has at least one enabled item
    function hasEnabledItem(arr) {
        if (!Array.isArray(arr)) return false;
        return arr.some(item => item.enabled === true);
    }

    // Validate all settings and return errors object
    function validateSettings() {
        const errors = {};

        // Skip validation for user-specific settings
        if (selectedUserId) return errors;

        const serviceMode = currentSettings.streaming?.serviceMode || 'debrid';
        const needsDebrid = serviceMode === 'debrid' || serviceMode === 'hybrid';
        const needsUsenet = serviceMode === 'usenet' || serviceMode === 'hybrid';

        // Server Settings - all required
        const serverErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.server?.host)) serverErrors.fields.host = 'Host is required';
        if (isEmpty(currentSettings.server?.port) && currentSettings.server?.port !== 0) serverErrors.fields.port = 'Port is required';
        if (isEmpty(currentSettings.server?.pin)) serverErrors.fields.pin = 'PIN is required';
        if (Object.keys(serverErrors.fields).length > 0) errors.server = serverErrors;

        // Streaming - all required
        const streamingErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.streaming?.serviceMode)) streamingErrors.fields.serviceMode = 'Service mode is required';
        if (Object.keys(streamingErrors.fields).length > 0) errors.streaming = streamingErrors;

        // Debrid Providers - at least one enabled if debrid/hybrid mode
        if (needsDebrid) {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                errors.debridProviders = {
                    fields: {},
                    messages: ['At least one enabled debrid provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Usenet Providers - at least one enabled if usenet/hybrid mode
        if (needsUsenet) {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                errors.usenet = {
                    fields: {},
                    messages: ['At least one enabled usenet provider is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Content Filtering - if service priority selected, must have enabled provider of that type
        const servicePriority = currentSettings.filtering?.servicePriority;
        if (servicePriority === 'usenet') {
            const usenetProviders = currentSettings.usenet || [];
            if (!hasEnabledItem(usenetProviders)) {
                if (!errors.filtering) errors.filtering = { fields: {}, messages: [] };
                errors.filtering.fields.servicePriority = 'Usenet priority requires an enabled usenet provider';
            }
        } else if (servicePriority === 'debrid') {
            const debridProviders = currentSettings.streaming?.debridProviders || [];
            if (!hasEnabledItem(debridProviders)) {
                if (!errors.filtering) errors.filtering = { fields: {}, messages: [] };
                errors.filtering.fields.servicePriority = 'Debrid priority requires an enabled debrid provider';
            }
        }

        // Indexers - required if usenet/hybrid mode
        if (needsUsenet) {
            const indexers = currentSettings.indexers || [];
            if (!hasEnabledItem(indexers)) {
                errors.indexers = {
                    fields: {},
                    messages: ['At least one enabled indexer is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Torrent Scrapers - required if debrid/hybrid mode
        if (needsDebrid) {
            const scrapers = currentSettings.torrentScrapers || [];
            if (!hasEnabledItem(scrapers)) {
                errors.torrentScrapers = {
                    fields: {},
                    messages: ['At least one enabled scraper is required for ' + serviceMode + ' mode']
                };
            }
        }

        // Metadata - all required
        const metadataErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.metadata?.tvdbApiKey)) metadataErrors.fields.tvdbApiKey = 'TVDB API Key is required';
        if (isEmpty(currentSettings.metadata?.tmdbApiKey)) metadataErrors.fields.tmdbApiKey = 'TMDB API Key is required';
        if (Object.keys(metadataErrors.fields).length > 0) errors.metadata = metadataErrors;

        // Cache - all required
        const cacheErrors = { fields: {}, messages: [] };
        if (isEmpty(currentSettings.cache?.directory)) cacheErrors.fields.directory = 'Cache directory is required';
        if (Object.keys(cacheErrors.fields).length > 0) errors.cache = cacheErrors;

        // Import Settings - all required (numbers can be 0, so just check existence)
        const importErrors = { fields: {}, messages: [] };
        if (currentSettings.import?.rarMaxWorkers === undefined) importErrors.fields.rarMaxWorkers = 'RAR Max Workers is required';
        if (currentSettings.import?.rarMaxCacheSizeMb === undefined) importErrors.fields.rarMaxCacheSizeMb = 'RAR Cache Size is required';
        if (currentSettings.import?.rarMaxMemoryGB === undefined) importErrors.fields.rarMaxMemoryGB = 'RAR Max Memory is required';
        if (Object.keys(importErrors.fields).length > 0) errors.import = importErrors;

        return errors;
    }

    // Get error count for a section
    function getSectionErrorCount(sectionKey) {
        const sectionErrors = validationErrors[sectionKey];
        if (!sectionErrors) return 0;
        const fieldCount = Object.keys(sectionErrors.fields || {}).length;
        const msgCount = (sectionErrors.messages || []).length;
        return fieldCount + msgCount;
    }

    // Check if a specific field has an error
    function getFieldError(sectionKey, fieldKey) {
        return validationErrors[sectionKey]?.fields?.[fieldKey] || null;
    }

    async function handleUserChange(userId) {
        selectedUserId = userId;
        if (userId) {
            // Load user-specific settings
            try {
                const response = await fetch('/admin/api/user-settings?userId=' + encodeURIComponent(userId));
                if (response.ok) {
                    userSettings = await response.json();
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                } else {
                    showToast('Failed to load user settings', 'error');
                    userSettings = null;
                    originalUserSettings = null;
                }
            } catch (e) {
                showToast('Failed to load user settings: ' + e.message, 'error');
                userSettings = null;
                originalUserSettings = null;
            }
        } else {
            userSettings = null;
            originalUserSettings = null;
        }
        renderSettings();
    }

    const icons = {
        'server': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>',
        'download': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>',
        'search': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        'magnet': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><path d="M22 7l-10 7L2 7"/></svg>',
        'film': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/></svg>',
        'database': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>',
        'folder': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
        'play-circle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>',
        'cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
        'upload': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>',
        'download-cloud': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="8 17 12 21 16 17"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"/></svg>',
        'shuffle': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>',
        'play': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>',
        'tv': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>',
        'layout': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>',
        'list': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        'filter': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>',
        'monitor': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>',
        'users': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>',
        'lock': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>',
        'unlock': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>',
    };

    function getIcon(name) { return icons[name] || icons['server']; }

    // Map section keys to user settings structure
    function mapToUserSettingsPath(path) {
        // homeShelves.shelves.0.enabled -> homeShelves.shelves.0.enabled (same)
        // playback.preferredPlayer -> playback.preferredPlayer (same)
        // filtering.maxSizeMovieGb -> filtering.maxSizeMovieGb (same)
        return path;
    }

    function getValue(path) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If user selected and this is a per-user section, use userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let val = userSettings;
            for (const key of keys) {
                if (val === undefined || val === null) return undefined;
                val = val[key];
            }
            return val;
        }

        // Otherwise use global settings
        let val = currentSettings;
        for (const key of keys) {
            if (val === undefined || val === null) return undefined;
            val = val[key];
        }
        return val;
    }
    function setValue(path, value) {
        const keys = path.split('.');
        const topKey = keys[0];

        // If user selected and this is a per-user section, update userSettings
        if (selectedUserId && userSettings && perUserSections.includes(topKey)) {
            let obj = userSettings;
            for (let i = 0; i < keys.length - 1; i++) {
                if (obj[keys[i]] === undefined) obj[keys[i]] = {};
                obj = obj[keys[i]];
            }
            obj[keys[keys.length - 1]] = value;
            return;
        }

        // Otherwise update global settings
        let obj = currentSettings;
        for (let i = 0; i < keys.length - 1; i++) {
            if (obj[keys[i]] === undefined) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
    }
    function renderInput(fieldKey, fieldDef, value, basePath, sectionKey) {
        const id = (basePath + '_' + fieldKey).replace(/\./g, '_');
        const isReadonly = fieldDef.readonly ? 'readonly' : '';
        const fieldError = getFieldError(sectionKey, fieldKey);
        const invalidClass = fieldError ? ' invalid' : '';
        switch (fieldDef.type) {
            case 'boolean':
                return '<label class="toggle"><input type="checkbox" id="'+id+'" '+(value ? 'checked' : '')+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.checked)"><span class="toggle-slider"></span></label>';
            case 'select':
                const options = fieldDef.options.map(opt => '<option value="'+opt+'" '+(value === opt ? 'selected' : '')+'>'+opt+'</option>').join('');
                return '<select class="form-select'+invalidClass+'" id="'+id+'" onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">'+options+'</select>';
            case 'number':
                return '<input type="number" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || 0)+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', parseFloat(this.value) || 0)">';
            case 'password':
                return '<input type="password" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
            case 'tags':
                const tags = Array.isArray(value) ? value : [];
                const tagsHtml = tags.map(tag => '<span class="tag">'+tag+'<span class="tag-remove" onclick="removeTag(\''+basePath+'\', \''+fieldKey+'\', \''+tag+'\')">&times;</span></span>').join('');
                return '<div class="tags-input'+invalidClass+'" id="'+id+'_container">'+tagsHtml+'<input type="text" placeholder="Add tag..." onkeydown="handleTagInput(event, \''+basePath+'\', \''+fieldKey+'\')"></div>';
            default:
                return '<input type="text" class="form-input'+invalidClass+'" id="'+id+'" value="'+(value || '')+'" '+isReadonly+' onchange="handleFieldChange(\''+basePath+'\', \''+fieldKey+'\', this.value)">';
        }
    }
    function handleFieldChange(basePath, fieldKey, value) {
        setValue(basePath ? basePath+'.'+fieldKey : fieldKey, value);
        // Re-render to update validation indicators (renderSettings runs validation)
        renderSettings();
    }
    function handleTagInput(event, basePath, fieldKey) {
        if (event.key === 'Enter' || event.key === ',') {
            event.preventDefault();
            const tag = event.target.value.trim();
            if (tag) { addTag(basePath, fieldKey, tag); event.target.value = ''; }
        }
    }
    function addTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = getValue(fullPath) || [];
        if (!tags.includes(tag)) { tags.push(tag); setValue(fullPath, tags); renderSettings(); }
    }
    function removeTag(basePath, fieldKey, tag) {
        const fullPath = basePath ? basePath+'.'+fieldKey : fieldKey;
        let tags = (getValue(fullPath) || []).filter(t => t !== tag);
        setValue(fullPath, tags);
        renderSettings();
    }
    function addArrayItem(sectionKey) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr;
        if (sectionDef.parent) {
            if (!targetSettings[sectionDef.parent]) targetSettings[sectionDef.parent] = {};
            arr = targetSettings[sectionDef.parent][sectionDef.key] || [];
            targetSettings[sectionDef.parent][sectionDef.key] = arr;
        } else {
            arr = targetSettings[sectionKey] || [];
            targetSettings[sectionKey] = arr;
        }
        const newItem = {};
        for (const [fieldKey, fieldDef] of Object.entries(sectionDef.fields)) {
            switch (fieldDef.type) {
                case 'boolean': newItem[fieldKey] = false; break;
                case 'number': newItem[fieldKey] = 0; break;
                case 'select': newItem[fieldKey] = fieldDef.options?.[0] || ''; break;
                default: newItem[fieldKey] = '';
            }
        }
        arr.push(newItem);
        renderSettings();
    }
    function removeArrayItem(sectionKey, index) {
        const sectionDef = schema[sectionKey];
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));
        const targetSettings = (selectedUserId && userSettings && isPerUserSection) ? userSettings : currentSettings;

        let arr = sectionDef.parent ? targetSettings[sectionDef.parent]?.[sectionDef.key] : targetSettings[sectionKey];
        if (arr && arr.length > index) { arr.splice(index, 1); renderSettings(); }
    }
    // Test provider functions
    async function testProvider(sectionKey, index) {
        const btn = document.getElementById('test-btn-'+sectionKey+'-'+index);
        const resultSpan = document.getElementById('test-result-'+sectionKey+'-'+index);
        if (!btn) return;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span> Testing...';
        resultSpan.textContent = '';
        resultSpan.className = 'test-result';

        let endpoint, payload;
        const sectionDef = schema[sectionKey];
        let items;

        if (sectionDef.parent) {
            items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
        } else {
            items = currentSettings[sectionKey] || [];
        }
        const item = items[index];
        if (!item) {
            btn.disabled = false;
            btn.textContent = 'Test';
            resultSpan.textContent = 'Item not found';
            resultSpan.className = 'test-result error';
            return;
        }

        switch(sectionKey) {
            case 'indexers':
                endpoint = '/admin/api/test/indexer';
                payload = { url: item.url, apiKey: item.apiKey, name: item.name };
                break;
            case 'torrentScrapers':
                endpoint = '/admin/api/test/scraper';
                payload = { name: item.name, type: item.type, url: item.url, apiKey: item.apiKey };
                break;
            case 'usenet':
                endpoint = '/admin/api/test/usenet-provider';
                payload = {
                    name: item.name,
                    host: item.host,
                    port: item.port,
                    ssl: item.ssl,
                    username: item.username,
                    password: item.password
                };
                break;
            case 'debridProviders':
                endpoint = '/admin/api/test/debrid-provider';
                payload = { name: item.name, provider: item.provider, apiKey: item.apiKey };
                break;
            default:
                btn.disabled = false;
                btn.textContent = 'Test';
                resultSpan.textContent = 'Unknown section';
                resultSpan.className = 'test-result error';
                return;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            btn.disabled = false;
            btn.textContent = 'Test';

            if (result.success) {
                resultSpan.textContent = result.message || 'Success';
                resultSpan.className = 'test-result success';
            } else {
                resultSpan.textContent = result.error || 'Test failed';
                resultSpan.className = 'test-result error';
            }
        } catch (e) {
            btn.disabled = false;
            btn.textContent = 'Test';
            resultSpan.textContent = 'Error: ' + e.message;
            resultSpan.className = 'test-result error';
        }
    }

    // Testable sections
    const testableSections = ['indexers', 'torrentScrapers', 'usenet', 'debridProviders'];

    // Deep equality check for comparing values
    function deepEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return a == b;
        if (typeof a !== typeof b) return false;
        if (typeof a !== 'object') return false;
        if (Array.isArray(a) !== Array.isArray(b)) return false;

        if (Array.isArray(a)) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) return false;
            }
            return true;
        }

        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) return false;

        for (const key of keysA) {
            if (!keysB.includes(key) || !deepEqual(a[key], b[key])) return false;
        }
        return true;
    }

    // Check if a specific section has unsaved changes
    function sectionHasChanges(sectionKey) {
        const sectionDef = schema[sectionKey];
        if (!sectionDef) return false;

        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        let hasDirectChanges = false;

        if (selectedUserId && isPerUserSection) {
            // Compare user settings
            if (!userSettings || !originalUserSettings) return false;

            if (sectionDef.parent) {
                const currentVal = userSettings[sectionDef.parent]?.[sectionDef.key];
                const originalVal = originalUserSettings[sectionDef.parent]?.[sectionDef.key];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            } else {
                const currentVal = userSettings[sectionKey];
                const originalVal = originalUserSettings[sectionKey];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            }
        } else {
            // Compare global settings
            if (sectionDef.parent) {
                const currentVal = currentSettings[sectionDef.parent]?.[sectionDef.key];
                const originalVal = originalSettings[sectionDef.parent]?.[sectionDef.key];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            } else {
                const currentVal = currentSettings[sectionKey];
                const originalVal = originalSettings[sectionKey];
                hasDirectChanges = !deepEqual(currentVal, originalVal);
            }
        }

        if (hasDirectChanges) return true;

        // Also check nested sections that are rendered within this section
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (sectionHasChanges(nestedKey)) return true;
            }
        }

        return false;
    }

    // Save a specific section (still saves all, but used for UX)
    async function saveSection(sectionKey, event) {
        event.stopPropagation(); // Don't toggle section when clicking save

        const btn = event.target.closest('.section-save-btn');
        if (!btn) return;

        const originalHtml = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-small"></span>';

        try {
            if (selectedUserId && userSettings) {
                // Save user-specific settings
                const response = await fetch('/admin/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(userSettings)
                });
                if (response.ok) {
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
                    showToast('Settings saved successfully');
                    setTimeout(() => renderSettings(), 500);
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save settings', 'error');
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            } else {
                // Save global settings
                const response = await fetch('/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json', 'X-PIN': originalSettings.server?.pin || '' },
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
                    showToast('Settings saved successfully');
                    setTimeout(() => renderSettings(), 500);
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            }
        } catch (e) {
            showToast('Failed to save settings: ' + e.message, 'error');
            btn.innerHTML = originalHtml;
            btn.disabled = false;
        }
    }

    function renderArraySection(sectionKey, sectionDef) {
        let items, basePath;
        const parentKey = sectionDef.parent;
        const isPerUserSection = perUserSections.includes(sectionKey) || (parentKey && perUserSections.includes(parentKey));

        if (sectionDef.parent) {
            // For nested array sections like homeShelves.shelves
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionDef.parent]?.[sectionDef.key] || [];
            } else {
                items = currentSettings[sectionDef.parent]?.[sectionDef.key] || [];
            }
            basePath = sectionDef.parent+'.'+sectionDef.key;
        } else {
            // For top-level array sections
            if (selectedUserId && userSettings && isPerUserSection) {
                items = userSettings[sectionKey] || [];
            } else {
                items = currentSettings[sectionKey] || [];
            }
            basePath = sectionKey;
        }
        const isTestable = testableSections.includes(sectionKey);
        const itemsHtml = items.map((item, index) => {
            const fieldsHtml = Object.entries(sectionDef.fields)
                .sort((a, b) => (a[1].order || 0) - (b[1].order || 0))
                .map(([fieldKey, fieldDef]) => {
                const showWhen = fieldDef.showWhen;
                if (showWhen) {
                    let shouldShow = false;
                    if (showWhen.operator === 'or' && Array.isArray(showWhen.conditions)) {
                        shouldShow = showWhen.conditions.some(cond => item[cond.field] === cond.value);
                    } else {
                        shouldShow = item[showWhen.field] === showWhen.value;
                    }
                    if (!shouldShow) return '';
                }
                return '<div class="form-group"><label class="form-label">'+fieldDef.label+'</label>'+renderInput(fieldKey, fieldDef, item[fieldKey], basePath+'.'+index, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+'</div>';
            }).join('');
            const testBtn = isTestable ? '<button id="test-btn-'+sectionKey+'-'+index+'" class="btn btn-sm btn-secondary" onclick="testProvider(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Test</button>' : '';
            const testResult = isTestable ? '<span id="test-result-'+sectionKey+'-'+index+'" class="test-result"></span>' : '';
            return '<div class="array-item"><div class="array-item-header"><div class="array-item-title">'+(item.name || item.id || 'Item '+(index+1))+'</div><div class="array-item-actions">'+testBtn+testResult+'<button class="btn btn-sm btn-danger" onclick="removeArrayItem(\''+sectionKey+'\', '+index+')"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button></div></div><div class="grid grid-2">'+fieldsHtml+'</div></div>';
        }).join('');
        return '<div class="array-items">'+itemsHtml+'<button class="add-item-btn" onclick="addArrayItem(\''+sectionKey+'\')"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add '+sectionDef.label.replace(/s$/, '')+'</button></div>';
    }
    function renderObjectSection(sectionKey, sectionDef) {
        // Use userSettings for per-user sections when a user is selected
        let sectionData;
        if (selectedUserId && userSettings && perUserSections.includes(sectionKey)) {
            sectionData = userSettings[sectionKey] || {};
        } else {
            sectionData = currentSettings[sectionKey] || {};
        }
        return Object.entries(sectionDef.fields).map(([fieldKey, fieldDef]) => {
            const fieldError = getFieldError(sectionKey, fieldKey);
            const invalidClass = fieldError ? ' invalid' : '';
            const errorHtml = fieldError ? '<div class="validation-message"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+fieldError+'</div>' : '';
            return '<div class="form-group'+invalidClass+'"><label class="form-label">'+fieldDef.label+'</label>'+renderInput(fieldKey, fieldDef, sectionData[fieldKey], sectionKey, sectionKey)+(fieldDef.description ? '<p class="form-hint">'+fieldDef.description+'</p>' : '')+errorHtml+'</div>';
        }).join('');
    }
    function renderSection(sectionKey, sectionDef) {
        const isOpen = window.location.hash === '#'+sectionKey;
        const errorCount = getSectionErrorCount(sectionKey);
        const sectionMessages = validationErrors[sectionKey]?.messages || [];
        const hasChanges = sectionHasChanges(sectionKey);

        // Warning badge for section header
        const warningBadge = errorCount > 0 ? '<span class="section-warning">'+errorCount+'</span>' : '';

        // Save button for section header (only show when section has changes and not a custom section)
        const saveBtn = (hasChanges && !sectionDef.custom) ? '<button class="section-save-btn" onclick="saveSection(\''+sectionKey+'\', event)" title="Save changes"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg> Save</button>' : '';

        // Section-level validation messages
        let messagesHtml = '';
        if (sectionMessages.length > 0) {
            messagesHtml = sectionMessages.map(msg =>
                '<div class="section-validation-msg"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>'+msg+'</div>'
            ).join('');
        }

        // Handle custom sections (like profiles)
        let contentHtml;
        if (sectionDef.custom && sectionKey === 'profiles') {
            contentHtml = renderProfilesSection();
        } else {
            contentHtml = sectionDef.is_array ? renderArraySection(sectionKey, sectionDef) : '<div class="grid grid-2">'+renderObjectSection(sectionKey, sectionDef)+'</div>';
        }
        let nestedHtml = '';
        for (const [nestedKey, nestedDef] of Object.entries(schema)) {
            // Only render as nested if parent matches AND section doesn't have its own group
            if (nestedDef.parent === sectionKey && !nestedDef.group) {
                if (selectedUserId && !perUserSections.includes(nestedKey)) continue;
                nestedHtml += '<div style="margin-top: 1.5rem;"><h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">'+nestedDef.label+'</h3>'+renderArraySection(nestedKey, nestedDef)+'</div>';
            }
        }
        return '<div class="section '+(isOpen ? 'open' : '')+(hasChanges ? ' has-changes' : '')+'" id="section-'+sectionKey+'"><div class="section-header" onclick="toggleSection(this)"><div class="section-title">'+getIcon(sectionDef.icon)+sectionDef.label+warningBadge+'</div><div class="section-header-actions">'+saveBtn+'<svg class="section-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></div></div><div class="section-content">'+messagesHtml+contentHtml+nestedHtml+'</div></div>';
    }

    // Profile management functions
    async function loadProfiles() {
        try {
            const response = await fetch('/admin/api/profiles');
            if (response.ok) {
                profilesData = await response.json();
            } else {
                console.error('Failed to load profiles');
                profilesData = [];
            }
        } catch (e) {
            console.error('Error loading profiles:', e);
            profilesData = [];
        }
    }

    async function setProfilePin(profileId, pin) {
        try {
            const response = await fetch('/admin/api/profiles/pin?profileId=' + encodeURIComponent(profileId), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pin: pin })
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('PIN set successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to set PIN', 'error');
            }
        } catch (e) {
            showToast('Error setting PIN: ' + e.message, 'error');
        }
    }

    async function clearProfilePin(profileId) {
        try {
            const response = await fetch('/admin/api/profiles/pin?profileId=' + encodeURIComponent(profileId), {
                method: 'DELETE'
            });
            if (response.ok) {
                const updated = await response.json();
                const idx = profilesData.findIndex(p => p.id === profileId);
                if (idx >= 0) profilesData[idx] = updated;
                showToast('PIN removed successfully');
                renderSettings();
            } else {
                const error = await response.text();
                showToast(error || 'Failed to remove PIN', 'error');
            }
        } catch (e) {
            showToast('Error removing PIN: ' + e.message, 'error');
        }
    }

    function handlePinFormSubmit(event, profileId) {
        event.preventDefault();
        const input = document.getElementById('pin-input-' + profileId);
        const pin = input.value.trim();
        if (pin.length < 4) {
            showToast('PIN must be at least 4 characters', 'error');
            return;
        }
        setProfilePin(profileId, pin);
        input.value = '';
    }

    function renderProfilesSection() {
        if (profilesData.length === 0) {
            return '<div style="color: var(--text-secondary); text-align: center; padding: 2rem;">No profiles found. Profiles can be created in the app.</div>';
        }

        return '<div class="array-items">' + profilesData.map(profile => {
            const avatarColor = profile.color || '#3B82F6';
            const initial = (profile.name || 'U').charAt(0).toUpperCase();
            const pinStatus = profile.hasPin
                ? '<span style="display: inline-flex; align-items: center; gap: 0.25rem; color: var(--success); font-size: 0.875rem;">' + icons.lock + ' PIN Protected</span>'
                : '<span style="display: inline-flex; align-items: center; gap: 0.25rem; color: var(--text-secondary); font-size: 0.875rem;">' + icons.unlock + ' No PIN</span>';

            const pinActions = profile.hasPin
                ? '<button class="btn btn-sm btn-danger" onclick="if(confirm(\'Remove PIN from this profile?\')) clearProfilePin(\'' + profile.id + '\')">Remove PIN</button>'
                : '<form onsubmit="handlePinFormSubmit(event, \'' + profile.id + '\')">' +
                  '<input type="password" id="pin-input-' + profile.id + '" class="form-input" placeholder="Enter PIN">' +
                  '<button type="submit" class="btn btn-sm btn-primary">Set PIN</button>' +
                  '</form>';

            return '<div class="array-item">' +
                '<div class="array-item-header profile-header">' +
                '<div class="array-item-title" style="display: flex; align-items: center; gap: 0.75rem;">' +
                '<div style="width: 36px; height: 36px; border-radius: 50%; background: ' + avatarColor + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 1rem;">' + initial + '</div>' +
                '<div>' +
                '<div style="font-weight: 600;">' + profile.name + '</div>' +
                '<div style="font-size: 0.75rem; color: var(--text-secondary);">ID: ' + profile.id + '</div>' +
                '</div>' +
                '</div>' +
                '<div class="profile-pin-status">' + pinStatus + '</div>' +
                '</div>' +
                '<div class="profile-pin-section">' +
                '<div class="profile-pin-label">Profile PIN Protection</div>' +
                '<div class="profile-pin-actions">' + pinActions + '</div>' +
                '</div>' +
                '</div>';
        }).join('') + '</div>';
    }

    function renderSettings() {
        const container = document.getElementById('settingsContainer');

        // Run validation before rendering
        validationErrors = validateSettings();

        // Save currently open sections before re-rendering
        const openSections = new Set();
        container.querySelectorAll('.section.open').forEach(section => {
            const id = section.id.replace('section-', '');
            if (id) openSections.add(id);
        });

        // Add info banner when user is selected
        let bannerHtml = '';
        if (selectedUserId) {
            bannerHtml = '<div style="background: var(--accent-bg, #2563eb20); border: 1px solid var(--accent, #2563eb); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--accent, #2563eb)" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg><span>Editing user-specific settings. Only Playback, Home Shelves, and Filtering are shown.</span></div>';
        }

        // Add validation warning banner if there are issues
        const totalErrors = Object.keys(validationErrors).length;
        if (totalErrors > 0 && !selectedUserId) {
            const errorSections = Object.keys(validationErrors).map(key => {
                const sectionDef = schema[key];
                return sectionDef?.label || key;
            }).join(', ');
            bannerHtml += '<div style="background: rgba(234, 179, 8, 0.1); border: 1px solid var(--warning, #eab308); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;"><svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--warning, #eab308)" stroke-width="2" style="flex-shrink: 0; margin-top: 2px;"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><div><strong style="color: var(--warning, #eab308);">Configuration warning</strong><p style="margin: 0.25rem 0 0; color: var(--text-secondary); font-size: 0.875rem;">Some recommended settings may be incomplete. Issues found in: '+errorSections+'</p></div></div>';
        }

        // Render sections grouped by their group property
        // Sections with their own group are shown at top level, even if they have a parent (for data access)
        let html = bannerHtml;
        for (const group of groups) {
            const groupSections = Object.entries(schema).filter(([key, def]) => {
                if (def.group !== group.id) return false;
                if (selectedUserId && !perUserSections.includes(key)) return false;
                return true;
            }).sort((a, b) => (a[1].order ?? 999) - (b[1].order ?? 999));

            if (groupSections.length === 0) continue;

            html += '<div class="settings-group"><h2 class="group-title">'+group.label+'</h2><div class="group-sections">'+groupSections.map(([key, def]) => renderSection(key, def)).join('')+'</div></div>';
        }

        container.innerHTML = html;

        // Restore previously open sections
        openSections.forEach(sectionKey => {
            const section = document.getElementById('section-'+sectionKey);
            if (section) section.classList.add('open');
        });

        if (window.location.hash) {
            const section = document.getElementById('section-'+window.location.hash.substring(1));
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    }
    async function saveAllSettings() {
        try {
            if (selectedUserId && userSettings) {
                // Save user-specific settings
                const response = await fetch('/admin/api/user-settings?userId=' + encodeURIComponent(selectedUserId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(userSettings)
                });
                if (response.ok) {
                    originalUserSettings = JSON.parse(JSON.stringify(userSettings));
                    showToast('User settings saved successfully');
                } else {
                    const result = await response.text();
                    showToast(result || 'Failed to save user settings', 'error');
                }
            } else {
                // Save global settings - use original PIN for auth since we might be changing it
                const response = await fetch('/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json', 'X-PIN': originalSettings.server?.pin || '' },
                    body: JSON.stringify(currentSettings)
                });
                if (response.ok) {
                    originalSettings = JSON.parse(JSON.stringify(currentSettings));
                    showToast('Settings saved successfully');
                } else {
                    const result = await response.json();
                    showToast(result.error || 'Failed to save settings', 'error');
                }
            }
        } catch (e) { showToast('Failed to save settings: ' + e.message, 'error'); }
    }
    function resetSettings() {
        if (confirm('Reset all changes? This will revert to the last saved settings.')) {
            if (selectedUserId && originalUserSettings) {
                userSettings = JSON.parse(JSON.stringify(originalUserSettings));
            } else {
                currentSettings = JSON.parse(JSON.stringify(originalSettings));
            }
            renderSettings();
            showToast('Settings reset to last saved state');
        }
    }
    document.addEventListener('DOMContentLoaded', async () => {
        await loadProfiles();
        renderSettings();
    });
    window.addEventListener('hashchange', () => {
        const hash = window.location.hash.substring(1);
        if (hash) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('open'));
            const section = document.getElementById('section-'+hash);
            if (section) { section.classList.add('open'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        }
    });
</script>
{{end}}
